<!DOCTYPE html>
<html lang=" ">
<head>
  <meta charset="utf-8" />
<link rel="icon" href="/images/rev_sheep.png " />
<title>almostSalted</title>
<meta name="referrer" content="no-referrer" />
<meta name="google-site-verification" content="_CsSd0yrTQQrdEyoybq1kZNTZbIVulPo3zdQnaqAR0Y" />
  
<link rel="stylesheet" href="/css/layout.css">

<meta name="generator" content="Hexo 6.1.0"></head>
<body>
  
<link rel="stylesheet" href="/css/header.css">


<div class="topBar">
  <img class="icon" src="/images/rev_sheep.png " />
  <div class="menu">
     
    <a href="/ ">home</a>
     
    <a href="/archives ">archives</a>
     
    <a href="/categories ">categories</a>
     
    <a href="/aboutme ">aboutme</a>
     
    <a href="/diary ">diary</a>
    
  </div>
</div>
<div class="blank"></div>
  <div class="wrapper">
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div id="post">
  <aside id="navigator">
    <ol class="anchor"><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#content"><span class="anchor-number">1.</span> <span class="anchor-text">Content</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#part-8---b-tree-leaf-node-format"><span class="anchor-number">1.1.</span> <span class="anchor-text">Part 8 - B-Tree leaf Node Format</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#alternative-table-formats"><span class="anchor-number">1.1.1.</span> <span class="anchor-text">Alternative Table Formats</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#leaf-node-format"><span class="anchor-number">1.1.2.</span> <span class="anchor-text">Leaf Node Format</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#accessing-leaf-node-fields"><span class="anchor-number">1.1.3.</span> <span class="anchor-text">Accessing Leaf Node Fields</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#changes-to-pager-and-table-objects"><span class="anchor-number">1.1.4.</span> <span class="anchor-text">Changes to Pager and Table Objects</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#changes-to-the-cursor-object"><span class="anchor-number">1.1.5.</span> <span class="anchor-text">Changes to the Cursor Object</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#insertion-into-a-leaf-node"><span class="anchor-number">1.1.6.</span> <span class="anchor-text">Insertion Into a Leaf Node</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#command-to-print-constants"><span class="anchor-number">1.1.7.</span> <span class="anchor-text">Command to Print Constants</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#tree-visualization"><span class="anchor-number">1.1.8.</span> <span class="anchor-text">Tree Visualization</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#next-time"><span class="anchor-number">1.1.9.</span> <span class="anchor-text">Next Time</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#complete-diff"><span class="anchor-number">1.1.10.</span> <span class="anchor-text">Complete Diff</span></a></li></ol></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#part-9---binary-search-and-duplicate-keys"><span class="anchor-number">1.2.</span> <span class="anchor-text">Part 9 - Binary Search and Duplicate Keys</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#part-10---splitting-a-leaf-node"><span class="anchor-number">1.3.</span> <span class="anchor-text">Part 10 - Splitting a Leaf Node</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#splitting-algorithm"><span class="anchor-number">1.3.1.</span> <span class="anchor-text">Splitting Algorithm</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#allocating-new-pages"><span class="anchor-number">1.3.2.</span> <span class="anchor-text">Allocating New Pages</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#leaf-node-sizes"><span class="anchor-number">1.3.3.</span> <span class="anchor-text">Leaf Node Sizes</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#creating-a-new-root"><span class="anchor-number">1.3.4.</span> <span class="anchor-text">Creating a New Root</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#internal-node-format"><span class="anchor-number">1.3.5.</span> <span class="anchor-text">Internal Node Format</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#keeping-track-of-the-root"><span class="anchor-number">1.3.6.</span> <span class="anchor-text">Keeping Track of the Root</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#printing-the-tree"><span class="anchor-number">1.3.7.</span> <span class="anchor-text">Printing the Tree</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#a-major-problem"><span class="anchor-number">1.3.8.</span> <span class="anchor-text">A Major Problem</span></a></li></ol></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#part-11--recursively-searching-the-b-tree"><span class="anchor-number">1.4.</span> <span class="anchor-text">Part 11 -Recursively Searching the B-Tree</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#tests"><span class="anchor-number">1.4.1.</span> <span class="anchor-text">Tests</span></a></li></ol></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#part-12--scanning-a-multi-level-b-tree"><span class="anchor-number">1.5.</span> <span class="anchor-text">Part 12 -Scanning a Multi-Level B-Tree</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#part-13---updating-parent-node-after-a-split"><span class="anchor-number">1.6.</span> <span class="anchor-text">Part 13 - Updating Parent Node After a Split</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#part-14---splitting-a-internal-node"><span class="anchor-number">1.7.</span> <span class="anchor-text">Part 14 - Splitting a Internal Node</span></a></li></ol></li></ol>
  </aside>
  <div id="content">
    <div id="postHead">
      <h1>yourSql 2</h1>
      <div class="postDate">
        <img class="dateIcon" src="/images/clockicon.svg" />
        --2022.4.28
      </div>
        
        <div class="postCategory">
            <a href="/categories/translation/">translation</a>
        </div>
         
    </div>
    <div id="postBody">
      <h1 id="content">Content</h1>
<style>
    #table {
        margin: 0 auto;
        text-align: center;
        border: 1px solid grey;
        border-collapse: collapse;
        line-height: 1.6em;
    }
    #table th,#table td {
        border: 1px solid grey;
        padding: 0.5em;
    }
</style>
<p></br></p>
<h2 id="part-8---b-tree-leaf-node-format">Part 8 - B-Tree leaf Node Format</h2>
<p>我们即将把 table 的结构从存储 row 的无序数组转变为 B-Tree,这是一个相当大的改变以至于需要好几章来实现.在本章的末尾，我们将会定义叶子节点的布局，以及支持向只有一个节点的树中插入键值对.</p>
<p>不过首先让我们回想一下为什么转换到树结构.</p>
<h3 id="alternative-table-formats">Alternative Table Formats</h3>
<p>基于目前的存储格式，每页只存储 row(没有元数据)因此空间利用效率很高.插入也很快因为我们只需要插入到末尾.但是寻找指定的 row 只能通过遍历整个 table 来完成,并且如果我们想要删除 row,我们需要将删除的 row 之后的所有行前移以填补空缺.</p>
<p>如果我们以数组的形式存储 table,但是 row 通过 id 排序,我们可以使用二分查找指定的 id.但是插入操作会非常耗时，因为我们要移动很多行以腾出空间.</p>
<p>因此，我们将使用 tree 结构.树中的每一個节点可以包含可变数量的行,所以我们需要在节点中存储一些信息以表示它包含了多少行.此外还有不存储任何行的内部节点的空间开销.作为数据库文件变大的交换，我们得到了快速插入，删除和查找.</p>
<table id="table">
<thead>
<tr>
<th>
</th>
<th>
存储 row 的无序数组
</th>
<th>
存储 row 的有序数组
</th>
<th>
树的节点
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
page 存储的数据
</td>
<td>
仅数据
</td>
<td>
仅数据
</td>
<td>
元数据，主键值和数据
</td>
</tr>
<tr>
<td>
每页的行数
</td>
<td>
more
</td>
<td>
more
</td>
<td>
fewer
</td>
</tr>
<tr>
<td>
插入
</td>
<td>
O(1)
</td>
<td>
O(n)
</td>
<td>
O(log(n))
</td>
</tr>
<tr>
<td>
删除
</td>
<td>
O(n)
</td>
<td>
O(n)
</td>
<td>
O(log(n))
</td>
</tr>
<tr>
<td>
通过 id 查找
</td>
<td>
O(n)
</td>
<td>
O(log(n))
</td>
<td>
O(log(n))
</td>
</tr>
</tbody>
</table>
<p>内部节点和叶子节点拥有不同的布局，让我们定义一个枚举变量表示节点的类型.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//+typedef enum &#123; NODE_INTERNAL, NODE_LEAF &#125; NodeType;</span></span><br><span class="line"><span class="comment">// 译者注: 因为下文要求type大小为1字节，所以制定了enum大小为uint8_t,否则默认为4个字节</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> : <span class="type">uint8_t</span></span><br><span class="line">&#123;</span><br><span class="line">    NODE_INTERNAL,</span><br><span class="line">    NODE_LEAF</span><br><span class="line">&#125; NodeType;</span><br></pre></td></tr></table></figure>
<p>每一个节点对应着一页.内部节点存储着指向子节点的指针，该指针实际上是存储着该子节点的页的 page number(译者注:即下标).btree 向 pager 请求指定的 page number,pager 返回指向该页缓存的指针.页根据 page number 有序存储在数据库文件中.</p>
<p>节点需要在页的头部存储一些元数据.每个节点会存储它的类型,是否为根节点，和一个指向父节点的指针(用来寻找兄弟节点).我定义了常量来表示头部的每个字段的大小和偏移量.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Common Node Header Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> NODE_TYPE_SIZE = <span class="built_in">sizeof</span>(NodeType);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> NODE_TYPE_OFFSET = <span class="number">0</span>;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> IS_ROOT_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> IS_ROOT_OFFSET = NODE_TYPE_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> PARENT_POINTER_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint8_t</span> COMMON_NODE_HEADER_SIZE =</span><br><span class="line">+    NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;</span><br></pre></td></tr></table></figure>
<h3 id="leaf-node-format">Leaf Node Format</h3>
<p>除了这些通用的头部字段外，叶子节点需要存储包含的"cell"的数量.一个"cell"就是一个键值对.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Leaf Node Header Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_NUM_CELLS_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_HEADER_SIZE =</span><br><span class="line">+    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;</span><br></pre></td></tr></table></figure>
<p>叶子节点的 body 是 cell 数组.每个 cell 是一个键后面跟着一个值(一个序列化的行).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Leaf Node Body Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_KEY_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_KEY_OFFSET = <span class="number">0</span>;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_VALUE_SIZE = ROW_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_VALUE_OFFSET =</span><br><span class="line">+    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_MAX_CELLS =</span><br><span class="line">+    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;</span><br></pre></td></tr></table></figure>
<p>基于这些常量,这里是叶子节点目前布局:</p>
<p>Our leaf node format</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/leaf-node-format.png"><img src="https://cstack.github.io/db_tutorial/assets/images/leaf-node-format.png" alt="Our leaf node format"></a></p>
<p>在头部使用一整个字节表示一个 bool 值有点浪费空间，但是这会让通过代码获取这些值更容易一点.</p>
<p>还要注意末尾有一些被浪费的空间.我们在头部之后存储尽可能多的 cell,但是剩余的空间不能存储一整个 cell.我们不使用这片空间以避免把 cell 分割到两个节点.</p>
<h3 id="accessing-leaf-node-fields">Accessing Leaf Node Fields</h3>
<p>获取键，值和元数据的函数都涉及到使用我们刚刚定义的常量进行指针算数运算.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">leaf_node_num_cells</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + LEAF_NODE_NUM_CELLS_OFFSET;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span>* <span class="title">leaf_node_cell</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + LEAF_NODE_HEADER_SIZE + cell_num * LEAF_NODE_CELL_SIZE;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">leaf_node_key</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_cell</span>(node, cell_num);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span>* <span class="title">leaf_node_value</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_cell</span>(node, cell_num) + LEAF_NODE_KEY_SIZE;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">initialize_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123; *<span class="built_in">leaf_node_num_cells</span>(node) = <span class="number">0</span>; &#125;</span><br><span class="line">+</span><br></pre></td></tr></table></figure>
<h3 id="changes-to-pager-and-table-objects">Changes to Pager and Table Objects</h3>
<p>每个节点将确切地占据一页，即使页没满.这意味着我们的 pager 不再需要支持 读/写 未满的页了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-<span class="function"><span class="type">void</span> <span class="title">pager_flush</span><span class="params">(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size)</span> </span>&#123;</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">pager_flush</span><span class="params">(Pager* pager, <span class="type">uint32_t</span> page_num)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (pager-&gt;pages[page_num] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Tried to flush null page\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">@@ <span class="number">-242</span>,<span class="number">7</span> +<span class="number">337</span>,<span class="number">7</span> @@ <span class="function"><span class="type">void</span> <span class="title">pager_flush</span><span class="params">(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">ssize_t</span> bytes_written =</span><br><span class="line">-      <span class="built_in">write</span>(pager-&gt;file_descriptor, pager-&gt;pages[page_num], size);</span><br><span class="line">+      <span class="built_in">write</span>(pager-&gt;file_descriptor, pager-&gt;pages[page_num], PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Error writing: %d\n&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">db_close</span><span class="params">(Table* table)</span> </span>&#123;</span><br><span class="line">   Pager* pager = table-&gt;pager;</span><br><span class="line">-  <span class="type">uint32_t</span> num_full_pages = table-&gt;num_rows / ROWS_PER_PAGE;</span><br><span class="line"></span><br><span class="line">-  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_full_pages; i++) &#123;</span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; pager-&gt;num_pages; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (pager-&gt;pages[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">-    <span class="built_in">pager_flush</span>(pager, i, PAGE_SIZE);</span><br><span class="line">+    <span class="built_in">pager_flush</span>(pager, i);</span><br><span class="line">     <span class="built_in">free</span>(pager-&gt;pages[i]);</span><br><span class="line">     pager-&gt;pages[i] = <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">-  <span class="comment">// There may be a partial page to write to the end of the file</span></span><br><span class="line">-  <span class="comment">// This should not be needed after we switch to a B-tree</span></span><br><span class="line">-  <span class="type">uint32_t</span> num_additional_rows = table-&gt;num_rows % ROWS_PER_PAGE;</span><br><span class="line">-  <span class="keyword">if</span> (num_additional_rows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">-    <span class="type">uint32_t</span> page_num = num_full_pages;</span><br><span class="line">-    <span class="keyword">if</span> (pager-&gt;pages[page_num] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">-      <span class="built_in">pager_flush</span>(pager, page_num, num_additional_rows * ROW_SIZE);</span><br><span class="line">-      <span class="built_in">free</span>(pager-&gt;pages[page_num]);</span><br><span class="line">-      pager-&gt;pages[page_num] = <span class="literal">NULL</span>;</span><br><span class="line">-    &#125;</span><br><span class="line">-  &#125;</span><br><span class="line">-</span><br><span class="line">   <span class="type">int</span> result = <span class="built_in">close</span>(pager-&gt;file_descriptor);</span><br><span class="line">   <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Error closing db file.\n&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在更明智的做法是在数据库中存储 page 的个数而不是 row 的个数.page 的个数和 pager 对象关联，而不是 table,因为这是被数据库使用的 page 的个数，而不是指定的 table.一个 btree 被它的根节点对应的 page 下标标识，所以 table 对象需要保存该下标.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="type">const</span> <span class="type">uint32_t</span> PAGE_SIZE = <span class="number">4096</span>;</span><br><span class="line"> <span class="type">const</span> <span class="type">uint32_t</span> TABLE_MAX_PAGES = <span class="number">100</span>;</span><br><span class="line">-<span class="type">const</span> <span class="type">uint32_t</span> ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;</span><br><span class="line">-<span class="type">const</span> <span class="type">uint32_t</span> TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="type">int</span> file_descriptor;</span><br><span class="line">   <span class="type">uint32_t</span> file_length;</span><br><span class="line">+  <span class="type">uint32_t</span> num_pages;</span><br><span class="line">   <span class="type">void</span>* pages[TABLE_MAX_PAGES];</span><br><span class="line"> &#125; Pager;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   Pager* pager;</span><br><span class="line">-  <span class="type">uint32_t</span> num_rows;</span><br><span class="line">+  <span class="type">uint32_t</span> root_page_num;</span><br><span class="line"> &#125; Table;</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-127</span>,<span class="number">6</span> +<span class="number">200</span>,<span class="number">10</span> @@ <span class="function"><span class="type">void</span>* <span class="title">get_page</span><span class="params">(Pager* pager, <span class="type">uint32_t</span> page_num)</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     pager-&gt;pages[page_num] = page;</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">if</span> (page_num &gt;= pager-&gt;num_pages) &#123;</span><br><span class="line">+      pager-&gt;num_pages = page_num + <span class="number">1</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> pager-&gt;pages[page_num];</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-184</span>,<span class="number">6</span> +<span class="number">269</span>,<span class="number">12</span> @@ <span class="function">Pager* <span class="title">pager_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">   Pager* pager = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Pager));</span><br><span class="line">   pager-&gt;file_descriptor = fd;</span><br><span class="line">   pager-&gt;file_length = file_length;</span><br><span class="line">+  pager-&gt;num_pages = (file_length / PAGE_SIZE);</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (file_length % PAGE_SIZE != <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Db file is not a whole number of pages. Corrupt file.\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; TABLE_MAX_PAGES; i++) &#123;</span><br><span class="line">     pager-&gt;pages[i] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="changes-to-the-cursor-object">Changes to the Cursor Object</h3>
<p>cursor 对象表示在 table 中的位置,当我们的 table 只是一个简单的元素为 row 的数组,我们只需要给定 row number 就可以访问该行.现在它是一棵树,我们通过 page number 和 cell 在节点中的 cell number 来标识一个位置.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   Table* table;</span><br><span class="line">-  <span class="type">uint32_t</span> row_num;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num;</span><br><span class="line">+  <span class="type">uint32_t</span> cell_num;</span><br><span class="line">   <span class="type">bool</span> end_of_table;  <span class="comment">// Indicates a position one past the last element</span></span><br><span class="line"> &#125; Cursor;</span><br><span class="line"></span><br><span class="line"> <span class="function">Cursor* <span class="title">table_start</span><span class="params">(Table* table)</span> </span>&#123;</span><br><span class="line">   Cursor* cursor = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Cursor));</span><br><span class="line">   cursor-&gt;table = table;</span><br><span class="line">-  cursor-&gt;row_num = <span class="number">0</span>;</span><br><span class="line">-  cursor-&gt;end_of_table = (table-&gt;num_rows == <span class="number">0</span>);</span><br><span class="line">+  cursor-&gt;page_num = table-&gt;root_page_num;</span><br><span class="line">+  cursor-&gt;cell_num = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(root_node);</span><br><span class="line">+  cursor-&gt;end_of_table = (num_cells == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cursor;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">Cursor* <span class="title">table_end</span><span class="params">(Table* table)</span> </span>&#123;</span><br><span class="line">   Cursor* cursor = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Cursor));</span><br><span class="line">   cursor-&gt;table = table;</span><br><span class="line">-  cursor-&gt;row_num = table-&gt;num_rows;</span><br><span class="line">+  cursor-&gt;page_num = table-&gt;root_page_num;</span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(root_node);</span><br><span class="line">+  cursor-&gt;cell_num = num_cells;</span><br><span class="line">   cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cursor;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span>* <span class="title">cursor_value</span><span class="params">(Cursor* cursor)</span> </span>&#123;</span><br><span class="line">-  <span class="type">uint32_t</span> row_num = cursor-&gt;row_num;</span><br><span class="line">-  <span class="type">uint32_t</span> page_num = row_num / ROWS_PER_PAGE;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num = cursor-&gt;page_num;</span><br><span class="line">   <span class="type">void</span>* page = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, page_num);</span><br><span class="line">-  <span class="type">uint32_t</span> row_offset = row_num % ROWS_PER_PAGE;</span><br><span class="line">-  <span class="type">uint32_t</span> byte_offset = row_offset * ROW_SIZE;</span><br><span class="line">-  <span class="keyword">return</span> page + byte_offset;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_value</span>(page, cursor-&gt;cell_num);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">cursor_advance</span><span class="params">(Cursor* cursor)</span> </span>&#123;</span><br><span class="line">-  cursor-&gt;row_num += <span class="number">1</span>;</span><br><span class="line">-  <span class="keyword">if</span> (cursor-&gt;row_num &gt;= cursor-&gt;table-&gt;num_rows) &#123;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num = cursor-&gt;page_num;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, page_num);</span><br><span class="line">+</span><br><span class="line">+  cursor-&gt;cell_num += <span class="number">1</span>;</span><br><span class="line">+  <span class="keyword">if</span> (cursor-&gt;cell_num &gt;= (*<span class="built_in">leaf_node_num_cells</span>(node))) &#123;</span><br><span class="line">     cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="insertion-into-a-leaf-node">Insertion Into a Leaf Node</h3>
<p>在本章我们会实现一个只有一个节点的树.回忆一下上一章的一开始只有一个空的叶子节点的树:</p>
<p>empty btree</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree1.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree1.png" alt="empty btree"></a></p>
<p>键值对可以一直放入，直到叶子节点被填满:</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree2.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree2.png" alt="one-node btree"></a></p>
<p>当我们第一次打开数据库，数据库文件是空的，所以我们初始化 page 0 为一个空的叶子节点(也是根节点):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function">Table* <span class="title">db_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">   Pager* pager = <span class="built_in">pager_open</span>(filename);</span><br><span class="line">-  <span class="type">uint32_t</span> num_rows = pager-&gt;file_length / ROW_SIZE;</span><br><span class="line"></span><br><span class="line">   Table* table = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Table));</span><br><span class="line">   table-&gt;pager = pager;</span><br><span class="line">-  table-&gt;num_rows = num_rows;</span><br><span class="line">+  table-&gt;root_page_num = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (pager-&gt;num_pages == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="comment">// New database file. Initialize page 0 as leaf node.</span></span><br><span class="line">+    <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(pager, <span class="number">0</span>);</span><br><span class="line">+    <span class="built_in">initialize_leaf_node</span>(root_node);</span><br><span class="line">+  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> table;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们会创建一个用来向叶子节点中插入键值对的函数,函数的参数 cursor 包含键值对应该被插入的位置.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">void</span> <span class="title">leaf_node_insert</span><span class="params">(Cursor* cursor, <span class="type">uint32_t</span> key, Row* value)</span> </span>&#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);</span><br><span class="line">+</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">+  <span class="keyword">if</span> (num_cells &gt;= LEAF_NODE_MAX_CELLS) &#123;</span><br><span class="line">+    <span class="comment">// Node full</span></span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Need to implement splitting a leaf node.\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (cursor-&gt;cell_num &lt; num_cells) &#123;</span><br><span class="line">+    <span class="comment">// Make room for new cell</span></span><br><span class="line">+    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = num_cells; i &gt; cursor-&gt;cell_num; i--) &#123;</span><br><span class="line">+      <span class="built_in">memcpy</span>(<span class="built_in">leaf_node_cell</span>(node, i), <span class="built_in">leaf_node_cell</span>(node, i - <span class="number">1</span>),</span><br><span class="line">+             LEAF_NODE_CELL_SIZE);</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  *(<span class="built_in">leaf_node_num_cells</span>(node)) += <span class="number">1</span>;</span><br><span class="line">+  *(<span class="built_in">leaf_node_key</span>(node, cursor-&gt;cell_num)) = key;</span><br><span class="line">+  <span class="built_in">serialize_row</span>(value, <span class="built_in">leaf_node_value</span>(node, cursor-&gt;cell_num));</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br></pre></td></tr></table></figure>
<p>我们现在还没有实现分裂操作,所以如果 node 容量满了会退出程序.然后将插入位置后面的 cell 右移一位以给新的 cell 腾出空间，然后我们向空的空间写入 key&amp;value.</p>
<p>既然我们假设树只有一个节点，<code>execute_insert()</code>函数只需要调用这个辅助函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function">ExecuteResult <span class="title">execute_insert</span><span class="params">(Statement* statement, Table* table)</span> </span>&#123;</span><br><span class="line">-  <span class="keyword">if</span> (table-&gt;num_rows &gt;= TABLE_MAX_ROWS) &#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="keyword">if</span> ((*<span class="built_in">leaf_node_num_cells</span>(node) &gt;= LEAF_NODE_MAX_CELLS)) &#123;</span><br><span class="line">     <span class="keyword">return</span> EXECUTE_TABLE_FULL;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);</span><br><span class="line">   Cursor* cursor = <span class="built_in">table_end</span>(table);</span><br><span class="line"></span><br><span class="line">-  <span class="built_in">serialize_row</span>(row_to_insert, <span class="built_in">cursor_value</span>(cursor));</span><br><span class="line">-  table-&gt;num_rows += <span class="number">1</span>;</span><br><span class="line">+  <span class="built_in">leaf_node_insert</span>(cursor, row_to_insert-&gt;id, row_to_insert);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(cursor);</span><br></pre></td></tr></table></figure>
<p>通过这些改动，我们的数据库就能和之前一样工作了!除了现在它会更早地返回"Table 已满"错误，因为我们还不能分裂根节点.</p>
<p>叶子节点可以保存多少行呢?</p>
<h3 id="command-to-print-constants">Command to Print Constants</h3>
<p>我增加了一个新的元命令，用来打印一些有趣的常量.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">void</span> <span class="title">print_constants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;ROW_SIZE: %d\n&quot;</span>, ROW_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;COMMON_NODE_HEADER_SIZE: %d\n&quot;</span>, COMMON_NODE_HEADER_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_HEADER_SIZE: %d\n&quot;</span>, LEAF_NODE_HEADER_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_CELL_SIZE: %d\n&quot;</span>, LEAF_NODE_CELL_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_SPACE_FOR_CELLS: %d\n&quot;</span>, LEAF_NODE_SPACE_FOR_CELLS);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_MAX_CELLS: %d\n&quot;</span>, LEAF_NODE_MAX_CELLS);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">@@ <span class="number">-294</span>,<span class="number">6</span> +<span class="number">376</span>,<span class="number">14</span> @@ <span class="function">MetaCommandResult <span class="title">do_meta_command</span><span class="params">(InputBuffer* input_buffer, Table* table)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">db_close</span>(table);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">+  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.constants&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Constants:\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">print_constants</span>();</span><br><span class="line">+    <span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> META_COMMAND_UNRECOGNIZED_COMMAND;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我还添加了一个测试，可以用来提醒我们这些变量改变了:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  it <span class="string">&#x27;prints constants&#x27;</span> <span class="keyword">do</span></span><br><span class="line">+    script = [</span><br><span class="line">+      <span class="string">&quot;.constants&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;.exit&quot;</span>,</span><br><span class="line">+    ]</span><br><span class="line">+    result = <span class="built_in">run_script</span>(script)</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">expect</span>(result).to <span class="built_in">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; Constants:&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;ROW_SIZE: 293&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;COMMON_NODE_HEADER_SIZE: 6&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_HEADER_SIZE: 10&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_CELL_SIZE: 297&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_SPACE_FOR_CELLS: 4086&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_MAX_CELLS: 13&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; &quot;</span>,</span><br><span class="line">+    ])</span><br><span class="line">+  end</span><br></pre></td></tr></table></figure>
<p>现在我们的 table 可以保存 13 行喔!</p>
<h3 id="tree-visualization">Tree Visualization</h3>
<p>为了便于调试和可视化,我还增加了一个元命令来打印出 btree 表现形式.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">void</span> <span class="title">print_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;leaf (size %d)\n&quot;</span>, num_cells);</span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_cells; i++) &#123;</span><br><span class="line">+    <span class="type">uint32_t</span> key = *<span class="built_in">leaf_node_key</span>(node, i);</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;  - %d : %d\n&quot;</span>, i, key);</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-294</span>,<span class="number">6</span> +<span class="number">376</span>,<span class="number">14</span> @@ <span class="function">MetaCommandResult <span class="title">do_meta_command</span><span class="params">(InputBuffer* input_buffer, Table* table)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">db_close</span>(table);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">+  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.btree&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Tree:\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">print_leaf_node</span>(<span class="built_in">get_page</span>(table-&gt;pager, <span class="number">0</span>));</span><br><span class="line">+    <span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.constants&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Constants:\n&quot;</span>);</span><br><span class="line">     <span class="built_in">print_constants</span>();</span><br><span class="line">     <span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> META_COMMAND_UNRECOGNIZED_COMMAND;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以及一个测试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  it <span class="string">&#x27;allows printing out the structure of a one-node btree&#x27;</span> <span class="keyword">do</span></span><br><span class="line">+    script = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>].map <span class="keyword">do</span> |i|</span><br><span class="line">+      <span class="string">&quot;insert #&#123;i&#125; user#&#123;i&#125; person#&#123;i&#125;@example.com&quot;</span></span><br><span class="line">+    end</span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;.btree&quot;</span></span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;.exit&quot;</span></span><br><span class="line">+    result = <span class="built_in">run_script</span>(script)</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">expect</span>(result).to <span class="built_in">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Tree:&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;leaf (size 3)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 0 : 3&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 1 : 1&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 2 : 2&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; &quot;</span></span><br><span class="line">+    ])</span><br><span class="line">+  end</span><br></pre></td></tr></table></figure>
<p>果咩，我们仍然没能有序地存储行.你可能注意到了<code>execute_insert()</code>函数在叶子节点的插入位置是由函数<code>table_end()</code>返回的.所以行是以插入的顺序排序的,就像之前一样.</p>
<p></br></p>
<h3 id="next-time">Next Time</h3>
<p>本章看起来像是倒退了一步.我们的数据库现在存储的行比之前少，并且我们存储的行仍然是无序的.但就像我在一开始说的，这是我们的一大步，并且将其分解成可管理的步骤很重要.</p>
<p>下一章，我们会实现根据 primary key(主键值)查找记录，然后有序地存储行.</p>
<p></br></p>
<h3 id="complete-diff">Complete Diff</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@@ <span class="number">-62</span>,<span class="number">29</span> +<span class="number">62</span>,<span class="number">101</span> @@ <span class="type">const</span> <span class="type">uint32_t</span> ROW_SIZE = ID_SIZE + USERNAME_SIZE + EMAIL_SIZE;</span><br><span class="line"></span><br><span class="line"> <span class="type">const</span> <span class="type">uint32_t</span> PAGE_SIZE = <span class="number">4096</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> TABLE_MAX_PAGES 100</span></span><br><span class="line">-<span class="type">const</span> <span class="type">uint32_t</span> ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;</span><br><span class="line">-<span class="type">const</span> <span class="type">uint32_t</span> TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="type">int</span> file_descriptor;</span><br><span class="line">   <span class="type">uint32_t</span> file_length;</span><br><span class="line">+  <span class="type">uint32_t</span> num_pages;</span><br><span class="line">   <span class="type">void</span>* pages[TABLE_MAX_PAGES];</span><br><span class="line"> &#125; Pager;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   Pager* pager;</span><br><span class="line">-  <span class="type">uint32_t</span> num_rows;</span><br><span class="line">+  <span class="type">uint32_t</span> root_page_num;</span><br><span class="line"> &#125; Table;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   Table* table;</span><br><span class="line">-  <span class="type">uint32_t</span> row_num;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num;</span><br><span class="line">+  <span class="type">uint32_t</span> cell_num;</span><br><span class="line">   <span class="type">bool</span> end_of_table;  <span class="comment">// Indicates a position one past the last element</span></span><br><span class="line"> &#125; Cursor;</span><br><span class="line"></span><br><span class="line">+<span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; NODE_INTERNAL, NODE_LEAF &#125; NodeType;</span><br><span class="line">+</span><br><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Common Node Header Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> NODE_TYPE_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> NODE_TYPE_OFFSET = <span class="number">0</span>;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> IS_ROOT_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> IS_ROOT_OFFSET = NODE_TYPE_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> PARENT_POINTER_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint8_t</span> COMMON_NODE_HEADER_SIZE =</span><br><span class="line">+    NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;</span><br><span class="line">+</span><br><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Leaf Node Header Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_NUM_CELLS_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_HEADER_SIZE =</span><br><span class="line">+    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;</span><br><span class="line">+</span><br><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Leaf Node Body Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_KEY_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_KEY_OFFSET = <span class="number">0</span>;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_VALUE_SIZE = ROW_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_VALUE_OFFSET =</span><br><span class="line">+    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_MAX_CELLS =</span><br><span class="line">+    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">leaf_node_num_cells</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + LEAF_NODE_NUM_CELLS_OFFSET;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span>* <span class="title">leaf_node_cell</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + LEAF_NODE_HEADER_SIZE + cell_num * LEAF_NODE_CELL_SIZE;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">leaf_node_key</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_cell</span>(node, cell_num);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span>* <span class="title">leaf_node_value</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_cell</span>(node, cell_num) + LEAF_NODE_KEY_SIZE;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">print_constants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;ROW_SIZE: %d\n&quot;</span>, ROW_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;COMMON_NODE_HEADER_SIZE: %d\n&quot;</span>, COMMON_NODE_HEADER_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_HEADER_SIZE: %d\n&quot;</span>, LEAF_NODE_HEADER_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_CELL_SIZE: %d\n&quot;</span>, LEAF_NODE_CELL_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_SPACE_FOR_CELLS: %d\n&quot;</span>, LEAF_NODE_SPACE_FOR_CELLS);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_MAX_CELLS: %d\n&quot;</span>, LEAF_NODE_MAX_CELLS);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">print_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;leaf (size %d)\n&quot;</span>, num_cells);</span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_cells; i++) &#123;</span><br><span class="line">+    <span class="type">uint32_t</span> key = *<span class="built_in">leaf_node_key</span>(node, i);</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;  - %d : %d\n&quot;</span>, i, key);</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">print_row</span><span class="params">(Row* row)</span> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;(%d, %s, %s)\n&quot;</span>, row-&gt;id, row-&gt;username, row-&gt;email);</span><br><span class="line"> &#125;</span><br><span class="line">@@ <span class="number">-101</span>,<span class="number">6</span> +<span class="number">173</span>,<span class="number">8</span> @@ <span class="function"><span class="type">void</span> <span class="title">deserialize_row</span><span class="params">(<span class="type">void</span> *source, Row* destination)</span> </span>&#123;</span><br><span class="line">     <span class="built_in">memcpy</span>(&amp;(destination-&gt;email), source + EMAIL_OFFSET, EMAIL_SIZE);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">initialize_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123; *<span class="built_in">leaf_node_num_cells</span>(node) = <span class="number">0</span>; &#125;</span><br><span class="line">+</span><br><span class="line"> <span class="function"><span class="type">void</span>* <span class="title">get_page</span><span class="params">(Pager* pager, <span class="type">uint32_t</span> page_num)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (page_num &gt; TABLE_MAX_PAGES) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Tried to fetch page number out of bounds. %d &gt; %d\n&quot;</span>, page_num,</span><br><span class="line">@@ <span class="number">-128</span>,<span class="number">6</span> +<span class="number">202</span>,<span class="number">10</span> @@ <span class="type">void</span>* <span class="built_in">get_page</span>(Pager* pager, <span class="type">uint32_t</span> page_num) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     pager-&gt;pages[page_num] = page;</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">if</span> (page_num &gt;= pager-&gt;num_pages) &#123;</span><br><span class="line">+      pager-&gt;num_pages = page_num + <span class="number">1</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> pager-&gt;pages[page_num];</span><br><span class="line">@@ <span class="number">-136</span>,<span class="number">8</span> +<span class="number">214</span>,<span class="number">12</span> @@ <span class="type">void</span>* <span class="built_in">get_page</span>(Pager* pager, <span class="type">uint32_t</span> page_num) &#123;</span><br><span class="line"> Cursor* <span class="built_in">table_start</span>(Table* table) &#123;</span><br><span class="line">   Cursor* cursor = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Cursor));</span><br><span class="line">   cursor-&gt;table = table;</span><br><span class="line">-  cursor-&gt;row_num = <span class="number">0</span>;</span><br><span class="line">-  cursor-&gt;end_of_table = (table-&gt;num_rows == <span class="number">0</span>);</span><br><span class="line">+  cursor-&gt;page_num = table-&gt;root_page_num;</span><br><span class="line">+  cursor-&gt;cell_num = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(root_node);</span><br><span class="line">+  cursor-&gt;end_of_table = (num_cells == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cursor;</span><br><span class="line"> &#125;</span><br><span class="line">@@ <span class="number">-145</span>,<span class="number">24</span> +<span class="number">227</span>,<span class="number">28</span> @@ Cursor* <span class="built_in">table_start</span>(Table* table) &#123;</span><br><span class="line"> Cursor* <span class="built_in">table_end</span>(Table* table) &#123;</span><br><span class="line">   Cursor* cursor = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Cursor));</span><br><span class="line">   cursor-&gt;table = table;</span><br><span class="line">-  cursor-&gt;row_num = table-&gt;num_rows;</span><br><span class="line">+  cursor-&gt;page_num = table-&gt;root_page_num;</span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(root_node);</span><br><span class="line">+  cursor-&gt;cell_num = num_cells;</span><br><span class="line">   cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cursor;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span>* <span class="built_in">cursor_value</span>(Cursor* cursor) &#123;</span><br><span class="line">-  <span class="type">uint32_t</span> row_num = cursor-&gt;row_num;</span><br><span class="line">-  <span class="type">uint32_t</span> page_num = row_num / ROWS_PER_PAGE;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num = cursor-&gt;page_num;</span><br><span class="line">   <span class="type">void</span>* page = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, page_num);</span><br><span class="line">-  <span class="type">uint32_t</span> row_offset = row_num % ROWS_PER_PAGE;</span><br><span class="line">-  <span class="type">uint32_t</span> byte_offset = row_offset * ROW_SIZE;</span><br><span class="line">-  <span class="keyword">return</span> page + byte_offset;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_value</span>(page, cursor-&gt;cell_num);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> <span class="built_in">cursor_advance</span>(Cursor* cursor) &#123;</span><br><span class="line">-  cursor-&gt;row_num += <span class="number">1</span>;</span><br><span class="line">-  <span class="keyword">if</span> (cursor-&gt;row_num &gt;= cursor-&gt;table-&gt;num_rows) &#123;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num = cursor-&gt;page_num;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, page_num);</span><br><span class="line">+</span><br><span class="line">+  cursor-&gt;cell_num += <span class="number">1</span>;</span><br><span class="line">+  <span class="keyword">if</span> (cursor-&gt;cell_num &gt;= (*<span class="built_in">leaf_node_num_cells</span>(node))) &#123;</span><br><span class="line">     cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">@@ <span class="number">-185</span>,<span class="number">6</span> +<span class="number">271</span>,<span class="number">12</span> @@ Pager* <span class="built_in">pager_open</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line">   Pager* pager = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Pager));</span><br><span class="line">   pager-&gt;file_descriptor = fd;</span><br><span class="line">   pager-&gt;file_length = file_length;</span><br><span class="line">+  pager-&gt;num_pages = (file_length / PAGE_SIZE);</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (file_length % PAGE_SIZE != <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Db file is not a whole number of pages. Corrupt file.\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; TABLE_MAX_PAGES; i++) &#123;</span><br><span class="line">     pager-&gt;pages[i] = <span class="literal">NULL</span>;</span><br><span class="line">@@ <span class="number">-194</span>,<span class="number">11</span> +<span class="number">285</span>,<span class="number">15</span> @@ Pager* <span class="built_in">pager_open</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line">@@ <span class="number">-195</span>,<span class="number">11</span> +<span class="number">287</span>,<span class="number">16</span> @@ Pager* <span class="built_in">pager_open</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line"></span><br><span class="line"> Table* <span class="built_in">db_open</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line">   Pager* pager = <span class="built_in">pager_open</span>(filename);</span><br><span class="line">-  <span class="type">uint32_t</span> num_rows = pager-&gt;file_length / ROW_SIZE;</span><br><span class="line"></span><br><span class="line">   Table* table = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Table));</span><br><span class="line">   table-&gt;pager = pager;</span><br><span class="line">-  table-&gt;num_rows = num_rows;</span><br><span class="line">+  table-&gt;root_page_num = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (pager-&gt;num_pages == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="comment">// New database file. Initialize page 0 as leaf node.</span></span><br><span class="line">+    <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(pager, <span class="number">0</span>);</span><br><span class="line">+    <span class="built_in">initialize_leaf_node</span>(root_node);</span><br><span class="line">+  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> table;</span><br><span class="line"> &#125;</span><br><span class="line">@@ <span class="number">-234</span>,<span class="number">7</span> +<span class="number">331</span>,<span class="number">7</span> @@ <span class="type">void</span> <span class="built_in">close_input_buffer</span>(InputBuffer* input_buffer) &#123;</span><br><span class="line">     <span class="built_in">free</span>(input_buffer);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">-<span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size) &#123;</span><br><span class="line">+<span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num) &#123;</span><br><span class="line">   <span class="keyword">if</span> (pager-&gt;pages[page_num] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Tried to flush null page\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">@@ <span class="number">-242</span>,<span class="number">7</span> +<span class="number">337</span>,<span class="number">7</span> @@ <span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size) &#123;</span><br><span class="line">@@ <span class="number">-249</span>,<span class="number">7</span> +<span class="number">346</span>,<span class="number">7</span> @@ <span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size) &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">ssize_t</span> bytes_written =</span><br><span class="line">-      <span class="built_in">write</span>(pager-&gt;file_descriptor, pager-&gt;pages[page_num], size);</span><br><span class="line">+      <span class="built_in">write</span>(pager-&gt;file_descriptor, pager-&gt;pages[page_num], PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Error writing: %d\n&quot;</span>, errno);</span><br><span class="line">@@ <span class="number">-252</span>,<span class="number">29</span> +<span class="number">347</span>,<span class="number">16</span> @@ <span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size) &#123;</span><br><span class="line">@@ <span class="number">-260</span>,<span class="number">29</span> +<span class="number">357</span>,<span class="number">16</span> @@ <span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> <span class="built_in">db_close</span>(Table* table) &#123;</span><br><span class="line">   Pager* pager = table-&gt;pager;</span><br><span class="line">-  <span class="type">uint32_t</span> num_full_pages = table-&gt;num_rows / ROWS_PER_PAGE;</span><br><span class="line"></span><br><span class="line">-  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_full_pages; i++) &#123;</span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; pager-&gt;num_pages; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (pager-&gt;pages[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">-    <span class="built_in">pager_flush</span>(pager, i, PAGE_SIZE);</span><br><span class="line">+    <span class="built_in">pager_flush</span>(pager, i);</span><br><span class="line">     <span class="built_in">free</span>(pager-&gt;pages[i]);</span><br><span class="line">     pager-&gt;pages[i] = <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">-  <span class="comment">// There may be a partial page to write to the end of the file</span></span><br><span class="line">-  <span class="comment">// This should not be needed after we switch to a B-tree</span></span><br><span class="line">-  <span class="type">uint32_t</span> num_additional_rows = table-&gt;num_rows % ROWS_PER_PAGE;</span><br><span class="line">-  <span class="keyword">if</span> (num_additional_rows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">-    <span class="type">uint32_t</span> page_num = num_full_pages;</span><br><span class="line">-    <span class="keyword">if</span> (pager-&gt;pages[page_num] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">-      <span class="built_in">pager_flush</span>(pager, page_num, num_additional_rows * ROW_SIZE);</span><br><span class="line">-      <span class="built_in">free</span>(pager-&gt;pages[page_num]);</span><br><span class="line">-      pager-&gt;pages[page_num] = <span class="literal">NULL</span>;</span><br><span class="line">-    &#125;</span><br><span class="line">-  &#125;</span><br><span class="line">-</span><br><span class="line">   <span class="type">int</span> result = <span class="built_in">close</span>(pager-&gt;file_descriptor);</span><br><span class="line">   <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Error closing db file.\n&quot;</span>);</span><br><span class="line">@@ <span class="number">-305</span>,<span class="number">6</span> +<span class="number">389</span>,<span class="number">14</span> @@ MetaCommandResult <span class="built_in">do_meta_command</span>(InputBuffer* input_buffer, Table *table) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">db_close</span>(table);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">+  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.btree&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Tree:\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">print_leaf_node</span>(<span class="built_in">get_page</span>(table-&gt;pager, <span class="number">0</span>));</span><br><span class="line">+    <span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br><span class="line">+  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.constants&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Constants:\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">print_constants</span>();</span><br><span class="line">+    <span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> META_COMMAND_UNRECOGNIZED_COMMAND;</span><br><span class="line">   &#125;</span><br><span class="line">@@ <span class="number">-354</span>,<span class="number">16</span> +<span class="number">446</span>,<span class="number">39</span> @@ PrepareResult <span class="built_in">prepare_statement</span>(InputBuffer* input_buffer,</span><br><span class="line">   <span class="keyword">return</span> PREPARE_UNRECOGNIZED_STATEMENT;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">+<span class="type">void</span> <span class="built_in">leaf_node_insert</span>(Cursor* cursor, <span class="type">uint32_t</span> key, Row* value) &#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);</span><br><span class="line">+</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">+  <span class="keyword">if</span> (num_cells &gt;= LEAF_NODE_MAX_CELLS) &#123;</span><br><span class="line">+    <span class="comment">// Node full</span></span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Need to implement splitting a leaf node.\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (cursor-&gt;cell_num &lt; num_cells) &#123;</span><br><span class="line">+    <span class="comment">// Make room for new cell</span></span><br><span class="line">+    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = num_cells; i &gt; cursor-&gt;cell_num; i--) &#123;</span><br><span class="line">+      <span class="built_in">memcpy</span>(<span class="built_in">leaf_node_cell</span>(node, i), <span class="built_in">leaf_node_cell</span>(node, i - <span class="number">1</span>),</span><br><span class="line">+             LEAF_NODE_CELL_SIZE);</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  *(<span class="built_in">leaf_node_num_cells</span>(node)) += <span class="number">1</span>;</span><br><span class="line">+  *(<span class="built_in">leaf_node_key</span>(node, cursor-&gt;cell_num)) = key;</span><br><span class="line">+  <span class="built_in">serialize_row</span>(value, <span class="built_in">leaf_node_value</span>(node, cursor-&gt;cell_num));</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> ExecuteResult <span class="built_in">execute_insert</span>(Statement* statement, Table* table) &#123;</span><br><span class="line">-  <span class="keyword">if</span> (table-&gt;num_rows &gt;= TABLE_MAX_ROWS) &#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="keyword">if</span> ((*<span class="built_in">leaf_node_num_cells</span>(node) &gt;= LEAF_NODE_MAX_CELLS)) &#123;</span><br><span class="line">     <span class="keyword">return</span> EXECUTE_TABLE_FULL;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);</span><br><span class="line">   Cursor* cursor = <span class="built_in">table_end</span>(table);</span><br><span class="line"></span><br><span class="line">-  <span class="built_in">serialize_row</span>(row_to_insert, <span class="built_in">cursor_value</span>(cursor));</span><br><span class="line">-  table-&gt;num_rows += <span class="number">1</span>;</span><br><span class="line">+  <span class="built_in">leaf_node_insert</span>(cursor, row_to_insert-&gt;id, row_to_insert);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(cursor);</span><br><span class="line"></span><br><span class="line">And the specs:</span><br><span class="line"></span><br><span class="line">+  it <span class="string">&#x27;allows printing out the structure of a one-node btree&#x27;</span> <span class="keyword">do</span></span><br><span class="line">+    script = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>].map <span class="keyword">do</span> |i|</span><br><span class="line">+      <span class="string">&quot;insert #&#123;i&#125; user#&#123;i&#125; person#&#123;i&#125;@example.com&quot;</span></span><br><span class="line">+    end</span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;.btree&quot;</span></span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;.exit&quot;</span></span><br><span class="line">+    result = <span class="built_in">run_script</span>(script)</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">expect</span>(result).to <span class="built_in">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Tree:&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;leaf (size 3)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 0 : 3&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 1 : 1&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 2 : 2&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; &quot;</span></span><br><span class="line">+    ])</span><br><span class="line">+  end</span><br><span class="line">+</span><br><span class="line">+  it <span class="string">&#x27;prints constants&#x27;</span> <span class="keyword">do</span></span><br><span class="line">+    script = [</span><br><span class="line">+      <span class="string">&quot;.constants&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;.exit&quot;</span>,</span><br><span class="line">+    ]</span><br><span class="line">+    result = <span class="built_in">run_script</span>(script)</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">expect</span>(result).to <span class="built_in">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; Constants:&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;ROW_SIZE: 293&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;COMMON_NODE_HEADER_SIZE: 6&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_HEADER_SIZE: 10&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_CELL_SIZE: 297&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_SPACE_FOR_CELLS: 4086&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_MAX_CELLS: 13&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; &quot;</span>,</span><br><span class="line">+    ])</span><br><span class="line">+  end</span><br><span class="line"> end</span><br></pre></td></tr></table></figure>
<h2 id="part-9---binary-search-and-duplicate-keys">Part 9 - Binary Search and Duplicate Keys</h2>
<p>在上一章注意到我们仍然存储键的方式仍然是无序的.我们将要修复这个问题，外加检测和拒绝重复的键.</p>
<p>目前，函数<code>execute_insert()</code>总是选择在表的末尾插入，但我们应该在表中搜索合适的插入位置，然后插到那里.如果键值已存在，返回一个错误.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ExecuteResult <span class="title">execute_insert</span><span class="params">(Statement* statement, Table* table)</span> </span>&#123;</span><br><span class="line">   <span class="type">void</span>* node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">-  <span class="keyword">if</span> ((*<span class="built_in">leaf_node_num_cells</span>(node) &gt;= LEAF_NODE_MAX_CELLS)) &#123;</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = (*<span class="built_in">leaf_node_num_cells</span>(node));</span><br><span class="line">+  <span class="keyword">if</span> (num_cells &gt;= LEAF_NODE_MAX_CELLS) &#123;</span><br><span class="line">     <span class="keyword">return</span> EXECUTE_TABLE_FULL;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);</span><br><span class="line">-  Cursor* cursor = <span class="built_in">table_end</span>(table);</span><br><span class="line">+  <span class="type">uint32_t</span> key_to_insert = row_to_insert-&gt;id;</span><br><span class="line">+  Cursor* cursor = <span class="built_in">table_find</span>(table, key_to_insert);</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (cursor-&gt;cell_num &lt; num_cells) &#123;</span><br><span class="line">+    <span class="type">uint32_t</span> key_at_index = *<span class="built_in">leaf_node_key</span>(node, cursor-&gt;cell_num);</span><br><span class="line">+    <span class="keyword">if</span> (key_at_index == key_to_insert) &#123;</span><br><span class="line">+      <span class="keyword">return</span> EXECUTE_DUPLICATE_KEY;</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">leaf_node_insert</span>(cursor, row_to_insert-&gt;id, row_to_insert);</span><br></pre></td></tr></table></figure>
<p>我们不再需要函数<code>table_end()</code>了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-<span class="function">Cursor* <span class="title">table_end</span><span class="params">(Table* table)</span> </span>&#123;</span><br><span class="line">-  Cursor* cursor = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Cursor));</span><br><span class="line">-  cursor-&gt;table = table;</span><br><span class="line">-  cursor-&gt;page_num = table-&gt;root_page_num;</span><br><span class="line">-</span><br><span class="line">-  <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">-  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(root_node);</span><br><span class="line">-  cursor-&gt;cell_num = num_cells;</span><br><span class="line">-  cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line">-</span><br><span class="line">-  <span class="keyword">return</span> cursor;</span><br><span class="line">-&#125;</span><br></pre></td></tr></table></figure>
<p>我们用一个新函数代替它，该函数可以在树中搜索一个给定的key.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+Return the position of the given key.</span></span><br><span class="line"><span class="comment">+If the key is not present, return the position</span></span><br><span class="line"><span class="comment">+where it should be inserted</span></span><br><span class="line"><span class="comment">+*/</span></span><br><span class="line">+<span class="function">Cursor* <span class="title">table_find</span><span class="params">(Table* table, <span class="type">uint32_t</span> key)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint32_t</span> root_page_num = table-&gt;root_page_num;</span><br><span class="line">+  <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(table-&gt;pager, root_page_num);</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (<span class="built_in">get_node_type</span>(root_node) == NODE_LEAF) &#123;</span><br><span class="line">+    <span class="keyword">return</span> <span class="built_in">leaf_node_find</span>(table, root_page_num, key);</span><br><span class="line">+  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Need to implement searching an internal node\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<p>我预留了处理内部节点的分支，尽管我们还没有实现内部节点.不过我们现在可以用二分查找搜索叶子节点.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function">Cursor* <span class="title">leaf_node_find</span><span class="params">(Table* table, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> key)</span> </span>&#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(table-&gt;pager, page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">+</span><br><span class="line">+  Cursor* cursor = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Cursor));</span><br><span class="line">+  cursor-&gt;table = table;</span><br><span class="line">+  cursor-&gt;page_num = page_num;</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">// Binary search</span></span><br><span class="line">+  <span class="type">uint32_t</span> min_index = <span class="number">0</span>;</span><br><span class="line">+  <span class="type">uint32_t</span> one_past_max_index = num_cells;</span><br><span class="line">+  <span class="keyword">while</span> (one_past_max_index != min_index) &#123;</span><br><span class="line">+    <span class="type">uint32_t</span> index = (min_index + one_past_max_index) / <span class="number">2</span>;</span><br><span class="line">+    <span class="type">uint32_t</span> key_at_index = *<span class="built_in">leaf_node_key</span>(node, index);</span><br><span class="line">+    <span class="keyword">if</span> (key == key_at_index) &#123;</span><br><span class="line">+      cursor-&gt;cell_num = index;</span><br><span class="line">+      <span class="keyword">return</span> cursor;</span><br><span class="line">+    &#125;</span><br><span class="line">+    <span class="keyword">if</span> (key &lt; key_at_index) &#123;</span><br><span class="line">+      one_past_max_index = index;</span><br><span class="line">+    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+      min_index = index + <span class="number">1</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  cursor-&gt;cell_num = min_index;</span><br><span class="line">+  <span class="keyword">return</span> cursor;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的返回值为:</p>
<ul>
<li>键对应的位置</li>
<li>另一个键的位置，如果我们想要插入新的键的话，就需要移动它，或者</li>
<li>最后一个键的后一个位置</li>
</ul>
<p>因为我们现在需要检查节点类型，所以需要一个函数去获得和设置类型值.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function">NodeType <span class="title">get_node_type</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint8_t</span> value = *((<span class="type">uint8_t</span>*)(node + NODE_TYPE_OFFSET));</span><br><span class="line">+  <span class="keyword">return</span> (NodeType)value;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">set_node_type</span><span class="params">(<span class="type">void</span>* node, NodeType type)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint8_t</span> value = type;</span><br><span class="line">+  *((<span class="type">uint8_t</span>*)(node + NODE_TYPE_OFFSET)) = value;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要先转换到<code>unt8_t</code>类型以确保其被序列化为一个字节.</p>
<p>我们还需要初始化节点类型.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-<span class="function"><span class="type">void</span> <span class="title">initialize_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123; *<span class="built_in">leaf_node_num_cells</span>(node) = <span class="number">0</span>; &#125;</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">initialize_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="built_in">set_node_type</span>(node, NODE_LEAF);</span><br><span class="line">+  *<span class="built_in">leaf_node_num_cells</span>(node) = <span class="number">0</span>;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们需要创建和处理一个新的错误码.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-<span class="keyword">enum</span> <span class="title class_">ExecuteResult_t</span> &#123; EXECUTE_SUCCESS, EXECUTE_TABLE_FULL &#125;;</span><br><span class="line">+<span class="keyword">enum</span> <span class="title class_">ExecuteResult_t</span> &#123;</span><br><span class="line">+  EXECUTE_SUCCESS,</span><br><span class="line">+  EXECUTE_DUPLICATE_KEY,</span><br><span class="line">+  EXECUTE_TABLE_FULL</span><br><span class="line">+&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">case</span> (EXECUTE_SUCCESS):</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Executed.\n&quot;</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">+      <span class="built_in">case</span> (EXECUTE_DUPLICATE_KEY):</span><br><span class="line">+        <span class="built_in">printf</span>(<span class="string">&quot;Error: Duplicate key.\n&quot;</span>);</span><br><span class="line">+        <span class="keyword">break</span>;</span><br><span class="line">       <span class="built_in">case</span> (EXECUTE_TABLE_FULL):</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Error: Table full.\n&quot;</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>通过这些改动，我们的测试可以改为检查顺序.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">       <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">       <span class="string">&quot;db &gt; Tree:&quot;</span>,</span><br><span class="line">       <span class="string">&quot;leaf (size 3)&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;  - 0 : 3&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;  - 1 : 1&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;  - 2 : 2&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 0 : 1&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 1 : 2&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 2 : 3&quot;</span>,</span><br><span class="line">       <span class="string">&quot;db &gt; &quot;</span></span><br><span class="line">     ])</span><br><span class="line">   end</span><br></pre></td></tr></table></figure>
<p>然后我们可以新增一个检查重复键的测试:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  it <span class="string">&#x27;prints an error message if there is a duplicate id&#x27;</span> <span class="keyword">do</span></span><br><span class="line">+    script = [</span><br><span class="line">+      <span class="string">&quot;insert 1 user1 person1@example.com&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;insert 1 user1 person1@example.com&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;select&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;.exit&quot;</span>,</span><br><span class="line">+    ]</span><br><span class="line">+    result = <span class="built_in">run_script</span>(script)</span><br><span class="line">+    <span class="built_in">expect</span>(result).to <span class="built_in">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Error: Duplicate key.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; (1, user1, person1@example.com)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; &quot;</span>,</span><br><span class="line">+    ])</span><br><span class="line">+  end</span><br></pre></td></tr></table></figure>
<p>好辣!在下一章我们将会 - 实施分裂叶子节点并且创建内部节点.</p>
<p></br></p>
<h2 id="part-10---splitting-a-leaf-node">Part 10 - Splitting a Leaf Node</h2>
<p>我们的B-Tree不太像一个树，因为只有一个节点.为了修复这个问题，我们需要一些代码来将一个叶子节点分裂成双胞胎.在这之后,我们需要创建一个内部节点作为两个叶子节点的父节点.</p>
<p>本章目标基本上是从这样:</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree2.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree2.png" alt="one-node btree"></a></p>
<p>到这样:</p>
<p>two-level btree</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree3.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree3.png" alt="two-level btree"></a></p>
<p>首先让我们移除叶子节点已满的错误处理:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">leaf_node_insert</span><span class="params">(Cursor* cursor, <span class="type">uint32_t</span> key, Row* value)</span> </span>&#123;</span><br><span class="line">   <span class="type">void</span>* node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);</span><br><span class="line"> </span><br><span class="line">   <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">   <span class="keyword">if</span> (num_cells &gt;= LEAF_NODE_MAX_CELLS) &#123;</span><br><span class="line">     <span class="comment">// Node full</span></span><br><span class="line">-    <span class="built_in">printf</span>(<span class="string">&quot;Need to implement splitting a leaf node.\n&quot;</span>);</span><br><span class="line">-    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+    <span class="built_in">leaf_node_split_and_insert</span>(cursor, key, value);</span><br><span class="line">+    <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ExecuteResult <span class="title">execute_insert</span><span class="params">(Statement* statement, Table* table)</span> </span>&#123;</span><br><span class="line">   <span class="type">void</span>* node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">   <span class="type">uint32_t</span> num_cells = (*<span class="built_in">leaf_node_num_cells</span>(node));</span><br><span class="line">-  <span class="keyword">if</span> (num_cells &gt;= LEAF_NODE_MAX_CELLS) &#123;</span><br><span class="line">-    <span class="keyword">return</span> EXECUTE_TABLE_FULL;</span><br><span class="line">-  &#125;</span><br><span class="line"> </span><br><span class="line">   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);</span><br><span class="line">   <span class="type">uint32_t</span> key_to_insert = row_to_insert-&gt;id;</span><br></pre></td></tr></table></figure>
<h3 id="splitting-algorithm">Splitting Algorithm</h3>
<p>简单的部分结束了,<a target="_blank" rel="noopener" href="https://play.google.com/store/books/details/Sibsankar_Haldar_SQLite_Database_System_Design_and?id=9Z6IQQnX1JEC&amp;hl=en">SQLite Database System: Design and Implementation</a>里面描述了我们接下来要做的事情</p>
<blockquote>
<p>如果叶子节点没有剩余空间了，我们应该将叶子节点已有的记录和新的记录(待插入的那个)分成两个等长的部分:下半部分和上半部分(上半部分的所有键都严格大于下半部分的键.)然后创建一个新的叶子节点，然后上半部分移动到叶子节点里.</p>
</blockquote>
<p>让我们来处理旧的节点然后创建一个新的节点.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">void</span> <span class="title">leaf_node_split_and_insert</span><span class="params">(Cursor* cursor, <span class="type">uint32_t</span> key, Row* value)</span> </span>&#123;</span><br><span class="line">+  <span class="comment">/*</span></span><br><span class="line"><span class="comment">+  Create a new node and move half the cells over.</span></span><br><span class="line"><span class="comment">+  Insert the new value in one of the two nodes.</span></span><br><span class="line"><span class="comment">+  Update parent or create a new parent.</span></span><br><span class="line"><span class="comment">+  */</span></span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* old_node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> new_page_num = <span class="built_in">get_unused_page_num</span>(cursor-&gt;table-&gt;pager);</span><br><span class="line">+  <span class="type">void</span>* new_node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, new_page_num);</span><br><span class="line">+  <span class="built_in">initialize_leaf_node</span>(new_node);</span><br></pre></td></tr></table></figure>
<p>然后，拷贝每个cell到新的位置:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  <span class="comment">/*</span></span><br><span class="line"><span class="comment">+  All existing keys plus new key should be divided</span></span><br><span class="line"><span class="comment">+  evenly between old (left) and new (right) nodes.</span></span><br><span class="line"><span class="comment">+  Starting from the right, move each key to correct position.</span></span><br><span class="line"><span class="comment">+  */</span></span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">int32_t</span> i = LEAF_NODE_MAX_CELLS; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">+    <span class="type">void</span>* destination_node;</span><br><span class="line">+    <span class="keyword">if</span> (i &gt;= LEAF_NODE_LEFT_SPLIT_COUNT) &#123;</span><br><span class="line">+      destination_node = new_node;</span><br><span class="line">+    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+      destination_node = old_node;</span><br><span class="line">+    &#125;</span><br><span class="line">+    <span class="type">uint32_t</span> index_within_node = i % LEAF_NODE_LEFT_SPLIT_COUNT;</span><br><span class="line">+    <span class="type">void</span>* destination = <span class="built_in">leaf_node_cell</span>(destination_node, index_within_node);</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">if</span> (i == cursor-&gt;cell_num) &#123;</span><br><span class="line">+      <span class="built_in">serialize_row</span>(value, destination);</span><br><span class="line">+    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; cursor-&gt;cell_num) &#123;</span><br><span class="line">+      <span class="built_in">memcpy</span>(destination, <span class="built_in">leaf_node_cell</span>(old_node, i - <span class="number">1</span>), LEAF_NODE_CELL_SIZE);</span><br><span class="line">+    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+      <span class="built_in">memcpy</span>(destination, <span class="built_in">leaf_node_cell</span>(old_node, i), LEAF_NODE_CELL_SIZE);</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们需要更新两个叶子节点的父节点.如果原节点(即被分裂的叶子节点)是根节点,也就是没有父节点.在这种情况下，创建一个新的根节点作为父节点,目前我们暂时不实现更新父节点的操作:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  <span class="keyword">if</span> (<span class="built_in">is_node_root</span>(old_node)) &#123;</span><br><span class="line">+    <span class="keyword">return</span> <span class="built_in">create_new_root</span>(cursor-&gt;table, new_page_num);</span><br><span class="line">+  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Need to implement updating parent after split\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<h3 id="allocating-new-pages">Allocating New Pages</h3>
<p>让我们回去定义一些新的函数和常量.当我们创建一个新的叶子节点时，我们把它放进由函数<code>get_ununsed_page_num()</code>指定的页中:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+Until we start recycling free pages, new pages will always</span></span><br><span class="line"><span class="comment">+go onto the end of the database file</span></span><br><span class="line"><span class="comment">+*/</span></span><br><span class="line">+<span class="function"><span class="type">uint32_t</span> <span class="title">get_unused_page_num</span><span class="params">(Pager* pager)</span> </span>&#123; <span class="keyword">return</span> pager-&gt;num_pages; &#125;</span><br></pre></td></tr></table></figure>
<p>目前，我们假设数据库有N页，page下标从0到N-1已被分配.所以我们可以分配下标N给新的页.最终在我们执行了删除操作之后，一些页可能是空的并且它们的页下标未被使用，为了提高效率，我们可以重新分配那些空的页.</p>
<h3 id="leaf-node-sizes">Leaf Node Sizes</h3>
<p>为了保持树的平衡，我们将cells平均分配到两个新的节点中.如果一个叶子节点可以保存N个cell,那么在分裂中我们需要分配N+1个cell到两个节点中(N个原cell外加一个待插入的新cell).我决定给<strong>左边</strong>的节点<strong>多分配一个cell</strong>,如果N+1是奇数的话.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_RIGHT_SPLIT_COUNT = (LEAF_NODE_MAX_CELLS + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_LEFT_SPLIT_COUNT =</span><br><span class="line">+    (LEAF_NODE_MAX_CELLS + <span class="number">1</span>) - LEAF_NODE_RIGHT_SPLIT_COUNT;</span><br></pre></td></tr></table></figure>
<h3 id="creating-a-new-root">Creating a New Root</h3>
<p>这里<a target="_blank" rel="noopener" href="https://play.google.com/store/books/details/Sibsankar_Haldar_SQLite_Database_System_Design_and?id=9Z6IQQnX1JEC&amp;hl=en">SQLite Database System</a>阐释了创建一个新的根节点的过程:</p>
<blockquote>
<p>让<code>N</code>变为根节点.首先分配两个节点，叫做<code>L</code>和<code>R</code>.移动N的下半部分元素到L,上半部分元素到R.然后现在N就是空的了.</p>
<p>在N中增加<code>&lt;L,K,R&gt;</code>，<code>K</code>是<code>L</code>中最大的键.第N页也仍然是根节点.注意树的深度增加了1,但是新的树在不违背任何B+tree属性的情况下保持了高度平衡.</p>
</blockquote>
<p>目前，我们已经创建了右孩子并且把上半部分元素移入其中.我们的函数将右孩子作为参数，然后分配一个新的页来存储左孩子.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">void</span> <span class="title">create_new_root</span><span class="params">(Table* table, <span class="type">uint32_t</span> right_child_page_num)</span> </span>&#123;</span><br><span class="line">+  <span class="comment">/*</span></span><br><span class="line"><span class="comment">+  Handle splitting the root.</span></span><br><span class="line"><span class="comment">+  Old root copied to new page, becomes left child.</span></span><br><span class="line"><span class="comment">+  Address of right child passed in.</span></span><br><span class="line"><span class="comment">+  Re-initialize root page to contain the new root node.</span></span><br><span class="line"><span class="comment">+  New root node points to two children.</span></span><br><span class="line"><span class="comment">+  */</span></span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* root = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="type">void</span>* right_child = <span class="built_in">get_page</span>(table-&gt;pager, right_child_page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> left_child_page_num = <span class="built_in">get_unused_page_num</span>(table-&gt;pager);</span><br><span class="line">+  <span class="type">void</span>* left_child = <span class="built_in">get_page</span>(table-&gt;pager, left_child_page_num);</span><br></pre></td></tr></table></figure>
<p>原根节点的数据被拷贝进了左孩子,然后我们就能重新使用该页作为根节点了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  <span class="comment">/* Left child has data copied from old root */</span></span><br><span class="line">+  <span class="built_in">memcpy</span>(left_child, root, PAGE_SIZE);</span><br><span class="line">+  <span class="built_in">set_node_root</span>(left_child, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>最后我们需要将<strong>原根节点</strong>对应的页初始化为一个新的有两个孩子的<strong>内部节点</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  <span class="comment">/* Root node is a new internal node with one key and two children */</span></span><br><span class="line">+  <span class="built_in">initialize_internal_node</span>(root);</span><br><span class="line">+  <span class="built_in">set_node_root</span>(root, <span class="literal">true</span>);</span><br><span class="line">+  *<span class="built_in">internal_node_num_keys</span>(root) = <span class="number">1</span>;</span><br><span class="line">+  *<span class="built_in">internal_node_child</span>(root, <span class="number">0</span>) = left_child_page_num;</span><br><span class="line">+  <span class="type">uint32_t</span> left_child_max_key = <span class="built_in">get_node_max_key</span>(left_child);</span><br><span class="line">+  *<span class="built_in">internal_node_key</span>(root, <span class="number">0</span>) = left_child_max_key;</span><br><span class="line">+  *<span class="built_in">internal_node_right_child</span>(root) = right_child_page_num;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<h3 id="internal-node-format">Internal Node Format</h3>
<p>现在我们终于要创建一个内部节点了,我们要先定义它的布局.</p>
<p>内部节点以普通节点头部开始，然后是它包含的键的数量，然后是它的最右边节点的page number.内部节点存储的指向子节点的指针总是比键的数量多一个.那个额外的子节点指针存储在头部.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Internal Node Header Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_NUM_KEYS_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_NUM_KEYS_OFFSET = COMMON_NODE_HEADER_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_RIGHT_CHILD_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_RIGHT_CHILD_OFFSET =</span><br><span class="line">+    INTERNAL_NODE_NUM_KEYS_OFFSET + INTERNAL_NODE_NUM_KEYS_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_HEADER_SIZE = COMMON_NODE_HEADER_SIZE +</span><br><span class="line">+                                           INTERNAL_NODE_NUM_KEYS_SIZE +</span><br><span class="line">+                                           INTERNAL_NODE_RIGHT_CHILD_SIZE;</span><br></pre></td></tr></table></figure>
<p>body是一个存储cell的数组，每个cell包含一个指向子节点的指针和键.每个键应该是该键左边的子节点中的最大的键值.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Internal Node Body Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_KEY_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_CHILD_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_CELL_SIZE =</span><br><span class="line">+    INTERNAL_NODE_CHILD_SIZE + INTERNAL_NODE_KEY_SIZE;</span><br></pre></td></tr></table></figure>
<p>基于这些常量,内部节点的布局应该长这样:</p>
<p>Our internal node format</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/internal-node-format.png"><img src="https://cstack.github.io/db_tutorial/assets/images/internal-node-format.png" alt="内部节点布局"></a></p>
<p>Notice our huge branching factor(不知道咋翻译...).因为每个<code>子节点指针&amp;键</code>组合相当小，每个内部节点可以存储510个键和511个孩子指针.这意味着我们几乎不会需要遍历树的很多层来找到一个给定的键值.</p>
<table id="table">
<thead>
<tr>
<th>
# 内部节点层数
</th>
<th>
最多 # 叶子节点
</th>
<th>
所有叶子节点的总大小
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
0
</td>
<td>
511^0=1
</td>
<td>
4KB
</td>
</tr>
<tr>
<td>
1
</td>
<td>
511^1=512
</td>
<td>
~ 2MB
</td>
</tr>
<tr>
<td>
2
</td>
<td>
511^2=261,121
</td>
<td>
~ 1GB
</td>
</tr>
<tr>
<td>
3
</td>
<td>
511^3=133,432,831
</td>
<td>
~ 550GB
</td>
</tr>
</tbody>
</table>
<p>实际上，每个叶子节点不可能将4KB全部用来存储数据,因为还需要存储头部信息,键,还有一些空间被浪费了.但是我们只需要从磁盘中加载4页数据就可以搜索500GB的数据.这就是为什么B-Tree这个数据结构非常适合数据库.</p>
<p>这里有一些函数用来想内部节点读写数据:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">internal_node_num_keys</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + INTERNAL_NODE_NUM_KEYS_OFFSET;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">internal_node_right_child</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + INTERNAL_NODE_RIGHT_CHILD_OFFSET;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">internal_node_cell</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + INTERNAL_NODE_HEADER_SIZE + cell_num * INTERNAL_NODE_CELL_SIZE;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">internal_node_child</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> child_num)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint32_t</span> num_keys = *<span class="built_in">internal_node_num_keys</span>(node);</span><br><span class="line">+  <span class="keyword">if</span> (child_num &gt; num_keys) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Tried to access child_num %d &gt; num_keys %d\n&quot;</span>, child_num, num_keys);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child_num == num_keys) &#123;</span><br><span class="line">+    <span class="keyword">return</span> <span class="built_in">internal_node_right_child</span>(node);</span><br><span class="line">+  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+    <span class="keyword">return</span> <span class="built_in">internal_node_cell</span>(node, child_num);</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">internal_node_key</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> key_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> (<span class="type">uint32_t</span>* )((<span class="type">unsigned</span> <span class="type">char</span>* )<span class="built_in">internal_node_cell</span>(node,key_num)+INTERNAL_NODE_CHILD_SIZE);</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p id="fixBug1">
</p>
<p>译者注: 函数<code>internal_node_key()</code>的返回值原文为</p>
<p><code>return internal_node_cell(node, key_num) + INTERNAL_NODE_CHILD_SIZE;</code></p>
<p>但是<code>internal_node_cell()</code>函数返回值是<strong>4字节</strong>int指针,所以指针算数运算的单位为4个字节,需要<strong>先转换为单字节指针</strong>然后再加上偏移量</p>
</blockquote>
<p>对于一个内部节点，最大的key总是它的最右边的key.对于一个叶子节点,最大的key的下标最大:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">uint32_t</span> <span class="title">get_node_max_key</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">switch</span> (<span class="built_in">get_node_type</span>(node)) &#123;</span><br><span class="line">+    <span class="keyword">case</span> NODE_INTERNAL:</span><br><span class="line">+      <span class="keyword">return</span> *<span class="built_in">internal_node_key</span>(node, *<span class="built_in">internal_node_num_keys</span>(node) - <span class="number">1</span>);</span><br><span class="line">+    <span class="keyword">case</span> NODE_LEAF:</span><br><span class="line">+      <span class="keyword">return</span> *<span class="built_in">leaf_node_key</span>(node, *<span class="built_in">leaf_node_num_cells</span>(node) - <span class="number">1</span>);</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<h3 id="keeping-track-of-the-root">Keeping Track of the Root</h3>
<p>我们最后利用的是普通节点头部的<code>is_root</code>值.</p>
<p>记得我们使用它来决定如何分裂一个叶子节点的:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_node_root</span>(old_node)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">create_new_root</span>(cursor-&gt;table, new_page_num);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Need to implement updating parent after split\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有<code>getter &amp; setter</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">bool</span> <span class="title">is_node_root</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint8_t</span> value = *((<span class="type">uint8_t</span>*)(node + IS_ROOT_OFFSET));</span><br><span class="line">+  <span class="keyword">return</span> (<span class="type">bool</span>)value;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">set_node_root</span><span class="params">(<span class="type">void</span>* node, <span class="type">bool</span> is_root)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint8_t</span> value = is_root;</span><br><span class="line">+  *((<span class="type">uint8_t</span>*)(node + IS_ROOT_OFFSET)) = value;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<p>初始化每种节点都应该默认设置<code>is_root</code>为false:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">initialize_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">set_node_type</span>(node, NODE_LEAF);</span><br><span class="line">+  <span class="built_in">set_node_root</span>(node, <span class="literal">false</span>);</span><br><span class="line">   *<span class="built_in">leaf_node_num_cells</span>(node) = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">initialize_internal_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="built_in">set_node_type</span>(node, NODE_INTERNAL);</span><br><span class="line">+  <span class="built_in">set_node_root</span>(node, <span class="literal">false</span>);</span><br><span class="line">+  *<span class="built_in">internal_node_num_keys</span>(node) = <span class="number">0</span>;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<p>我们应该在创建的节点为table中的第一个节点时设置<code>is_root</code>为true:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">     <span class="comment">// New database file. Initialize page 0 as leaf node.</span></span><br><span class="line">     <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(pager, <span class="number">0</span>);</span><br><span class="line">     <span class="built_in">initialize_leaf_node</span>(root_node);</span><br><span class="line">+    <span class="built_in">set_node_root</span>(root_node, <span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> table;</span><br></pre></td></tr></table></figure>
<p></br></p>
<h3 id="printing-the-tree">Printing the Tree</h3>
<p>为了帮助我们可视化数据库的状态,我们应该更新<code>.btree</code>命令以打印一棵多阶树.</p>
<p>我将会替换现有的<code>print_leaf_node()</code>函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-<span class="function"><span class="type">void</span> <span class="title">print_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">-  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">-  <span class="built_in">printf</span>(<span class="string">&quot;leaf (size %d)\n&quot;</span>, num_cells);</span><br><span class="line">-  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_cells; i++) &#123;</span><br><span class="line">-    <span class="type">uint32_t</span> key = *<span class="built_in">leaf_node_key</span>(node, i);</span><br><span class="line">-    <span class="built_in">printf</span>(<span class="string">&quot;  - %d : %d\n&quot;</span>, i, key);</span><br><span class="line">-  &#125;</span><br><span class="line">-&#125;</span><br></pre></td></tr></table></figure>
<p>用一个递归函数代替它.递归函数接受一个任意节点作为参数，然后打印该节点和所有子节点.还接受一个参数作为缩进等级,在向下递归的时候缩进等级递增.我还添加了一个小的辅助函数用于打印缩进.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">void</span> <span class="title">indent</span><span class="params">(<span class="type">uint32_t</span> level)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">print_tree</span><span class="params">(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> indentation_level)</span> </span>&#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(pager, page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_keys, child;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">switch</span> (<span class="built_in">get_node_type</span>(node)) &#123;</span><br><span class="line">+    <span class="built_in">case</span> (NODE_LEAF):</span><br><span class="line">+      num_keys = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">+      <span class="built_in">indent</span>(indentation_level);</span><br><span class="line">+      <span class="built_in">printf</span>(<span class="string">&quot;- leaf (size %d)\n&quot;</span>, num_keys);</span><br><span class="line">+      <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_keys; i++) &#123;</span><br><span class="line">+        <span class="built_in">indent</span>(indentation_level + <span class="number">1</span>);</span><br><span class="line">+        <span class="built_in">printf</span>(<span class="string">&quot;- %d\n&quot;</span>, *<span class="built_in">leaf_node_key</span>(node, i));</span><br><span class="line">+      &#125;</span><br><span class="line">+      <span class="keyword">break</span>;</span><br><span class="line">+    <span class="built_in">case</span> (NODE_INTERNAL):</span><br><span class="line">+      num_keys = *<span class="built_in">internal_node_num_keys</span>(node);</span><br><span class="line">+      <span class="built_in">indent</span>(indentation_level);</span><br><span class="line">+      <span class="built_in">printf</span>(<span class="string">&quot;- internal (size %d)\n&quot;</span>, num_keys);</span><br><span class="line">+      <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_keys; i++) &#123;</span><br><span class="line">+        child = *<span class="built_in">internal_node_child</span>(node, i);</span><br><span class="line">+        <span class="built_in">print_tree</span>(pager, child, indentation_level + <span class="number">1</span>);</span><br><span class="line">+</span><br><span class="line">+        <span class="built_in">indent</span>(indentation_level + <span class="number">1</span>);</span><br><span class="line">+        <span class="built_in">printf</span>(<span class="string">&quot;- key %d\n&quot;</span>, *<span class="built_in">internal_node_key</span>(node, i));</span><br><span class="line">+      &#125;</span><br><span class="line">+      child = *<span class="built_in">internal_node_right_child</span>(node);</span><br><span class="line">+      <span class="built_in">print_tree</span>(pager, child, indentation_level + <span class="number">1</span>);</span><br><span class="line">+      <span class="keyword">break</span>;</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<p>然后更新<code>.btree</code>调用的函数,一开始传递的缩进等级为0.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.btree&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Tree:\n&quot;</span>);</span><br><span class="line">-    <span class="built_in">print_leaf_node</span>(<span class="built_in">get_page</span>(table-&gt;pager, <span class="number">0</span>));</span><br><span class="line">+    <span class="built_in">print_tree</span>(table-&gt;pager, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br></pre></td></tr></table></figure>
<p>这里有测试新的打印函数的代码喔!</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  it <span class="string">&#x27;allows printing out the structure of a 3-leaf-node btree&#x27;</span> <span class="keyword">do</span></span><br><span class="line">+    script = (<span class="number">1.</span><span class="number">.14</span>).map <span class="keyword">do</span> |i|</span><br><span class="line">+      <span class="string">&quot;insert #&#123;i&#125; user#&#123;i&#125; person#&#123;i&#125;@example.com&quot;</span></span><br><span class="line">+    end</span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;.btree&quot;</span></span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;insert 15 user15 person15@example.com&quot;</span></span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;.exit&quot;</span></span><br><span class="line">+    result = <span class="built_in">run_script</span>(script)</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">expect</span>(result[<span class="number">14.</span>..(result.length)]).to <span class="built_in">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; Tree:&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;- internal (size 1)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - leaf (size 7)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 1&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 2&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 3&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 4&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 5&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 6&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 7&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - key 7&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - leaf (size 7)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 8&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 9&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 10&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 11&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 12&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 13&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 14&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Need to implement searching an internal node&quot;</span>,</span><br><span class="line">+    ])</span><br><span class="line">+  end</span><br></pre></td></tr></table></figure>
<p>打印的内容被简化了,所以我们需要更新一下之前的<code>.btree</code>测试:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">       <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">       <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">       <span class="string">&quot;db &gt; Tree:&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;leaf (size 3)&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;  - 0 : 1&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;  - 1 : 2&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;  - 2 : 3&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;- leaf (size 3)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 1&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 2&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 3&quot;</span>,</span><br><span class="line">       <span class="string">&quot;db &gt; &quot;</span></span><br><span class="line">     ])</span><br><span class="line">   end</span><br></pre></td></tr></table></figure>
<p>这是<code>.btree</code>测试的输出:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tree:</span><br><span class="line">- internal (size 1)</span><br><span class="line">  - leaf (size 7)</span><br><span class="line">    - 1</span><br><span class="line">    - 2</span><br><span class="line">    - 3</span><br><span class="line">    - 4</span><br><span class="line">    - 5</span><br><span class="line">    - 6</span><br><span class="line">    - 7</span><br><span class="line">  - key 7</span><br><span class="line">  - leaf (size 7)</span><br><span class="line">    - 8</span><br><span class="line">    - 9</span><br><span class="line">    - 10</span><br><span class="line">    - 11</span><br><span class="line">    - 12</span><br><span class="line">    - 13</span><br><span class="line">    - 14</span><br></pre></td></tr></table></figure>
<p>在缩进级别0，我们看到了根节点(这是个内部节点喔).<code>size 1</code>表示它只有一个键.在缩进级别1,有一个叶子节点,一个键和另一个叶子节点.在根节点的键(7)是它的第一个左孩子的最大的键.所有比7大的键在第二个叶子节点里.</p>
<h3 id="a-major-problem">A Major Problem</h3>
<p>如果你观察仔细的话就会注意到我们忽略了很重要的事情.当我们尝试再插入一行时会变成这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db &gt; insert 15 user15 person15@example.com</span><br><span class="line">Need to implement searching an internal node</span><br></pre></td></tr></table></figure>
<p>哎呀!谁写下的TODO信息? :P 😤😤</p>
<p>在下一章我们会继续B-tree的传奇，实现在一个多阶树中搜索.</p>
<p></br></p>
<h2 id="part-11--recursively-searching-the-b-tree">Part 11 -Recursively Searching the B-Tree</h2>
<p>上一章结尾我们插入第15行得到了一个错误:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">db &gt; insert <span class="number">15</span> user15 person15@example.com</span><br><span class="line">Need to implement searching an internal node</span><br></pre></td></tr></table></figure>
<p>首先，用一个新的函数调用替换代码存根.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (<span class="built_in">get_node_type</span>(root_node) == NODE_LEAF) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">leaf_node_find</span>(table, root_page_num, key);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">-    <span class="built_in">printf</span>(<span class="string">&quot;Need to implement searching an internal node\n&quot;</span>);</span><br><span class="line">-    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+    <span class="keyword">return</span> <span class="built_in">internal_node_find</span>(table, root_page_num, key);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>该函数会用二分查找包含给定key的子节点.记住每个子节点指针的右边的key是该子节点包含的最大的key.</p>
<p>three-level btree</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree6.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree6.png" alt="three-level btree"></a></p>
<p>所以我们的二分查找会比较需要找到的key和子节点指针右边的key:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function">Cursor* <span class="title">internal_node_find</span><span class="params">(Table* table, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> key)</span> </span>&#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(table-&gt;pager, page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_keys = *<span class="built_in">internal_node_num_keys</span>(node);</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">/* Binary search to find index of child to search */</span></span><br><span class="line">+  <span class="type">uint32_t</span> min_index = <span class="number">0</span>;</span><br><span class="line">+  <span class="type">uint32_t</span> max_index = num_keys; <span class="comment">/* there is one more child than key */</span></span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">while</span> (min_index != max_index) &#123;</span><br><span class="line">+    <span class="type">uint32_t</span> index = (min_index + max_index) / <span class="number">2</span>;</span><br><span class="line">+    <span class="type">uint32_t</span> key_to_right = *<span class="built_in">internal_node_key</span>(node, index);</span><br><span class="line">+    <span class="keyword">if</span> (key_to_right &gt;= key) &#123;</span><br><span class="line">+      max_index = index;</span><br><span class="line">+    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+      min_index = index + <span class="number">1</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br></pre></td></tr></table></figure>
<p>还要记住一个内部节点的子节点可能是叶子节点或者内部节点.在我们找到正确的孩子后,要调用恰当的搜索函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  <span class="type">uint32_t</span> child_num = *<span class="built_in">internal_node_child</span>(node, min_index);</span><br><span class="line">+  <span class="type">void</span>* child = <span class="built_in">get_page</span>(table-&gt;pager, child_num);</span><br><span class="line">+  <span class="keyword">switch</span> (<span class="built_in">get_node_type</span>(child)) &#123;</span><br><span class="line">+    <span class="keyword">case</span> NODE_LEAF:</span><br><span class="line">+      <span class="keyword">return</span> <span class="built_in">leaf_node_find</span>(table, child_num, key);</span><br><span class="line">+    <span class="keyword">case</span> NODE_INTERNAL:</span><br><span class="line">+      <span class="keyword">return</span> <span class="built_in">internal_node_find</span>(table, child_num, key);</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译者注: 还有一个地方需要修改-<code>execute_insert</code></p>
<figure>
<img src="https://gitee.com/salt3dfish/images/raw/master/hexo/22-04-30/dedd9d12883cad9c4047e8b84fead216.png" alt="" /><figcaption>image-20220430155156393</figcaption>
</figure>
<p>因为现在搜索后的<code>cursor</code>不一定指向根节点，所以node应该是cursor指向的节点</p>
</blockquote>
<h3 id="tests">Tests</h3>
<p>现在向多节点btree中插入键不再会导致错误了.然后我们可以更新下我们的测试:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       &quot;    - 12&quot;,</span><br><span class="line">       &quot;    - 13&quot;,</span><br><span class="line">       &quot;    - 14&quot;,</span><br><span class="line">-      &quot;db &gt; Need to implement searching an internal node&quot;,</span><br><span class="line">+      &quot;db &gt; Executed.&quot;,</span><br><span class="line">+      &quot;db &gt; &quot;,</span><br><span class="line">     ])</span><br><span class="line">   end</span><br></pre></td></tr></table></figure>
<p>我认为还可以重用一下另一个测试,就是那个试图插入1400行的.它仍然会出错，但是错误信息变了.目前该测试在程序中断的时候不能很好地处理.如果程序崩溃了，我们只需要使用目前使用的错误信息:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">     raw_output = nil</span><br><span class="line">     IO.<span class="title function_ invoke__">popen</span>(<span class="string">&quot;./db test.db&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">do</span> |pipe|</span><br><span class="line">       commands.each <span class="keyword">do</span> |command|</span><br><span class="line">-        pipe.puts command</span><br><span class="line">+        begin</span><br><span class="line">+          pipe.puts command</span><br><span class="line">+        rescue Errno::EPIPE</span><br><span class="line">+          <span class="keyword">break</span></span><br><span class="line">+        end</span><br><span class="line">       end</span><br><span class="line"></span><br><span class="line">       pipe.close_write</span><br></pre></td></tr></table></figure>
<p>然后这揭露了1400行测试的错误信息是这个:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">     end</span><br><span class="line">     script &lt;&lt; <span class="string">&quot;.exit&quot;</span></span><br><span class="line">     result = <span class="title function_ invoke__">run_script</span>(script)</span><br><span class="line">-    <span class="title function_ invoke__">expect</span>(result[-<span class="number">2</span>]).to <span class="title function_ invoke__">eq</span>(<span class="symbol">&#x27;db</span> &gt; Error: Table full.&#x27;)</span><br><span class="line">+    <span class="title function_ invoke__">expect</span>(result.<span class="title function_ invoke__">last</span>(<span class="number">2</span>)).to <span class="title function_ invoke__">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Need to implement updating parent after split&quot;</span>,</span><br><span class="line">+    ])</span><br><span class="line">   end</span><br></pre></td></tr></table></figure>
<p>这看起来好像是我们to-do列表的下一个目标!</p>
<p></br></p>
<h2 id="part-12--scanning-a-multi-level-b-tree">Part 12 -Scanning a Multi-Level B-Tree</h2>
<p>目前我们的数据库程序支持构建多阶btree,但是我们在这个过程中破坏了<code>select</code>语句.这里有一个测试插入15行然后尝试打印它们.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  it <span class="string">&#x27;prints all rows in a multi-level tree&#x27;</span> <span class="keyword">do</span></span><br><span class="line">+    script = []</span><br><span class="line">+    (<span class="number">1.</span><span class="number">.15</span>).each <span class="keyword">do</span> |i|</span><br><span class="line">+      script &lt;&lt; <span class="string">&quot;insert #&#123;i&#125; user#&#123;i&#125; person#&#123;i&#125;@example.com&quot;</span></span><br><span class="line">+    end</span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;select&quot;</span></span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;.exit&quot;</span></span><br><span class="line">+    result = <span class="built_in">run_script</span>(script)</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">expect</span>(result[<span class="number">15.</span>..result.length]).to <span class="built_in">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; (1, user1, person1@example.com)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;(2, user2, person2@example.com)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;(3, user3, person3@example.com)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;(4, user4, person4@example.com)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;(5, user5, person5@example.com)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;(6, user6, person6@example.com)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;(7, user7, person7@example.com)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;(8, user8, person8@example.com)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;(9, user9, person9@example.com)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;(10, user10, person10@example.com)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;(11, user11, person11@example.com)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;(12, user12, person12@example.com)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;(13, user13, person13@example.com)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;(14, user14, person14@example.com)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;(15, user15, person15@example.com)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;Executed.&quot;</span>, <span class="string">&quot;db &gt; &quot;</span>,</span><br><span class="line">+    ])</span><br><span class="line">+  end</span><br></pre></td></tr></table></figure>
<p>但是当我们运行这个测试的时候，实际上会发生这个:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db &gt; select</span><br><span class="line">(2, user1, person1@example.com)</span><br><span class="line">Executed.</span><br></pre></td></tr></table></figure>
<p>这很奇怪不是阿木.它只打印了一行数据，并且该行看起来已经损坏了(注意id和username不匹配).</p>
<p>产生这个问题的原因是<code>execute_select()</code>从table的开头开始,然后我们当前的<code>table_start()</code>函数返回的是根节点的下标为0的cell.但是我们的btree的根节点现在是一个内部节点，不包含任何行.所以打印出来的数据一定是从根节点还是叶子节点的时候留下来的.<code>execute_select()</code>真正应该返回的是最左边叶子节点的下标为0的cell.</p>
<p>所以让我们先清除旧的实现:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-<span class="function">Cursor* <span class="title">table_start</span><span class="params">(Table* table)</span> </span>&#123;</span><br><span class="line">-  Cursor* cursor = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Cursor));</span><br><span class="line">-  cursor-&gt;table = table;</span><br><span class="line">-  cursor-&gt;page_num = table-&gt;root_page_num;</span><br><span class="line">-  cursor-&gt;cell_num = <span class="number">0</span>;</span><br><span class="line">-</span><br><span class="line">-  <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">-  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(root_node);</span><br><span class="line">-  cursor-&gt;end_of_table = (num_cells == <span class="number">0</span>);</span><br><span class="line">-</span><br><span class="line">-  <span class="keyword">return</span> cursor;</span><br><span class="line">-&#125;</span><br></pre></td></tr></table></figure>
<p>然后添加新的实现，搜索key<sub>0</sub>(可能的最小key).即使key<sub>0</sub>在表中不存在,该函数会返回最小的id的位置(最左边的叶子节点的开头).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function">Cursor* <span class="title">table_start</span><span class="params">(Table* table)</span> </span>&#123;</span><br><span class="line">+  Cursor* cursor =  <span class="built_in">table_find</span>(table, <span class="number">0</span>);</span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(table-&gt;pager, cursor-&gt;page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">+  cursor-&gt;end_of_table = (num_cells == <span class="number">0</span>);</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">return</span> cursor;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<p>通过这些改动，它仍然只打印一个叶子节点的所有行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db &gt; select</span><br><span class="line">(1, user1, person1@example.com)</span><br><span class="line">(2, user2, person2@example.com)</span><br><span class="line">(3, user3, person3@example.com)</span><br><span class="line">(4, user4, person4@example.com)</span><br><span class="line">(5, user5, person5@example.com)</span><br><span class="line">(6, user6, person6@example.com)</span><br><span class="line">(7, user7, person7@example.com)</span><br><span class="line">Executed.</span><br><span class="line">db &gt;</span><br></pre></td></tr></table></figure>
<p>因为一共有15条记录,我们的btree包含一个内部节点和两个叶子节点，就像这样:</p>
<p>structure of our btree</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree3.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree3.png" alt="structure of our btree"></a></p>
<p>为了扫描整个表,当我们到达第一个叶子节点的末尾后需要跳到第二个叶子节点.为了实现这个操作，我们将在叶子节点的头部存储一个新的字段 - "next_leaf",该字段的值为该叶子节点的右边的兄弟节点的page number.最右边的叶子节点的<code>next_leaf</code>的值为0以表示它没有右兄弟(page<sub>0</sub>不论何时都预留给表的根节点).</p>
<p>更新叶子节点的头部格式以包含新的字段:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_NUM_CELLS_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line"> <span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;</span><br><span class="line">-<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_HEADER_SIZE =</span><br><span class="line">-    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_NEXT_LEAF_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_NEXT_LEAF_OFFSET =</span><br><span class="line">+    LEAF_NODE_NUM_CELLS_OFFSET + LEAF_NODE_NUM_CELLS_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_HEADER_SIZE = COMMON_NODE_HEADER_SIZE +</span><br><span class="line">+                                       LEAF_NODE_NUM_CELLS_SIZE +</span><br><span class="line">+                                       LEAF_NODE_NEXT_LEAF_SIZE;</span><br></pre></td></tr></table></figure>
<p>以及一个函数用来获取该字段:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">leaf_node_next_leaf</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + LEAF_NODE_NEXT_LEAF_OFFSET;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<p>初始化一个新的叶子节点时令<code>next_leaf</code>为0：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@@ <span class="number">-322</span>,<span class="number">6</span> +<span class="number">330</span>,<span class="number">7</span> @@ <span class="function"><span class="type">void</span> <span class="title">initialize_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">set_node_type</span>(node, NODE_LEAF);</span><br><span class="line">   <span class="built_in">set_node_root</span>(node, <span class="literal">false</span>);</span><br><span class="line">   *<span class="built_in">leaf_node_num_cells</span>(node) = <span class="number">0</span>;</span><br><span class="line">+  *<span class="built_in">leaf_node_next_leaf</span>(node) = <span class="number">0</span>;  <span class="comment">// 0 represents no sibling</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>当我们分裂一个叶子节点时,更新兄弟指针.旧的叶子节点的兄弟变成了新创建的叶子,然后新的叶子节点的兄弟是旧叶子节点的原兄弟,无论原兄弟是什么.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@@ <span class="number">-659</span>,<span class="number">6</span> +<span class="number">671</span>,<span class="number">8</span> @@ <span class="function"><span class="type">void</span> <span class="title">leaf_node_split_and_insert</span><span class="params">(Cursor* cursor, <span class="type">uint32_t</span> key, Row* value)</span> </span>&#123;</span><br><span class="line">   <span class="type">uint32_t</span> new_page_num = <span class="built_in">get_unused_page_num</span>(cursor-&gt;table-&gt;pager);</span><br><span class="line">   <span class="type">void</span>* new_node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, new_page_num);</span><br><span class="line">   <span class="built_in">initialize_leaf_node</span>(new_node);</span><br><span class="line">+  *<span class="built_in">leaf_node_next_leaf</span>(new_node) = *<span class="built_in">leaf_node_next_leaf</span>(old_node);</span><br><span class="line">+  *<span class="built_in">leaf_node_next_leaf</span>(old_node) = new_page_num;</span><br></pre></td></tr></table></figure>
<p>增加一个新的字段会改变一些常量:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   it &#x27;prints constants&#x27; do</span><br><span class="line">     script = [</span><br><span class="line">       &quot;.constants&quot;,</span><br><span class="line">@@ -199,9 +228,9 @@ describe &#x27;database&#x27; do</span><br><span class="line">       &quot;db &gt; Constants:&quot;,</span><br><span class="line">       &quot;ROW_SIZE: 293&quot;,</span><br><span class="line">       &quot;COMMON_NODE_HEADER_SIZE: 6&quot;,</span><br><span class="line">-      &quot;LEAF_NODE_HEADER_SIZE: 10&quot;,</span><br><span class="line">+      &quot;LEAF_NODE_HEADER_SIZE: 14&quot;,</span><br><span class="line">       &quot;LEAF_NODE_CELL_SIZE: 297&quot;,</span><br><span class="line">-      &quot;LEAF_NODE_SPACE_FOR_CELLS: 4086&quot;,</span><br><span class="line">+      &quot;LEAF_NODE_SPACE_FOR_CELLS: 4082&quot;,</span><br><span class="line">       &quot;LEAF_NODE_MAX_CELLS: 13&quot;,</span><br><span class="line">       &quot;db &gt; &quot;,</span><br><span class="line">     ])</span><br></pre></td></tr></table></figure>
<p>现在无论何时我们想要cursor从一个叶子节点的末尾前进,我们可以检查该叶子节点是否有兄弟.如果有就跳到它那里,没有的话就意味着我们就到达了表的末尾.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@@ <span class="number">-428</span>,<span class="number">7</span> +<span class="number">432</span>,<span class="number">15</span> @@ <span class="function"><span class="type">void</span> <span class="title">cursor_advance</span><span class="params">(Cursor* cursor)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   cursor-&gt;cell_num += <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (cursor-&gt;cell_num &gt;= (*<span class="built_in">leaf_node_num_cells</span>(node))) &#123;</span><br><span class="line">-    cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line">+    <span class="comment">/* Advance to next leaf node */</span></span><br><span class="line">+    <span class="type">uint32_t</span> next_page_num = *<span class="built_in">leaf_node_next_leaf</span>(node);</span><br><span class="line">+    <span class="keyword">if</span> (next_page_num == <span class="number">0</span>) &#123;</span><br><span class="line">+      <span class="comment">/* This was rightmost leaf */</span></span><br><span class="line">+      cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line">+    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+      cursor-&gt;page_num = next_page_num;</span><br><span class="line">+      cursor-&gt;cell_num = <span class="number">0</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>做了这些改动之后，我们雀食打印了15行了喔...</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db &gt; select</span><br><span class="line">(1, user1, person1@example.com)</span><br><span class="line">(2, user2, person2@example.com)</span><br><span class="line">(3, user3, person3@example.com)</span><br><span class="line">(4, user4, person4@example.com)</span><br><span class="line">(5, user5, person5@example.com)</span><br><span class="line">(6, user6, person6@example.com)</span><br><span class="line">(7, user7, person7@example.com)</span><br><span class="line">(8, user8, person8@example.com)</span><br><span class="line">(9, user9, person9@example.com)</span><br><span class="line">(10, user10, person10@example.com)</span><br><span class="line">(11, user11, person11@example.com)</span><br><span class="line">(12, user12, person12@example.com)</span><br><span class="line">(13, user13, person13@example.com)</span><br><span class="line">(1919251317, 14, on14@example.com)</span><br><span class="line">(15, user15, person15@example.com)</span><br><span class="line">Executed.</span><br><span class="line">db &gt;</span><br></pre></td></tr></table></figure>
<p>...但是其中的一行看起来好像损坏了.</p>
<p>在经过一些调试之后，我发现这个bug来自分裂叶子节点的函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@@ <span class="number">-676</span>,<span class="number">7</span> +<span class="number">690</span>,<span class="number">9</span> @@ <span class="function"><span class="type">void</span> <span class="title">leaf_node_split_and_insert</span><span class="params">(Cursor* cursor, <span class="type">uint32_t</span> key, Row* value)</span> </span>&#123;</span><br><span class="line">     <span class="type">void</span>* destination = <span class="built_in">leaf_node_cell</span>(destination_node, index_within_node);</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span> (i == cursor-&gt;cell_num) &#123;</span><br><span class="line">-      <span class="built_in">serialize_row</span>(value, destination);</span><br><span class="line">+      <span class="built_in">serialize_row</span>(value,</span><br><span class="line">+                    <span class="built_in">leaf_node_value</span>(destination_node, index_within_node));</span><br><span class="line">+      *<span class="built_in">leaf_node_key</span>(destination_node, index_within_node) = key;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; cursor-&gt;cell_num) &#123;</span><br><span class="line">       <span class="built_in">memcpy</span>(destination, <span class="built_in">leaf_node_cell</span>(old_node, i - <span class="number">1</span>), LEAF_NODE_CELL_SIZE);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure>
<p>请记住叶子节点的每一个cell包含key和value,key在前,value在后喔:</p>
<p>Original leaf node format</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/leaf-node-format.png"><img src="https://cstack.github.io/db_tutorial/assets/images/leaf-node-format.png" alt="Original leaf node format"></a></p>
<p>我们把待插入的行(的value)写入了cell的开头,而这应该是存储key的地方.这意味着username的一部分变成了id(导致id大的变态).</p>
<blockquote>
<p>译者注: 呃，让我来解释一下...</p>
<p>cell的存储格式为key+value,但是分裂函数中只写入了value,而value是key+username+email,所以即使格式错了,但是key是对的,能被正确索引.</p>
<p>但是读取的时候是直接读取value部分的,而这部分现在变成了username+email(本来应该是key+usn+email).</p>
</blockquote>
<p>修复了bug之后,我们最终可以如期打印整个表了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db &gt; select</span><br><span class="line">(1, user1, person1@example.com)</span><br><span class="line">(2, user2, person2@example.com)</span><br><span class="line">(3, user3, person3@example.com)</span><br><span class="line">(4, user4, person4@example.com)</span><br><span class="line">(5, user5, person5@example.com)</span><br><span class="line">(6, user6, person6@example.com)</span><br><span class="line">(7, user7, person7@example.com)</span><br><span class="line">(8, user8, person8@example.com)</span><br><span class="line">(9, user9, person9@example.com)</span><br><span class="line">(10, user10, person10@example.com)</span><br><span class="line">(11, user11, person11@example.com)</span><br><span class="line">(12, user12, person12@example.com)</span><br><span class="line">(13, user13, person13@example.com)</span><br><span class="line">(14, user14, person14@example.com)</span><br><span class="line">(15, user15, person15@example.com)</span><br><span class="line">Executed.</span><br><span class="line">db &gt;</span><br></pre></td></tr></table></figure>
<p>😼😼!一个接一个的bug,但是我们一直在前进.</p>
<p>直到下一次.</p>
<p></br></p>
<h2 id="part-13---updating-parent-node-after-a-split">Part 13 - Updating Parent Node After a Split</h2>
<p>对于史诗般的b-tree之旅的下一步,我们将要在分裂叶子节点之后处理父节点,我会使用下面的例子作为参考:</p>
<p>Example of updating internal node</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/updating-internal-node.png"><img src="https://cstack.github.io/db_tutorial/assets/images/updating-internal-node.png" alt="Example of updating internal node"></a></p>
<p>在这个例子中,我们给树添加了key<sub>3</sub>.这导致了左边叶子节点的分裂.在分裂之后我们通过下面这些步骤修复这棵树:</p>
<ol type="1">
<li>更新父节点的第一个key为最左边子节点的key<sub>max</sub>(本例中是3).</li>
<li>在更新后的key后面添加一个子节点指针/key对
<ul>
<li>新的子节点指针指向新的子节点</li>
<li>新的key是新的子节点的key<sub>max</sub></li>
</ul></li>
</ol>
<p>那么第一件事是,用两个新函数调用替换我们的占坑代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">update_internal_node_key</span>() <span class="keyword">for</span> step <span class="number">1</span> <span class="function"><span class="keyword">and</span> <span class="title">internal_node_insert</span><span class="params">()</span> <span class="keyword">for</span> step 2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">@@ -670,9 +725,11 @@ <span class="type">void</span> <span class="title">leaf_node_split_and_insert</span><span class="params">(Cursor* cursor, <span class="type">uint32_t</span> key, Row* value)</span> </span>&#123;</span><br><span class="line">   */</span><br><span class="line"> </span><br><span class="line">   <span class="type">void</span>* old_node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> old_max = <span class="built_in">get_node_max_key</span>(old_node);</span><br><span class="line">   <span class="type">uint32_t</span> new_page_num = <span class="built_in">get_unused_page_num</span>(cursor-&gt;table-&gt;pager);</span><br><span class="line">   <span class="type">void</span>* new_node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, new_page_num);</span><br><span class="line">   <span class="built_in">initialize_leaf_node</span>(new_node);</span><br><span class="line">+  *<span class="built_in">node_parent</span>(new_node) = *<span class="built_in">node_parent</span>(old_node);</span><br><span class="line">   *<span class="built_in">leaf_node_next_leaf</span>(new_node) = *<span class="built_in">leaf_node_next_leaf</span>(old_node);</span><br><span class="line">   *<span class="built_in">leaf_node_next_leaf</span>(old_node) = new_page_num;</span><br><span class="line"> </span><br><span class="line">@@ <span class="number">-709</span>,<span class="number">8</span> +<span class="number">766</span>,<span class="number">12</span> @@ <span class="function"><span class="type">void</span> <span class="title">leaf_node_split_and_insert</span><span class="params">(Cursor* cursor, <span class="type">uint32_t</span> key, Row* value)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">is_node_root</span>(old_node)) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">create_new_root</span>(cursor-&gt;table, new_page_num);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">-    <span class="built_in">printf</span>(<span class="string">&quot;Need to implement updating parent after split\n&quot;</span>);</span><br><span class="line">-    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+    <span class="type">uint32_t</span> parent_page_num = *<span class="built_in">node_parent</span>(old_node);</span><br><span class="line">+    <span class="type">uint32_t</span> new_max = <span class="built_in">get_node_max_key</span>(old_node);</span><br><span class="line">+    <span class="type">void</span>* parent = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, parent_page_num);</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">update_internal_node_key</span>(parent, old_max, new_max);</span><br><span class="line">+    <span class="built_in">internal_node_insert</span>(cursor-&gt;table, parent_page_num, new_page_num);</span><br><span class="line">+    <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>为了获取父节点的引用，我们需要在每个节点中记录指向父节点的指针.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">node_parent</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123; <span class="keyword">return</span> node + PARENT_POINTER_OFFSET; &#125;</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-660</span>,<span class="number">6</span> +<span class="number">675</span>,<span class="number">48</span> @@ <span class="function"><span class="type">void</span> <span class="title">create_new_root</span><span class="params">(Table* table, <span class="type">uint32_t</span> right_child_page_num)</span> </span>&#123;</span><br><span class="line">   <span class="type">uint32_t</span> left_child_max_key = <span class="built_in">get_node_max_key</span>(left_child);</span><br><span class="line">   *<span class="built_in">internal_node_key</span>(root, <span class="number">0</span>) = left_child_max_key;</span><br><span class="line">   *<span class="built_in">internal_node_right_child</span>(root) = right_child_page_num;</span><br><span class="line">+  *<span class="built_in">node_parent</span>(left_child) = table-&gt;root_page_num;</span><br><span class="line">+  *<span class="built_in">node_parent</span>(right_child) = table-&gt;root_page_num;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>现在我们需要找到在父节点中因为分裂操作而受到影响的cell.(分裂的)子节点不知道它在父节点中的cell<sub>index</sub>,所以我们不能根据下标找到它.但是我们知道该子节点的key<sub>max</sub>,所以我们可以在父节点中搜索这个key.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">void</span> <span class="title">update_internal_node_key</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> old_key, <span class="type">uint32_t</span> new_key)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint32_t</span> old_child_index = <span class="built_in">internal_node_find_child</span>(node, old_key);</span><br><span class="line">+  *<span class="built_in">internal_node_key</span>(node, old_child_index) = new_key;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>internal_node_find_child()</code>内部复用了一些在内部节点搜索key的代码.重构<code>internal_node_find()</code>以使用新的辅助函数.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-<span class="function">Cursor* <span class="title">internal_node_find</span><span class="params">(Table* table, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> key)</span> </span>&#123;</span><br><span class="line">-  <span class="type">void</span>* node = <span class="built_in">get_page</span>(table-&gt;pager, page_num);</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span> <span class="title">internal_node_find_child</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> key)</span> </span>&#123;</span><br><span class="line">+  <span class="comment">/*</span></span><br><span class="line"><span class="comment">+  Return the index of the child which should contain</span></span><br><span class="line"><span class="comment">+  the given key.</span></span><br><span class="line"><span class="comment">+  */</span></span><br><span class="line">+</span><br><span class="line">   <span class="type">uint32_t</span> num_keys = *<span class="built_in">internal_node_num_keys</span>(node);</span><br><span class="line"> </span><br><span class="line">-  <span class="comment">/* Binary search to find index of child to search */</span></span><br><span class="line">+  <span class="comment">/* Binary search */</span></span><br><span class="line">   <span class="type">uint32_t</span> min_index = <span class="number">0</span>;</span><br><span class="line">   <span class="type">uint32_t</span> max_index = num_keys; <span class="comment">/* there is one more child than key */</span></span><br><span class="line"> </span><br><span class="line">@@ <span class="number">-386</span>,<span class="number">7</span> +<span class="number">394</span>,<span class="number">14</span> @@ <span class="function">Cursor* <span class="title">internal_node_find</span><span class="params">(Table* table, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> key)</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">-  <span class="type">uint32_t</span> child_num = *<span class="built_in">internal_node_child</span>(node, min_index);</span><br><span class="line">+  <span class="keyword">return</span> min_index;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function">Cursor* <span class="title">internal_node_find</span><span class="params">(Table* table, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> key)</span> </span>&#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(table-&gt;pager, page_num);</span><br><span class="line">+</span><br><span class="line">+  <span class="type">uint32_t</span> child_index = <span class="built_in">internal_node_find_child</span>(node, key);</span><br><span class="line">+  <span class="type">uint32_t</span> child_num = *<span class="built_in">internal_node_child</span>(node, child_index);</span><br><span class="line">   <span class="type">void</span>* child = <span class="built_in">get_page</span>(table-&gt;pager, child_num);</span><br><span class="line">   <span class="keyword">switch</span> (<span class="built_in">get_node_type</span>(child)) &#123;</span><br><span class="line">     <span class="keyword">case</span> NODE_LEAF:</span><br></pre></td></tr></table></figure>
<p>现在我们到了这一章的核心部分,实现函数<code>internal_node_insert()</code>.我将分成几个部分来解释这玩意.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">void</span> <span class="title">internal_node_insert</span><span class="params">(Table* table, <span class="type">uint32_t</span> parent_page_num,</span></span></span><br><span class="line"><span class="params"><span class="function">+                          <span class="type">uint32_t</span> child_page_num)</span> </span>&#123;</span><br><span class="line">+  <span class="comment">/*</span></span><br><span class="line"><span class="comment">+  Add a new child/key pair to parent that corresponds to child</span></span><br><span class="line"><span class="comment">+  */</span></span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* parent = <span class="built_in">get_page</span>(table-&gt;pager, parent_page_num);</span><br><span class="line">+  <span class="type">void</span>* child = <span class="built_in">get_page</span>(table-&gt;pager, child_page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> child_max_key = <span class="built_in">get_node_max_key</span>(child);</span><br><span class="line">+  <span class="type">uint32_t</span> index = <span class="built_in">internal_node_find_child</span>(parent, child_max_key);</span><br><span class="line">+</span><br><span class="line">+  <span class="type">uint32_t</span> original_num_keys = *<span class="built_in">internal_node_num_keys</span>(parent);</span><br><span class="line">+  *<span class="built_in">internal_node_num_keys</span>(parent) = original_num_keys + <span class="number">1</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (original_num_keys &gt;= INTERNAL_NODE_MAX_CELLS) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Need to implement splitting internal node\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125;</span><br></pre></td></tr></table></figure>
<p>根据新的子节点的key<sub>max</sub>得到新的cell(子节点指针&amp;键 pair)应该插入的位置的下标index.在我们看到的例子中,<code>child_max_key</code>是5然后下标为1.</p>
<p>如果内部节点没有空间来插入一个cell,抛出一个错误.我们将会在后续章实现分裂内部节点.</p>
<p>现在看一下函数的其余部分:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+</span><br><span class="line">+  <span class="type">uint32_t</span> right_child_page_num = *<span class="built_in">internal_node_right_child</span>(parent);</span><br><span class="line">+  <span class="type">void</span>* right_child = <span class="built_in">get_page</span>(table-&gt;pager, right_child_page_num);</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (child_max_key &gt; <span class="built_in">get_node_max_key</span>(right_child)) &#123;</span><br><span class="line">+    <span class="comment">/* Replace right child */</span></span><br><span class="line">+    *<span class="built_in">internal_node_child</span>(parent, original_num_keys) = right_child_page_num;</span><br><span class="line">+    *<span class="built_in">internal_node_key</span>(parent, original_num_keys) =</span><br><span class="line">+        <span class="built_in">get_node_max_key</span>(right_child);</span><br><span class="line">+    *<span class="built_in">internal_node_right_child</span>(parent) = child_page_num;</span><br><span class="line">+  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+    <span class="comment">/* Make room for the new cell */</span></span><br><span class="line">+    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = original_num_keys; i &gt; index; i--) &#123;</span><br><span class="line">+      <span class="type">void</span>* destination = <span class="built_in">internal_node_cell</span>(parent, i);</span><br><span class="line">+      <span class="type">void</span>* source = <span class="built_in">internal_node_cell</span>(parent, i - <span class="number">1</span>);</span><br><span class="line">+      <span class="built_in">memcpy</span>(destination, source, INTERNAL_NODE_CELL_SIZE);</span><br><span class="line">+    &#125;</span><br><span class="line">+    *<span class="built_in">internal_node_child</span>(parent, index) = child_page_num;</span><br><span class="line">+    *<span class="built_in">internal_node_key</span>(parent, index) = child_max_key;</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们将最右边子节点指针与其余的<code>子节点指针&amp;键 pair</code>分开来存储,所以需要特殊处理当新的子节点成为最右边子节点的情况.</p>
<p>在函数中,我们可能会进入<code>else</code>块.首先为新的cell腾出空间,将其他cell右移一个cell单位.(尽管在我们的示例中没有cell需要移动)</p>
<p>然后，将新的<code>子节点指针&amp;key pair</code>写入<code>index</code>对应的cell位置.</p>
<p>为了减少测试用例的大小,我目前硬编码了<code>INTERNAL_NODE_MAX_CELLS</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@@ <span class="number">-126</span>,<span class="number">6</span> +<span class="number">126</span>,<span class="number">8</span> @@ <span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_KEY_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line"> <span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_CHILD_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line"> <span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_CELL_SIZE =</span><br><span class="line">     INTERNAL_NODE_CHILD_SIZE + INTERNAL_NODE_KEY_SIZE;</span><br><span class="line">+<span class="comment">/* Keep this small for testing */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_MAX_CELLS = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>说到测试,我们的大量数据测试用例需要修改一下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@ -65,7 +65,7 @@ describe &#x27;database&#x27; do</span><br><span class="line">     result = run_script(script)</span><br><span class="line">     expect(result.last(2)).to match_array([</span><br><span class="line">       &quot;db &gt; Executed.&quot;,</span><br><span class="line">-      &quot;db &gt; Need to implement updating parent after split&quot;,</span><br><span class="line">+      &quot;db &gt; Need to implement splitting internal node&quot;,</span><br><span class="line">     ])</span><br></pre></td></tr></table></figure>
<p>Very satisfying, I know.</p>
<p>再加个测试来打印一棵4个节点的树.目前为止我们的测试的插入ID都是顺序的,这个测试将会以伪随机顺序插入记录.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+  it &#x27;allows printing out the structure of a 4-leaf-node btree&#x27; do</span><br><span class="line">+    script = [</span><br><span class="line">+      &quot;insert 18 user18 person18@example.com&quot;,</span><br><span class="line">+      &quot;insert 7 user7 person7@example.com&quot;,</span><br><span class="line">+      &quot;insert 10 user10 person10@example.com&quot;,</span><br><span class="line">+      &quot;insert 29 user29 person29@example.com&quot;,</span><br><span class="line">+      &quot;insert 23 user23 person23@example.com&quot;,</span><br><span class="line">+      &quot;insert 4 user4 person4@example.com&quot;,</span><br><span class="line">+      &quot;insert 14 user14 person14@example.com&quot;,</span><br><span class="line">+      &quot;insert 30 user30 person30@example.com&quot;,</span><br><span class="line">+      &quot;insert 15 user15 person15@example.com&quot;,</span><br><span class="line">+      &quot;insert 26 user26 person26@example.com&quot;,</span><br><span class="line">+      &quot;insert 22 user22 person22@example.com&quot;,</span><br><span class="line">+      &quot;insert 19 user19 person19@example.com&quot;,</span><br><span class="line">+      &quot;insert 2 user2 person2@example.com&quot;,</span><br><span class="line">+      &quot;insert 1 user1 person1@example.com&quot;,</span><br><span class="line">+      &quot;insert 21 user21 person21@example.com&quot;,</span><br><span class="line">+      &quot;insert 11 user11 person11@example.com&quot;,</span><br><span class="line">+      &quot;insert 6 user6 person6@example.com&quot;,</span><br><span class="line">+      &quot;insert 20 user20 person20@example.com&quot;,</span><br><span class="line">+      &quot;insert 5 user5 person5@example.com&quot;,</span><br><span class="line">+      &quot;insert 8 user8 person8@example.com&quot;,</span><br><span class="line">+      &quot;insert 9 user9 person9@example.com&quot;,</span><br><span class="line">+      &quot;insert 3 user3 person3@example.com&quot;,</span><br><span class="line">+      &quot;insert 12 user12 person12@example.com&quot;,</span><br><span class="line">+      &quot;insert 27 user27 person27@example.com&quot;,</span><br><span class="line">+      &quot;insert 17 user17 person17@example.com&quot;,</span><br><span class="line">+      &quot;insert 16 user16 person16@example.com&quot;,</span><br><span class="line">+      &quot;insert 13 user13 person13@example.com&quot;,</span><br><span class="line">+      &quot;insert 24 user24 person24@example.com&quot;,</span><br><span class="line">+      &quot;insert 25 user25 person25@example.com&quot;,</span><br><span class="line">+      &quot;insert 28 user28 person28@example.com&quot;,</span><br><span class="line">+      &quot;.btree&quot;,</span><br><span class="line">+      &quot;.exit&quot;,</span><br><span class="line">+    ]</span><br><span class="line">+    result = run_script(script)</span><br></pre></td></tr></table></figure>
<p>它应该会输出这个:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- internal (size 3)</span><br><span class="line">  - leaf (size 7)</span><br><span class="line">    - 1</span><br><span class="line">    - 2</span><br><span class="line">    - 3</span><br><span class="line">    - 4</span><br><span class="line">    - 5</span><br><span class="line">    - 6</span><br><span class="line">    - 7</span><br><span class="line">  - key 1</span><br><span class="line">  - leaf (size 8)</span><br><span class="line">    - 8</span><br><span class="line">    - 9</span><br><span class="line">    - 10</span><br><span class="line">    - 11</span><br><span class="line">    - 12</span><br><span class="line">    - 13</span><br><span class="line">    - 14</span><br><span class="line">    - 15</span><br><span class="line">  - key 15</span><br><span class="line">  - leaf (size 7)</span><br><span class="line">    - 16</span><br><span class="line">    - 17</span><br><span class="line">    - 18</span><br><span class="line">    - 19</span><br><span class="line">    - 20</span><br><span class="line">    - 21</span><br><span class="line">    - 22</span><br><span class="line">  - key 22</span><br><span class="line">  - leaf (size 8)</span><br><span class="line">    - 23</span><br><span class="line">    - 24</span><br><span class="line">    - 25</span><br><span class="line">    - 26</span><br><span class="line">    - 27</span><br><span class="line">    - 28</span><br><span class="line">    - 29</span><br><span class="line">    - 30</span><br><span class="line">db &gt;</span><br></pre></td></tr></table></figure>
<p>仔细观察你会发现一个bug:</p>
<p>这里的key应该是7,而不是1!</p>
<p>在经过一堆debug和i后,我发现错误原因是一些错误的指针运算.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="type">uint32_t</span>* <span class="title">internal_node_key</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> key_num)</span> </span>&#123;</span><br><span class="line">-  <span class="keyword">return</span> <span class="built_in">internal_node_cell</span>(node, key_num) + INTERNAL_NODE_CHILD_SIZE;</span><br><span class="line">+  <span class="keyword">return</span> (<span class="type">void</span>*)<span class="built_in">internal_node_cell</span>(node, key_num) + INTERNAL_NODE_CHILD_SIZE;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译者注: 如果你认真看的话,就应该知道我已经<a href="#fixBug1">改正</a>过这个错误了</p>
</blockquote>
<p><strong>INTERNAL_NODE_CHILD_SIZE</strong>的值为4.我的原意是令<code>internal_node_cell()</code>返回的指针地址加上4字节,但是因为<code>internal_node_cell()</code>返回的是一个<code>uint32_t*</code>指针,所以实际上加了<code>4*sizeof(uint32_t)</code>字节.在进行算数运算之前先把指针显式类型转换为<code>void*</code>类型，这样就能修复问题了.</p>
<p><strong>注意!</strong><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3523145/pointer-arithmetic-for-void-pointer-in-c/46238658#46238658">void指针的算数运算并不是C标准内容的一部分,所以可能在你的编译器上无效.</a>未来我也许会写一篇关于可移植性的文章,但是目前我会保留void指针运算.</p>
<p>好了.One more step toward a fully-operational btree implementation.下一步应该是分裂内部节点.</p>
<p>Until then!</p>
<p></br></p>
<p></br></p>
<p></br></p>
<blockquote>
<p>译者注: 原作者在2021.11.27更新了最后一章 - part 13.</p>
<p>然后彻底的鸽了(悲).本人本着人道主义精神,决定尽可能地狗尾续貂,至少得完成B树的完整架构.</p>
<p>当然,我也可能会鸽(毕竟我每天都做牛做马,如果实在没时间继续,我就鸽😤😤).</p>
</blockquote>
<p></br></p>
<h2 id="part-14---splitting-a-internal-node">Part 14 - Splitting a Internal Node</h2>
    </div>
  </div>
</article> 
  </div>
  
<link rel="stylesheet" href="/css/footer.css">


<div id="footer"></div>
 
</body>