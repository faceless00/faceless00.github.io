<!DOCTYPE html>
<html lang=" ">
<head>
  <meta charset="utf-8" />
<link rel="icon" href="/images/rev_sheep.png " />
<title>almostSalted</title>
<meta name="referrer" content="no-referrer" />
<meta name="google-site-verification" content="_CsSd0yrTQQrdEyoybq1kZNTZbIVulPo3zdQnaqAR0Y" />
  
<link rel="stylesheet" href="/css/layout.css">

<meta name="generator" content="Hexo 6.1.0"></head>
<body>
  
<link rel="stylesheet" href="/css/header.css">


<div class="topBar">
  <img class="icon" src="/images/rev_sheep.png " />
  <div class="menu">
     
    <a href="/ ">home</a>
     
    <a href="/archives ">archives</a>
     
    <a href="/categories ">categories</a>
     
    <a href="/aboutme ">aboutme</a>
     
    <a href="/diary ">diary</a>
    
  </div>
</div>
<div class="blank"></div>
  <div class="wrapper">
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div id="post">
  <aside id="navigator">
    <ol class="anchor"><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#Content"><span class="anchor-number">1.</span> <span class="anchor-text">Content</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part-8-B-Tree-leaf-Node-Format"><span class="anchor-number">1.1.</span> <span class="anchor-text">Part 8 - B-Tree leaf Node Format</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Alternative-Table-Formats"><span class="anchor-number">1.1.1.</span> <span class="anchor-text">Alternative Table Formats</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Leaf-Node-Format"><span class="anchor-number">1.1.2.</span> <span class="anchor-text">Leaf Node Format</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Accessing-Leaf-Node-Fields"><span class="anchor-number">1.1.3.</span> <span class="anchor-text">Accessing Leaf Node Fields</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Changes-to-Pager-and-Table-Objects"><span class="anchor-number">1.1.4.</span> <span class="anchor-text">Changes to Pager and Table Objects</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Changes-to-the-Cursor-Object"><span class="anchor-number">1.1.5.</span> <span class="anchor-text">Changes to the Cursor Object</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Insertion-Into-a-Leaf-Node"><span class="anchor-number">1.1.6.</span> <span class="anchor-text">Insertion Into a Leaf Node</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Command-to-Print-Constants"><span class="anchor-number">1.1.7.</span> <span class="anchor-text">Command to Print Constants</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Tree-Visualization"><span class="anchor-number">1.1.8.</span> <span class="anchor-text">Tree Visualization</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Next-Time"><span class="anchor-number">1.1.9.</span> <span class="anchor-text">Next Time</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Complete-Diff"><span class="anchor-number">1.1.10.</span> <span class="anchor-text">Complete Diff</span></a></li></ol></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part-9-Binary-Search-and-Duplicate-Keys"><span class="anchor-number">1.2.</span> <span class="anchor-text">Part 9 - Binary Search and Duplicate Keys</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part-10-Splitting-a-Leaf-Node"><span class="anchor-number">1.3.</span> <span class="anchor-text">Part 10 - Splitting a Leaf Node</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Splitting-Algorithm"><span class="anchor-number">1.3.1.</span> <span class="anchor-text">Splitting Algorithm</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Allocating-New-Pages"><span class="anchor-number">1.3.2.</span> <span class="anchor-text">Allocating New Pages</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Leaf-Node-Sizes"><span class="anchor-number">1.3.3.</span> <span class="anchor-text">Leaf Node Sizes</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Creating-a-New-Root"><span class="anchor-number">1.3.4.</span> <span class="anchor-text">Creating a New Root</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Internal-Node-Format"><span class="anchor-number">1.3.5.</span> <span class="anchor-text">Internal Node Format</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Keeping-Track-of-the-Root"><span class="anchor-number">1.3.6.</span> <span class="anchor-text">Keeping Track of the Root</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Printing-the-Tree"><span class="anchor-number">1.3.7.</span> <span class="anchor-text">Printing the Tree</span></a></li></ol></li></ol></li></ol>
  </aside>
  <div id="content">
    <div id="postHead">
      <h1>yourSql 2</h1>
      <div class="postDate">
        <img class="dateIcon" src="/images/clockicon.svg" />
        --2022.4.28
      </div>
        
        <div class="postCategory">
            <a href="/categories/translation/">translation</a>
        </div>
         
    </div>
    <div id="postBody">
      <h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><style>
    #table {
        margin: 0 auto;
        text-align: center;
        border: 1px solid grey;
        border-collapse: collapse;
        line-height: 1.6em;
    }
    #table th,#table td {
        border: 1px solid grey;
        padding: 0.5em;
    }
</style>

</br>

<h2 id="Part-8-B-Tree-leaf-Node-Format"><a href="#Part-8-B-Tree-leaf-Node-Format" class="headerlink" title="Part 8 - B-Tree leaf Node Format"></a>Part 8 - B-Tree leaf Node Format</h2><p>我们即将把 table 的结构从存储 row 的无序数组转变为 B-Tree,这是一个相当大的改变以至于需要好几章来实现.在本章的末尾，我们将会定义叶子节点的布局，以及支持向只有一个节点的树中插入键值对.</p>
<p>不过首先让我们回想一下为什么转换到树结构.</p>
<h3 id="Alternative-Table-Formats"><a href="#Alternative-Table-Formats" class="headerlink" title="Alternative Table Formats"></a>Alternative Table Formats</h3><p>基于目前的存储格式，每页只存储 row(没有元数据)因此空间利用效率很高.插入也很快因为我们只需要插入到末尾.但是寻找指定的 row 只能通过遍历整个 table 来完成,并且如果我们想要删除 row,我们需要将删除的 row 之后的所有行前移以填补空缺.</p>
<p>如果我们以数组的形式存储 table,但是 row 通过 id 排序,我们可以使用二分查找指定的 id.但是插入操作会非常耗时，因为我们要移动很多行以腾出空间.</p>
<p>因此，我们将使用 tree 结构.树中的每一個节点可以包含可变数量的行,所以我们需要在节点中存储一些信息以表示它包含了多少行.此外还有不存储任何行的内部节点的空间开销.作为数据库文件变大的交换，我们得到了快速插入，删除和查找.</p>
<table id="table">
<thead>
<tr>
<th></th>
<th>存储 row 的无序数组</th>
<th>存储 row 的有序数组</th>
<th>树的节点</th>
</tr>
</thead>
<tbody><tr>
<td>page 存储的数据</td>
<td>仅数据</td>
<td>仅数据</td>
<td>元数据，主键值和数据</td>
</tr>
<tr>
<td>每页的行数</td>
<td>more</td>
<td>more</td>
<td>fewer</td>
</tr>
<tr>
<td>插入</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>删除</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>通过 id 查找</td>
<td>O(n)</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
</tr>
</tbody></table>

<p>内部节点和叶子节点拥有不同的布局，让我们定义一个枚举变量表示节点的类型.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//+typedef enum &#123; NODE_INTERNAL, NODE_LEAF &#125; NodeType;</span></span><br><span class="line"><span class="comment">// 译者注: 因为下文要求type大小为1字节，所以制定了enum大小为uint8_t,否则默认为4个字节</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> : <span class="type">uint8_t</span></span><br><span class="line">&#123;</span><br><span class="line">    NODE_INTERNAL,</span><br><span class="line">    NODE_LEAF</span><br><span class="line">&#125; NodeType;</span><br></pre></td></tr></table></figure>

<p>每一个节点对应着一页.内部节点存储着指向子节点的指针，该指针实际上是存储着该子节点的页的 page number(译者注:即下标).btree 向 pager 请求指定的 page number,pager 返回指向该页缓存的指针.页根据 page number 有序存储在数据库文件中.</p>
<p>节点需要在页的头部存储一些元数据.每个节点会存储它的类型,是否为根节点，和一个指向父节点的指针(用来寻找兄弟节点).我定义了常量来表示头部的每个字段的大小和偏移量.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Common Node Header Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> NODE_TYPE_SIZE = <span class="built_in">sizeof</span>(NodeType);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> NODE_TYPE_OFFSET = <span class="number">0</span>;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> IS_ROOT_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> IS_ROOT_OFFSET = NODE_TYPE_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> PARENT_POINTER_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint8_t</span> COMMON_NODE_HEADER_SIZE =</span><br><span class="line">+    NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;</span><br></pre></td></tr></table></figure>

<h3 id="Leaf-Node-Format"><a href="#Leaf-Node-Format" class="headerlink" title="Leaf Node Format"></a>Leaf Node Format</h3><p>除了这些通用的头部字段外，叶子节点需要存储包含的”cell”的数量.一个”cell”就是一个键值对.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Leaf Node Header Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_NUM_CELLS_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_HEADER_SIZE =</span><br><span class="line">+    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;</span><br></pre></td></tr></table></figure>

<p>叶子节点的 body 是 cell 数组.每个 cell 是一个键后面跟着一个值(一个序列化的行).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Leaf Node Body Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_KEY_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_KEY_OFFSET = <span class="number">0</span>;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_VALUE_SIZE = ROW_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_VALUE_OFFSET =</span><br><span class="line">+    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_MAX_CELLS =</span><br><span class="line">+    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;</span><br></pre></td></tr></table></figure>

<p>基于这些常量,这里是叶子节点目前布局:</p>
<p>Our leaf node format</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/leaf-node-format.png"><img src="https://cstack.github.io/db_tutorial/assets/images/leaf-node-format.png" alt="Our leaf node format"></a></p>
<p>在头部使用一整个字节表示一个 bool 值有点浪费空间，但是这会让通过代码获取这些值更容易一点.</p>
<p>还要注意末尾有一些被浪费的空间.我们在头部之后存储尽可能多的 cell,但是剩余的空间不能存储一整个 cell.我们不使用这片空间以避免把 cell 分割到两个节点.</p>
<h3 id="Accessing-Leaf-Node-Fields"><a href="#Accessing-Leaf-Node-Fields" class="headerlink" title="Accessing Leaf Node Fields"></a>Accessing Leaf Node Fields</h3><p>获取键，值和元数据的函数都涉及到使用我们刚刚定义的常量进行指针算数运算.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">leaf_node_num_cells</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + LEAF_NODE_NUM_CELLS_OFFSET;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span>* <span class="title">leaf_node_cell</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + LEAF_NODE_HEADER_SIZE + cell_num * LEAF_NODE_CELL_SIZE;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">leaf_node_key</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_cell</span>(node, cell_num);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span>* <span class="title">leaf_node_value</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_cell</span>(node, cell_num) + LEAF_NODE_KEY_SIZE;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">initialize_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123; *<span class="built_in">leaf_node_num_cells</span>(node) = <span class="number">0</span>; &#125;</span><br><span class="line">+</span><br></pre></td></tr></table></figure>

<h3 id="Changes-to-Pager-and-Table-Objects"><a href="#Changes-to-Pager-and-Table-Objects" class="headerlink" title="Changes to Pager and Table Objects"></a>Changes to Pager and Table Objects</h3><p>每个节点将确切地占据一页，即使页没满.这意味着我们的 pager 不再需要支持 读&#x2F;写 未满的页了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-<span class="function"><span class="type">void</span> <span class="title">pager_flush</span><span class="params">(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size)</span> </span>&#123;</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">pager_flush</span><span class="params">(Pager* pager, <span class="type">uint32_t</span> page_num)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (pager-&gt;pages[page_num] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Tried to flush null page\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">@@ <span class="number">-242</span>,<span class="number">7</span> +<span class="number">337</span>,<span class="number">7</span> @@ <span class="function"><span class="type">void</span> <span class="title">pager_flush</span><span class="params">(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">ssize_t</span> bytes_written =</span><br><span class="line">-      <span class="built_in">write</span>(pager-&gt;file_descriptor, pager-&gt;pages[page_num], size);</span><br><span class="line">+      <span class="built_in">write</span>(pager-&gt;file_descriptor, pager-&gt;pages[page_num], PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Error writing: %d\n&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">db_close</span><span class="params">(Table* table)</span> </span>&#123;</span><br><span class="line">   Pager* pager = table-&gt;pager;</span><br><span class="line">-  <span class="type">uint32_t</span> num_full_pages = table-&gt;num_rows / ROWS_PER_PAGE;</span><br><span class="line"></span><br><span class="line">-  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_full_pages; i++) &#123;</span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; pager-&gt;num_pages; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (pager-&gt;pages[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">-    <span class="built_in">pager_flush</span>(pager, i, PAGE_SIZE);</span><br><span class="line">+    <span class="built_in">pager_flush</span>(pager, i);</span><br><span class="line">     <span class="built_in">free</span>(pager-&gt;pages[i]);</span><br><span class="line">     pager-&gt;pages[i] = <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">-  <span class="comment">// There may be a partial page to write to the end of the file</span></span><br><span class="line">-  <span class="comment">// This should not be needed after we switch to a B-tree</span></span><br><span class="line">-  <span class="type">uint32_t</span> num_additional_rows = table-&gt;num_rows % ROWS_PER_PAGE;</span><br><span class="line">-  <span class="keyword">if</span> (num_additional_rows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">-    <span class="type">uint32_t</span> page_num = num_full_pages;</span><br><span class="line">-    <span class="keyword">if</span> (pager-&gt;pages[page_num] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">-      <span class="built_in">pager_flush</span>(pager, page_num, num_additional_rows * ROW_SIZE);</span><br><span class="line">-      <span class="built_in">free</span>(pager-&gt;pages[page_num]);</span><br><span class="line">-      pager-&gt;pages[page_num] = <span class="literal">NULL</span>;</span><br><span class="line">-    &#125;</span><br><span class="line">-  &#125;</span><br><span class="line">-</span><br><span class="line">   <span class="type">int</span> result = <span class="built_in">close</span>(pager-&gt;file_descriptor);</span><br><span class="line">   <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Error closing db file.\n&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在更明智的做法是在数据库中存储 page 的个数而不是 row 的个数.page 的个数和 pager 对象关联，而不是 table,因为这是被数据库使用的 page 的个数，而不是指定的 table.一个 btree 被它的根节点对应的 page 下标标识，所以 table 对象需要保存该下标.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="type">const</span> <span class="type">uint32_t</span> PAGE_SIZE = <span class="number">4096</span>;</span><br><span class="line"> <span class="type">const</span> <span class="type">uint32_t</span> TABLE_MAX_PAGES = <span class="number">100</span>;</span><br><span class="line">-<span class="type">const</span> <span class="type">uint32_t</span> ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;</span><br><span class="line">-<span class="type">const</span> <span class="type">uint32_t</span> TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="type">int</span> file_descriptor;</span><br><span class="line">   <span class="type">uint32_t</span> file_length;</span><br><span class="line">+  <span class="type">uint32_t</span> num_pages;</span><br><span class="line">   <span class="type">void</span>* pages[TABLE_MAX_PAGES];</span><br><span class="line"> &#125; Pager;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   Pager* pager;</span><br><span class="line">-  <span class="type">uint32_t</span> num_rows;</span><br><span class="line">+  <span class="type">uint32_t</span> root_page_num;</span><br><span class="line"> &#125; Table;</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-127</span>,<span class="number">6</span> +<span class="number">200</span>,<span class="number">10</span> @@ <span class="function"><span class="type">void</span>* <span class="title">get_page</span><span class="params">(Pager* pager, <span class="type">uint32_t</span> page_num)</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     pager-&gt;pages[page_num] = page;</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">if</span> (page_num &gt;= pager-&gt;num_pages) &#123;</span><br><span class="line">+      pager-&gt;num_pages = page_num + <span class="number">1</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> pager-&gt;pages[page_num];</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-184</span>,<span class="number">6</span> +<span class="number">269</span>,<span class="number">12</span> @@ <span class="function">Pager* <span class="title">pager_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">   Pager* pager = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Pager));</span><br><span class="line">   pager-&gt;file_descriptor = fd;</span><br><span class="line">   pager-&gt;file_length = file_length;</span><br><span class="line">+  pager-&gt;num_pages = (file_length / PAGE_SIZE);</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (file_length % PAGE_SIZE != <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Db file is not a whole number of pages. Corrupt file.\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; TABLE_MAX_PAGES; i++) &#123;</span><br><span class="line">     pager-&gt;pages[i] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Changes-to-the-Cursor-Object"><a href="#Changes-to-the-Cursor-Object" class="headerlink" title="Changes to the Cursor Object"></a>Changes to the Cursor Object</h3><p>cursor 对象表示在 table 中的位置,当我们的 table 只是一个简单的元素为 row 的数组,我们只需要给定 row number 就可以访问该行.现在它是一棵树,我们通过 page number 和 cell 在节点中的 cell number 来标识一个位置.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   Table* table;</span><br><span class="line">-  <span class="type">uint32_t</span> row_num;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num;</span><br><span class="line">+  <span class="type">uint32_t</span> cell_num;</span><br><span class="line">   <span class="type">bool</span> end_of_table;  <span class="comment">// Indicates a position one past the last element</span></span><br><span class="line"> &#125; Cursor;</span><br><span class="line"></span><br><span class="line"> <span class="function">Cursor* <span class="title">table_start</span><span class="params">(Table* table)</span> </span>&#123;</span><br><span class="line">   Cursor* cursor = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Cursor));</span><br><span class="line">   cursor-&gt;table = table;</span><br><span class="line">-  cursor-&gt;row_num = <span class="number">0</span>;</span><br><span class="line">-  cursor-&gt;end_of_table = (table-&gt;num_rows == <span class="number">0</span>);</span><br><span class="line">+  cursor-&gt;page_num = table-&gt;root_page_num;</span><br><span class="line">+  cursor-&gt;cell_num = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(root_node);</span><br><span class="line">+  cursor-&gt;end_of_table = (num_cells == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cursor;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">Cursor* <span class="title">table_end</span><span class="params">(Table* table)</span> </span>&#123;</span><br><span class="line">   Cursor* cursor = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Cursor));</span><br><span class="line">   cursor-&gt;table = table;</span><br><span class="line">-  cursor-&gt;row_num = table-&gt;num_rows;</span><br><span class="line">+  cursor-&gt;page_num = table-&gt;root_page_num;</span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(root_node);</span><br><span class="line">+  cursor-&gt;cell_num = num_cells;</span><br><span class="line">   cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cursor;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span>* <span class="title">cursor_value</span><span class="params">(Cursor* cursor)</span> </span>&#123;</span><br><span class="line">-  <span class="type">uint32_t</span> row_num = cursor-&gt;row_num;</span><br><span class="line">-  <span class="type">uint32_t</span> page_num = row_num / ROWS_PER_PAGE;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num = cursor-&gt;page_num;</span><br><span class="line">   <span class="type">void</span>* page = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, page_num);</span><br><span class="line">-  <span class="type">uint32_t</span> row_offset = row_num % ROWS_PER_PAGE;</span><br><span class="line">-  <span class="type">uint32_t</span> byte_offset = row_offset * ROW_SIZE;</span><br><span class="line">-  <span class="keyword">return</span> page + byte_offset;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_value</span>(page, cursor-&gt;cell_num);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">cursor_advance</span><span class="params">(Cursor* cursor)</span> </span>&#123;</span><br><span class="line">-  cursor-&gt;row_num += <span class="number">1</span>;</span><br><span class="line">-  <span class="keyword">if</span> (cursor-&gt;row_num &gt;= cursor-&gt;table-&gt;num_rows) &#123;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num = cursor-&gt;page_num;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, page_num);</span><br><span class="line">+</span><br><span class="line">+  cursor-&gt;cell_num += <span class="number">1</span>;</span><br><span class="line">+  <span class="keyword">if</span> (cursor-&gt;cell_num &gt;= (*<span class="built_in">leaf_node_num_cells</span>(node))) &#123;</span><br><span class="line">     cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Insertion-Into-a-Leaf-Node"><a href="#Insertion-Into-a-Leaf-Node" class="headerlink" title="Insertion Into a Leaf Node"></a>Insertion Into a Leaf Node</h3><p>在本章我们会实现一个只有一个节点的树.回忆一下上一章的一开始只有一个空的叶子节点的树:</p>
<p>empty btree</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree1.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree1.png" alt="empty btree"></a></p>
<p>键值对可以一直放入，直到叶子节点被填满:</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree2.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree2.png" alt="one-node btree"></a></p>
<p>当我们第一次打开数据库，数据库文件是空的，所以我们初始化 page 0 为一个空的叶子节点(也是根节点):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function">Table* <span class="title">db_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">   Pager* pager = <span class="built_in">pager_open</span>(filename);</span><br><span class="line">-  <span class="type">uint32_t</span> num_rows = pager-&gt;file_length / ROW_SIZE;</span><br><span class="line"></span><br><span class="line">   Table* table = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Table));</span><br><span class="line">   table-&gt;pager = pager;</span><br><span class="line">-  table-&gt;num_rows = num_rows;</span><br><span class="line">+  table-&gt;root_page_num = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (pager-&gt;num_pages == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="comment">// New database file. Initialize page 0 as leaf node.</span></span><br><span class="line">+    <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(pager, <span class="number">0</span>);</span><br><span class="line">+    <span class="built_in">initialize_leaf_node</span>(root_node);</span><br><span class="line">+  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> table;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>然后我们会创建一个用来向叶子节点中插入键值对的函数,函数的参数 cursor 包含键值对应该被插入的位置.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">void</span> <span class="title">leaf_node_insert</span><span class="params">(Cursor* cursor, <span class="type">uint32_t</span> key, Row* value)</span> </span>&#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);</span><br><span class="line">+</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">+  <span class="keyword">if</span> (num_cells &gt;= LEAF_NODE_MAX_CELLS) &#123;</span><br><span class="line">+    <span class="comment">// Node full</span></span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Need to implement splitting a leaf node.\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (cursor-&gt;cell_num &lt; num_cells) &#123;</span><br><span class="line">+    <span class="comment">// Make room for new cell</span></span><br><span class="line">+    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = num_cells; i &gt; cursor-&gt;cell_num; i--) &#123;</span><br><span class="line">+      <span class="built_in">memcpy</span>(<span class="built_in">leaf_node_cell</span>(node, i), <span class="built_in">leaf_node_cell</span>(node, i - <span class="number">1</span>),</span><br><span class="line">+             LEAF_NODE_CELL_SIZE);</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  *(<span class="built_in">leaf_node_num_cells</span>(node)) += <span class="number">1</span>;</span><br><span class="line">+  *(<span class="built_in">leaf_node_key</span>(node, cursor-&gt;cell_num)) = key;</span><br><span class="line">+  <span class="built_in">serialize_row</span>(value, <span class="built_in">leaf_node_value</span>(node, cursor-&gt;cell_num));</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br></pre></td></tr></table></figure>

<p>我们现在还没有实现分裂操作,所以如果 node 容量满了会退出程序.然后将插入位置后面的 cell 右移一位以给新的 cell 腾出空间，然后我们向空的空间写入 key&amp;value.</p>
<p>既然我们假设树只有一个节点，<code>execute_insert()</code>函数只需要调用这个辅助函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function">ExecuteResult <span class="title">execute_insert</span><span class="params">(Statement* statement, Table* table)</span> </span>&#123;</span><br><span class="line">-  <span class="keyword">if</span> (table-&gt;num_rows &gt;= TABLE_MAX_ROWS) &#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="keyword">if</span> ((*<span class="built_in">leaf_node_num_cells</span>(node) &gt;= LEAF_NODE_MAX_CELLS)) &#123;</span><br><span class="line">     <span class="keyword">return</span> EXECUTE_TABLE_FULL;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);</span><br><span class="line">   Cursor* cursor = <span class="built_in">table_end</span>(table);</span><br><span class="line"></span><br><span class="line">-  <span class="built_in">serialize_row</span>(row_to_insert, <span class="built_in">cursor_value</span>(cursor));</span><br><span class="line">-  table-&gt;num_rows += <span class="number">1</span>;</span><br><span class="line">+  <span class="built_in">leaf_node_insert</span>(cursor, row_to_insert-&gt;id, row_to_insert);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(cursor);</span><br></pre></td></tr></table></figure>

<p>通过这些改动，我们的数据库就能和之前一样工作了!除了现在它会更早地返回”Table 已满”错误，因为我们还不能分裂根节点.</p>
<p>叶子节点可以保存多少行呢?</p>
<h3 id="Command-to-Print-Constants"><a href="#Command-to-Print-Constants" class="headerlink" title="Command to Print Constants"></a>Command to Print Constants</h3><p>我增加了一个新的元命令，用来打印一些有趣的常量.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">void</span> <span class="title">print_constants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;ROW_SIZE: %d\n&quot;</span>, ROW_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;COMMON_NODE_HEADER_SIZE: %d\n&quot;</span>, COMMON_NODE_HEADER_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_HEADER_SIZE: %d\n&quot;</span>, LEAF_NODE_HEADER_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_CELL_SIZE: %d\n&quot;</span>, LEAF_NODE_CELL_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_SPACE_FOR_CELLS: %d\n&quot;</span>, LEAF_NODE_SPACE_FOR_CELLS);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_MAX_CELLS: %d\n&quot;</span>, LEAF_NODE_MAX_CELLS);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">@@ <span class="number">-294</span>,<span class="number">6</span> +<span class="number">376</span>,<span class="number">14</span> @@ <span class="function">MetaCommandResult <span class="title">do_meta_command</span><span class="params">(InputBuffer* input_buffer, Table* table)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">db_close</span>(table);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">+  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.constants&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Constants:\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">print_constants</span>();</span><br><span class="line">+    <span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> META_COMMAND_UNRECOGNIZED_COMMAND;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>我还添加了一个测试，可以用来提醒我们这些变量改变了:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  it <span class="string">&#x27;prints constants&#x27;</span> <span class="keyword">do</span></span><br><span class="line">+    script = [</span><br><span class="line">+      <span class="string">&quot;.constants&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;.exit&quot;</span>,</span><br><span class="line">+    ]</span><br><span class="line">+    result = <span class="built_in">run_script</span>(script)</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">expect</span>(result).to <span class="built_in">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; Constants:&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;ROW_SIZE: 293&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;COMMON_NODE_HEADER_SIZE: 6&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_HEADER_SIZE: 10&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_CELL_SIZE: 297&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_SPACE_FOR_CELLS: 4086&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_MAX_CELLS: 13&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; &quot;</span>,</span><br><span class="line">+    ])</span><br><span class="line">+  end</span><br></pre></td></tr></table></figure>

<p>现在我们的 table 可以保存 13 行喔!</p>
<h3 id="Tree-Visualization"><a href="#Tree-Visualization" class="headerlink" title="Tree Visualization"></a>Tree Visualization</h3><p>为了便于调试和可视化,我还增加了一个元命令来打印出 btree 表现形式.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">void</span> <span class="title">print_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;leaf (size %d)\n&quot;</span>, num_cells);</span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_cells; i++) &#123;</span><br><span class="line">+    <span class="type">uint32_t</span> key = *<span class="built_in">leaf_node_key</span>(node, i);</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;  - %d : %d\n&quot;</span>, i, key);</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-294</span>,<span class="number">6</span> +<span class="number">376</span>,<span class="number">14</span> @@ <span class="function">MetaCommandResult <span class="title">do_meta_command</span><span class="params">(InputBuffer* input_buffer, Table* table)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">db_close</span>(table);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">+  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.btree&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Tree:\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">print_leaf_node</span>(<span class="built_in">get_page</span>(table-&gt;pager, <span class="number">0</span>));</span><br><span class="line">+    <span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.constants&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Constants:\n&quot;</span>);</span><br><span class="line">     <span class="built_in">print_constants</span>();</span><br><span class="line">     <span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> META_COMMAND_UNRECOGNIZED_COMMAND;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以及一个测试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  it <span class="string">&#x27;allows printing out the structure of a one-node btree&#x27;</span> <span class="keyword">do</span></span><br><span class="line">+    script = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>].map <span class="keyword">do</span> |i|</span><br><span class="line">+      <span class="string">&quot;insert #&#123;i&#125; user#&#123;i&#125; person#&#123;i&#125;@example.com&quot;</span></span><br><span class="line">+    end</span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;.btree&quot;</span></span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;.exit&quot;</span></span><br><span class="line">+    result = <span class="built_in">run_script</span>(script)</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">expect</span>(result).to <span class="built_in">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Tree:&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;leaf (size 3)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 0 : 3&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 1 : 1&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 2 : 2&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; &quot;</span></span><br><span class="line">+    ])</span><br><span class="line">+  end</span><br></pre></td></tr></table></figure>

<p>果咩，我们仍然没能有序地存储行.你可能注意到了<code>execute_insert()</code>函数在叶子节点的插入位置是由函数<code>table_end()</code>返回的.所以行是以插入的顺序排序的,就像之前一样.</p>
</br>

<h3 id="Next-Time"><a href="#Next-Time" class="headerlink" title="Next Time"></a>Next Time</h3><p>本章看起来像是倒退了一步.我们的数据库现在存储的行比之前少，并且我们存储的行仍然是无序的.但就像我在一开始说的，这是我们的一大步，并且将其分解成可管理的步骤很重要.</p>
<p>下一章，我们会实现根据 primary key(主键值)查找记录，然后有序地存储行.</p>
</br>

<h3 id="Complete-Diff"><a href="#Complete-Diff" class="headerlink" title="Complete Diff"></a>Complete Diff</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@@ <span class="number">-62</span>,<span class="number">29</span> +<span class="number">62</span>,<span class="number">101</span> @@ <span class="type">const</span> <span class="type">uint32_t</span> ROW_SIZE = ID_SIZE + USERNAME_SIZE + EMAIL_SIZE;</span><br><span class="line"></span><br><span class="line"> <span class="type">const</span> <span class="type">uint32_t</span> PAGE_SIZE = <span class="number">4096</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> TABLE_MAX_PAGES 100</span></span><br><span class="line">-<span class="type">const</span> <span class="type">uint32_t</span> ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;</span><br><span class="line">-<span class="type">const</span> <span class="type">uint32_t</span> TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="type">int</span> file_descriptor;</span><br><span class="line">   <span class="type">uint32_t</span> file_length;</span><br><span class="line">+  <span class="type">uint32_t</span> num_pages;</span><br><span class="line">   <span class="type">void</span>* pages[TABLE_MAX_PAGES];</span><br><span class="line"> &#125; Pager;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   Pager* pager;</span><br><span class="line">-  <span class="type">uint32_t</span> num_rows;</span><br><span class="line">+  <span class="type">uint32_t</span> root_page_num;</span><br><span class="line"> &#125; Table;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   Table* table;</span><br><span class="line">-  <span class="type">uint32_t</span> row_num;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num;</span><br><span class="line">+  <span class="type">uint32_t</span> cell_num;</span><br><span class="line">   <span class="type">bool</span> end_of_table;  <span class="comment">// Indicates a position one past the last element</span></span><br><span class="line"> &#125; Cursor;</span><br><span class="line"></span><br><span class="line">+<span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; NODE_INTERNAL, NODE_LEAF &#125; NodeType;</span><br><span class="line">+</span><br><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Common Node Header Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> NODE_TYPE_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> NODE_TYPE_OFFSET = <span class="number">0</span>;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> IS_ROOT_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> IS_ROOT_OFFSET = NODE_TYPE_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> PARENT_POINTER_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint8_t</span> COMMON_NODE_HEADER_SIZE =</span><br><span class="line">+    NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;</span><br><span class="line">+</span><br><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Leaf Node Header Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_NUM_CELLS_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_HEADER_SIZE =</span><br><span class="line">+    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;</span><br><span class="line">+</span><br><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Leaf Node Body Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_KEY_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_KEY_OFFSET = <span class="number">0</span>;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_VALUE_SIZE = ROW_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_VALUE_OFFSET =</span><br><span class="line">+    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_MAX_CELLS =</span><br><span class="line">+    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">leaf_node_num_cells</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + LEAF_NODE_NUM_CELLS_OFFSET;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span>* <span class="title">leaf_node_cell</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + LEAF_NODE_HEADER_SIZE + cell_num * LEAF_NODE_CELL_SIZE;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">leaf_node_key</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_cell</span>(node, cell_num);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span>* <span class="title">leaf_node_value</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_cell</span>(node, cell_num) + LEAF_NODE_KEY_SIZE;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">print_constants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;ROW_SIZE: %d\n&quot;</span>, ROW_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;COMMON_NODE_HEADER_SIZE: %d\n&quot;</span>, COMMON_NODE_HEADER_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_HEADER_SIZE: %d\n&quot;</span>, LEAF_NODE_HEADER_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_CELL_SIZE: %d\n&quot;</span>, LEAF_NODE_CELL_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_SPACE_FOR_CELLS: %d\n&quot;</span>, LEAF_NODE_SPACE_FOR_CELLS);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_MAX_CELLS: %d\n&quot;</span>, LEAF_NODE_MAX_CELLS);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">print_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;leaf (size %d)\n&quot;</span>, num_cells);</span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_cells; i++) &#123;</span><br><span class="line">+    <span class="type">uint32_t</span> key = *<span class="built_in">leaf_node_key</span>(node, i);</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;  - %d : %d\n&quot;</span>, i, key);</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">print_row</span><span class="params">(Row* row)</span> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;(%d, %s, %s)\n&quot;</span>, row-&gt;id, row-&gt;username, row-&gt;email);</span><br><span class="line"> &#125;</span><br><span class="line">@@ <span class="number">-101</span>,<span class="number">6</span> +<span class="number">173</span>,<span class="number">8</span> @@ <span class="function"><span class="type">void</span> <span class="title">deserialize_row</span><span class="params">(<span class="type">void</span> *source, Row* destination)</span> </span>&#123;</span><br><span class="line">     <span class="built_in">memcpy</span>(&amp;(destination-&gt;email), source + EMAIL_OFFSET, EMAIL_SIZE);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">initialize_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123; *<span class="built_in">leaf_node_num_cells</span>(node) = <span class="number">0</span>; &#125;</span><br><span class="line">+</span><br><span class="line"> <span class="function"><span class="type">void</span>* <span class="title">get_page</span><span class="params">(Pager* pager, <span class="type">uint32_t</span> page_num)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (page_num &gt; TABLE_MAX_PAGES) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Tried to fetch page number out of bounds. %d &gt; %d\n&quot;</span>, page_num,</span><br><span class="line">@@ <span class="number">-128</span>,<span class="number">6</span> +<span class="number">202</span>,<span class="number">10</span> @@ <span class="type">void</span>* <span class="built_in">get_page</span>(Pager* pager, <span class="type">uint32_t</span> page_num) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     pager-&gt;pages[page_num] = page;</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">if</span> (page_num &gt;= pager-&gt;num_pages) &#123;</span><br><span class="line">+      pager-&gt;num_pages = page_num + <span class="number">1</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> pager-&gt;pages[page_num];</span><br><span class="line">@@ <span class="number">-136</span>,<span class="number">8</span> +<span class="number">214</span>,<span class="number">12</span> @@ <span class="type">void</span>* <span class="built_in">get_page</span>(Pager* pager, <span class="type">uint32_t</span> page_num) &#123;</span><br><span class="line"> Cursor* <span class="built_in">table_start</span>(Table* table) &#123;</span><br><span class="line">   Cursor* cursor = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Cursor));</span><br><span class="line">   cursor-&gt;table = table;</span><br><span class="line">-  cursor-&gt;row_num = <span class="number">0</span>;</span><br><span class="line">-  cursor-&gt;end_of_table = (table-&gt;num_rows == <span class="number">0</span>);</span><br><span class="line">+  cursor-&gt;page_num = table-&gt;root_page_num;</span><br><span class="line">+  cursor-&gt;cell_num = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(root_node);</span><br><span class="line">+  cursor-&gt;end_of_table = (num_cells == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cursor;</span><br><span class="line"> &#125;</span><br><span class="line">@@ <span class="number">-145</span>,<span class="number">24</span> +<span class="number">227</span>,<span class="number">28</span> @@ Cursor* <span class="built_in">table_start</span>(Table* table) &#123;</span><br><span class="line"> Cursor* <span class="built_in">table_end</span>(Table* table) &#123;</span><br><span class="line">   Cursor* cursor = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Cursor));</span><br><span class="line">   cursor-&gt;table = table;</span><br><span class="line">-  cursor-&gt;row_num = table-&gt;num_rows;</span><br><span class="line">+  cursor-&gt;page_num = table-&gt;root_page_num;</span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(root_node);</span><br><span class="line">+  cursor-&gt;cell_num = num_cells;</span><br><span class="line">   cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cursor;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span>* <span class="built_in">cursor_value</span>(Cursor* cursor) &#123;</span><br><span class="line">-  <span class="type">uint32_t</span> row_num = cursor-&gt;row_num;</span><br><span class="line">-  <span class="type">uint32_t</span> page_num = row_num / ROWS_PER_PAGE;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num = cursor-&gt;page_num;</span><br><span class="line">   <span class="type">void</span>* page = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, page_num);</span><br><span class="line">-  <span class="type">uint32_t</span> row_offset = row_num % ROWS_PER_PAGE;</span><br><span class="line">-  <span class="type">uint32_t</span> byte_offset = row_offset * ROW_SIZE;</span><br><span class="line">-  <span class="keyword">return</span> page + byte_offset;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_value</span>(page, cursor-&gt;cell_num);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> <span class="built_in">cursor_advance</span>(Cursor* cursor) &#123;</span><br><span class="line">-  cursor-&gt;row_num += <span class="number">1</span>;</span><br><span class="line">-  <span class="keyword">if</span> (cursor-&gt;row_num &gt;= cursor-&gt;table-&gt;num_rows) &#123;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num = cursor-&gt;page_num;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, page_num);</span><br><span class="line">+</span><br><span class="line">+  cursor-&gt;cell_num += <span class="number">1</span>;</span><br><span class="line">+  <span class="keyword">if</span> (cursor-&gt;cell_num &gt;= (*<span class="built_in">leaf_node_num_cells</span>(node))) &#123;</span><br><span class="line">     cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">@@ <span class="number">-185</span>,<span class="number">6</span> +<span class="number">271</span>,<span class="number">12</span> @@ Pager* <span class="built_in">pager_open</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line">   Pager* pager = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Pager));</span><br><span class="line">   pager-&gt;file_descriptor = fd;</span><br><span class="line">   pager-&gt;file_length = file_length;</span><br><span class="line">+  pager-&gt;num_pages = (file_length / PAGE_SIZE);</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (file_length % PAGE_SIZE != <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Db file is not a whole number of pages. Corrupt file.\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; TABLE_MAX_PAGES; i++) &#123;</span><br><span class="line">     pager-&gt;pages[i] = <span class="literal">NULL</span>;</span><br><span class="line">@@ <span class="number">-194</span>,<span class="number">11</span> +<span class="number">285</span>,<span class="number">15</span> @@ Pager* <span class="built_in">pager_open</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line">@@ <span class="number">-195</span>,<span class="number">11</span> +<span class="number">287</span>,<span class="number">16</span> @@ Pager* <span class="built_in">pager_open</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line"></span><br><span class="line"> Table* <span class="built_in">db_open</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line">   Pager* pager = <span class="built_in">pager_open</span>(filename);</span><br><span class="line">-  <span class="type">uint32_t</span> num_rows = pager-&gt;file_length / ROW_SIZE;</span><br><span class="line"></span><br><span class="line">   Table* table = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Table));</span><br><span class="line">   table-&gt;pager = pager;</span><br><span class="line">-  table-&gt;num_rows = num_rows;</span><br><span class="line">+  table-&gt;root_page_num = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (pager-&gt;num_pages == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="comment">// New database file. Initialize page 0 as leaf node.</span></span><br><span class="line">+    <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(pager, <span class="number">0</span>);</span><br><span class="line">+    <span class="built_in">initialize_leaf_node</span>(root_node);</span><br><span class="line">+  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> table;</span><br><span class="line"> &#125;</span><br><span class="line">@@ <span class="number">-234</span>,<span class="number">7</span> +<span class="number">331</span>,<span class="number">7</span> @@ <span class="type">void</span> <span class="built_in">close_input_buffer</span>(InputBuffer* input_buffer) &#123;</span><br><span class="line">     <span class="built_in">free</span>(input_buffer);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">-<span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size) &#123;</span><br><span class="line">+<span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num) &#123;</span><br><span class="line">   <span class="keyword">if</span> (pager-&gt;pages[page_num] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Tried to flush null page\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">@@ <span class="number">-242</span>,<span class="number">7</span> +<span class="number">337</span>,<span class="number">7</span> @@ <span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size) &#123;</span><br><span class="line">@@ <span class="number">-249</span>,<span class="number">7</span> +<span class="number">346</span>,<span class="number">7</span> @@ <span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size) &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">ssize_t</span> bytes_written =</span><br><span class="line">-      <span class="built_in">write</span>(pager-&gt;file_descriptor, pager-&gt;pages[page_num], size);</span><br><span class="line">+      <span class="built_in">write</span>(pager-&gt;file_descriptor, pager-&gt;pages[page_num], PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Error writing: %d\n&quot;</span>, errno);</span><br><span class="line">@@ <span class="number">-252</span>,<span class="number">29</span> +<span class="number">347</span>,<span class="number">16</span> @@ <span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size) &#123;</span><br><span class="line">@@ <span class="number">-260</span>,<span class="number">29</span> +<span class="number">357</span>,<span class="number">16</span> @@ <span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> <span class="built_in">db_close</span>(Table* table) &#123;</span><br><span class="line">   Pager* pager = table-&gt;pager;</span><br><span class="line">-  <span class="type">uint32_t</span> num_full_pages = table-&gt;num_rows / ROWS_PER_PAGE;</span><br><span class="line"></span><br><span class="line">-  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_full_pages; i++) &#123;</span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; pager-&gt;num_pages; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (pager-&gt;pages[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">-    <span class="built_in">pager_flush</span>(pager, i, PAGE_SIZE);</span><br><span class="line">+    <span class="built_in">pager_flush</span>(pager, i);</span><br><span class="line">     <span class="built_in">free</span>(pager-&gt;pages[i]);</span><br><span class="line">     pager-&gt;pages[i] = <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">-  <span class="comment">// There may be a partial page to write to the end of the file</span></span><br><span class="line">-  <span class="comment">// This should not be needed after we switch to a B-tree</span></span><br><span class="line">-  <span class="type">uint32_t</span> num_additional_rows = table-&gt;num_rows % ROWS_PER_PAGE;</span><br><span class="line">-  <span class="keyword">if</span> (num_additional_rows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">-    <span class="type">uint32_t</span> page_num = num_full_pages;</span><br><span class="line">-    <span class="keyword">if</span> (pager-&gt;pages[page_num] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">-      <span class="built_in">pager_flush</span>(pager, page_num, num_additional_rows * ROW_SIZE);</span><br><span class="line">-      <span class="built_in">free</span>(pager-&gt;pages[page_num]);</span><br><span class="line">-      pager-&gt;pages[page_num] = <span class="literal">NULL</span>;</span><br><span class="line">-    &#125;</span><br><span class="line">-  &#125;</span><br><span class="line">-</span><br><span class="line">   <span class="type">int</span> result = <span class="built_in">close</span>(pager-&gt;file_descriptor);</span><br><span class="line">   <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Error closing db file.\n&quot;</span>);</span><br><span class="line">@@ <span class="number">-305</span>,<span class="number">6</span> +<span class="number">389</span>,<span class="number">14</span> @@ MetaCommandResult <span class="built_in">do_meta_command</span>(InputBuffer* input_buffer, Table *table) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">db_close</span>(table);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">+  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.btree&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Tree:\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">print_leaf_node</span>(<span class="built_in">get_page</span>(table-&gt;pager, <span class="number">0</span>));</span><br><span class="line">+    <span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br><span class="line">+  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.constants&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Constants:\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">print_constants</span>();</span><br><span class="line">+    <span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> META_COMMAND_UNRECOGNIZED_COMMAND;</span><br><span class="line">   &#125;</span><br><span class="line">@@ <span class="number">-354</span>,<span class="number">16</span> +<span class="number">446</span>,<span class="number">39</span> @@ PrepareResult <span class="built_in">prepare_statement</span>(InputBuffer* input_buffer,</span><br><span class="line">   <span class="keyword">return</span> PREPARE_UNRECOGNIZED_STATEMENT;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">+<span class="type">void</span> <span class="built_in">leaf_node_insert</span>(Cursor* cursor, <span class="type">uint32_t</span> key, Row* value) &#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);</span><br><span class="line">+</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">+  <span class="keyword">if</span> (num_cells &gt;= LEAF_NODE_MAX_CELLS) &#123;</span><br><span class="line">+    <span class="comment">// Node full</span></span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Need to implement splitting a leaf node.\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (cursor-&gt;cell_num &lt; num_cells) &#123;</span><br><span class="line">+    <span class="comment">// Make room for new cell</span></span><br><span class="line">+    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = num_cells; i &gt; cursor-&gt;cell_num; i--) &#123;</span><br><span class="line">+      <span class="built_in">memcpy</span>(<span class="built_in">leaf_node_cell</span>(node, i), <span class="built_in">leaf_node_cell</span>(node, i - <span class="number">1</span>),</span><br><span class="line">+             LEAF_NODE_CELL_SIZE);</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  *(<span class="built_in">leaf_node_num_cells</span>(node)) += <span class="number">1</span>;</span><br><span class="line">+  *(<span class="built_in">leaf_node_key</span>(node, cursor-&gt;cell_num)) = key;</span><br><span class="line">+  <span class="built_in">serialize_row</span>(value, <span class="built_in">leaf_node_value</span>(node, cursor-&gt;cell_num));</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> ExecuteResult <span class="built_in">execute_insert</span>(Statement* statement, Table* table) &#123;</span><br><span class="line">-  <span class="keyword">if</span> (table-&gt;num_rows &gt;= TABLE_MAX_ROWS) &#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="keyword">if</span> ((*<span class="built_in">leaf_node_num_cells</span>(node) &gt;= LEAF_NODE_MAX_CELLS)) &#123;</span><br><span class="line">     <span class="keyword">return</span> EXECUTE_TABLE_FULL;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);</span><br><span class="line">   Cursor* cursor = <span class="built_in">table_end</span>(table);</span><br><span class="line"></span><br><span class="line">-  <span class="built_in">serialize_row</span>(row_to_insert, <span class="built_in">cursor_value</span>(cursor));</span><br><span class="line">-  table-&gt;num_rows += <span class="number">1</span>;</span><br><span class="line">+  <span class="built_in">leaf_node_insert</span>(cursor, row_to_insert-&gt;id, row_to_insert);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(cursor);</span><br><span class="line"></span><br><span class="line">And the specs:</span><br><span class="line"></span><br><span class="line">+  it <span class="string">&#x27;allows printing out the structure of a one-node btree&#x27;</span> <span class="keyword">do</span></span><br><span class="line">+    script = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>].map <span class="keyword">do</span> |i|</span><br><span class="line">+      <span class="string">&quot;insert #&#123;i&#125; user#&#123;i&#125; person#&#123;i&#125;@example.com&quot;</span></span><br><span class="line">+    end</span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;.btree&quot;</span></span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;.exit&quot;</span></span><br><span class="line">+    result = <span class="built_in">run_script</span>(script)</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">expect</span>(result).to <span class="built_in">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Tree:&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;leaf (size 3)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 0 : 3&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 1 : 1&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 2 : 2&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; &quot;</span></span><br><span class="line">+    ])</span><br><span class="line">+  end</span><br><span class="line">+</span><br><span class="line">+  it <span class="string">&#x27;prints constants&#x27;</span> <span class="keyword">do</span></span><br><span class="line">+    script = [</span><br><span class="line">+      <span class="string">&quot;.constants&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;.exit&quot;</span>,</span><br><span class="line">+    ]</span><br><span class="line">+    result = <span class="built_in">run_script</span>(script)</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">expect</span>(result).to <span class="built_in">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; Constants:&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;ROW_SIZE: 293&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;COMMON_NODE_HEADER_SIZE: 6&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_HEADER_SIZE: 10&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_CELL_SIZE: 297&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_SPACE_FOR_CELLS: 4086&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_MAX_CELLS: 13&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; &quot;</span>,</span><br><span class="line">+    ])</span><br><span class="line">+  end</span><br><span class="line"> end</span><br></pre></td></tr></table></figure>



<h2 id="Part-9-Binary-Search-and-Duplicate-Keys"><a href="#Part-9-Binary-Search-and-Duplicate-Keys" class="headerlink" title="Part 9 - Binary Search and Duplicate Keys"></a>Part 9 - Binary Search and Duplicate Keys</h2><p>在上一章注意到我们仍然存储键的方式仍然是无序的.我们将要修复这个问题，外加检测和拒绝重复的键.</p>
<p>目前，函数<code>execute_insert()</code>总是选择在表的末尾插入，但我们应该在表中搜索合适的插入位置，然后插到那里.如果键值已存在，返回一个错误.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ExecuteResult <span class="title">execute_insert</span><span class="params">(Statement* statement, Table* table)</span> </span>&#123;</span><br><span class="line">   <span class="type">void</span>* node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">-  <span class="keyword">if</span> ((*<span class="built_in">leaf_node_num_cells</span>(node) &gt;= LEAF_NODE_MAX_CELLS)) &#123;</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = (*<span class="built_in">leaf_node_num_cells</span>(node));</span><br><span class="line">+  <span class="keyword">if</span> (num_cells &gt;= LEAF_NODE_MAX_CELLS) &#123;</span><br><span class="line">     <span class="keyword">return</span> EXECUTE_TABLE_FULL;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);</span><br><span class="line">-  Cursor* cursor = <span class="built_in">table_end</span>(table);</span><br><span class="line">+  <span class="type">uint32_t</span> key_to_insert = row_to_insert-&gt;id;</span><br><span class="line">+  Cursor* cursor = <span class="built_in">table_find</span>(table, key_to_insert);</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (cursor-&gt;cell_num &lt; num_cells) &#123;</span><br><span class="line">+    <span class="type">uint32_t</span> key_at_index = *<span class="built_in">leaf_node_key</span>(node, cursor-&gt;cell_num);</span><br><span class="line">+    <span class="keyword">if</span> (key_at_index == key_to_insert) &#123;</span><br><span class="line">+      <span class="keyword">return</span> EXECUTE_DUPLICATE_KEY;</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">leaf_node_insert</span>(cursor, row_to_insert-&gt;id, row_to_insert);</span><br></pre></td></tr></table></figure>

<p>我们不再需要函数<code>table_end()</code>了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-<span class="function">Cursor* <span class="title">table_end</span><span class="params">(Table* table)</span> </span>&#123;</span><br><span class="line">-  Cursor* cursor = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Cursor));</span><br><span class="line">-  cursor-&gt;table = table;</span><br><span class="line">-  cursor-&gt;page_num = table-&gt;root_page_num;</span><br><span class="line">-</span><br><span class="line">-  <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">-  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(root_node);</span><br><span class="line">-  cursor-&gt;cell_num = num_cells;</span><br><span class="line">-  cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line">-</span><br><span class="line">-  <span class="keyword">return</span> cursor;</span><br><span class="line">-&#125;</span><br></pre></td></tr></table></figure>

<p>我们用一个新函数代替它，该函数可以在树中搜索一个给定的key.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+Return the position of the given key.</span></span><br><span class="line"><span class="comment">+If the key is not present, return the position</span></span><br><span class="line"><span class="comment">+where it should be inserted</span></span><br><span class="line"><span class="comment">+*/</span></span><br><span class="line">+<span class="function">Cursor* <span class="title">table_find</span><span class="params">(Table* table, <span class="type">uint32_t</span> key)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint32_t</span> root_page_num = table-&gt;root_page_num;</span><br><span class="line">+  <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(table-&gt;pager, root_page_num);</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (<span class="built_in">get_node_type</span>(root_node) == NODE_LEAF) &#123;</span><br><span class="line">+    <span class="keyword">return</span> <span class="built_in">leaf_node_find</span>(table, root_page_num, key);</span><br><span class="line">+  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Need to implement searching an internal node\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<p>我预留了处理内部节点的分支，尽管我们还没有实现内部节点.不过我们现在可以用二分查找搜索叶子节点.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function">Cursor* <span class="title">leaf_node_find</span><span class="params">(Table* table, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> key)</span> </span>&#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(table-&gt;pager, page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">+</span><br><span class="line">+  Cursor* cursor = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Cursor));</span><br><span class="line">+  cursor-&gt;table = table;</span><br><span class="line">+  cursor-&gt;page_num = page_num;</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">// Binary search</span></span><br><span class="line">+  <span class="type">uint32_t</span> min_index = <span class="number">0</span>;</span><br><span class="line">+  <span class="type">uint32_t</span> one_past_max_index = num_cells;</span><br><span class="line">+  <span class="keyword">while</span> (one_past_max_index != min_index) &#123;</span><br><span class="line">+    <span class="type">uint32_t</span> index = (min_index + one_past_max_index) / <span class="number">2</span>;</span><br><span class="line">+    <span class="type">uint32_t</span> key_at_index = *<span class="built_in">leaf_node_key</span>(node, index);</span><br><span class="line">+    <span class="keyword">if</span> (key == key_at_index) &#123;</span><br><span class="line">+      cursor-&gt;cell_num = index;</span><br><span class="line">+      <span class="keyword">return</span> cursor;</span><br><span class="line">+    &#125;</span><br><span class="line">+    <span class="keyword">if</span> (key &lt; key_at_index) &#123;</span><br><span class="line">+      one_past_max_index = index;</span><br><span class="line">+    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+      min_index = index + <span class="number">1</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  cursor-&gt;cell_num = min_index;</span><br><span class="line">+  <span class="keyword">return</span> cursor;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的返回值为:</p>
<ul>
<li>键对应的位置</li>
<li>另一个键的位置，如果我们想要插入新的键的话，就需要移动它，或者</li>
<li>最后一个键的后一个位置</li>
</ul>
<p>因为我们现在需要检查节点类型，所以需要一个函数去获得和设置类型值.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function">NodeType <span class="title">get_node_type</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint8_t</span> value = *((<span class="type">uint8_t</span>*)(node + NODE_TYPE_OFFSET));</span><br><span class="line">+  <span class="keyword">return</span> (NodeType)value;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">set_node_type</span><span class="params">(<span class="type">void</span>* node, NodeType type)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint8_t</span> value = type;</span><br><span class="line">+  *((<span class="type">uint8_t</span>*)(node + NODE_TYPE_OFFSET)) = value;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要先转换到<code>unt8_t</code>类型以确保其被序列化为一个字节.</p>
<p>我们还需要初始化节点类型.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-<span class="function"><span class="type">void</span> <span class="title">initialize_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123; *<span class="built_in">leaf_node_num_cells</span>(node) = <span class="number">0</span>; &#125;</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">initialize_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="built_in">set_node_type</span>(node, NODE_LEAF);</span><br><span class="line">+  *<span class="built_in">leaf_node_num_cells</span>(node) = <span class="number">0</span>;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们需要创建和处理一个新的错误码.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-<span class="keyword">enum</span> <span class="title class_">ExecuteResult_t</span> &#123; EXECUTE_SUCCESS, EXECUTE_TABLE_FULL &#125;;</span><br><span class="line">+<span class="keyword">enum</span> <span class="title class_">ExecuteResult_t</span> &#123;</span><br><span class="line">+  EXECUTE_SUCCESS,</span><br><span class="line">+  EXECUTE_DUPLICATE_KEY,</span><br><span class="line">+  EXECUTE_TABLE_FULL</span><br><span class="line">+&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">case</span> (EXECUTE_SUCCESS):</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Executed.\n&quot;</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">+      <span class="built_in">case</span> (EXECUTE_DUPLICATE_KEY):</span><br><span class="line">+        <span class="built_in">printf</span>(<span class="string">&quot;Error: Duplicate key.\n&quot;</span>);</span><br><span class="line">+        <span class="keyword">break</span>;</span><br><span class="line">       <span class="built_in">case</span> (EXECUTE_TABLE_FULL):</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Error: Table full.\n&quot;</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>通过这些改动，我们的测试可以改为检查顺序.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">       <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">       <span class="string">&quot;db &gt; Tree:&quot;</span>,</span><br><span class="line">       <span class="string">&quot;leaf (size 3)&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;  - 0 : 3&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;  - 1 : 1&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;  - 2 : 2&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 0 : 1&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 1 : 2&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 2 : 3&quot;</span>,</span><br><span class="line">       <span class="string">&quot;db &gt; &quot;</span></span><br><span class="line">     ])</span><br><span class="line">   end</span><br></pre></td></tr></table></figure>

<p>然后我们可以新增一个检查重复键的测试:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  it <span class="string">&#x27;prints an error message if there is a duplicate id&#x27;</span> <span class="keyword">do</span></span><br><span class="line">+    script = [</span><br><span class="line">+      <span class="string">&quot;insert 1 user1 person1@example.com&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;insert 1 user1 person1@example.com&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;select&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;.exit&quot;</span>,</span><br><span class="line">+    ]</span><br><span class="line">+    result = <span class="built_in">run_script</span>(script)</span><br><span class="line">+    <span class="built_in">expect</span>(result).to <span class="built_in">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Error: Duplicate key.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; (1, user1, person1@example.com)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; &quot;</span>,</span><br><span class="line">+    ])</span><br><span class="line">+  end</span><br></pre></td></tr></table></figure>

<p>好辣!在下一章我们将会 - 实施分裂叶子节点并且创建内部节点.</p>
</br>

<h2 id="Part-10-Splitting-a-Leaf-Node"><a href="#Part-10-Splitting-a-Leaf-Node" class="headerlink" title="Part 10 - Splitting a Leaf Node"></a>Part 10 - Splitting a Leaf Node</h2><p>我们的B-Tree不太像一个树，因为只有一个节点.为了修复这个问题，我们需要一些代码来将一个叶子节点分裂成双胞胎.在这之后,我们需要创建一个内部节点作为两个叶子节点的父节点.</p>
<p>本章目标基本上是从这样:</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree2.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree2.png" alt="one-node btree"></a></p>
<p>到这样:</p>
<p>two-level btree</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree3.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree3.png" alt="two-level btree"></a></p>
<p>首先让我们移除叶子节点已满的错误处理:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">leaf_node_insert</span><span class="params">(Cursor* cursor, <span class="type">uint32_t</span> key, Row* value)</span> </span>&#123;</span><br><span class="line">   <span class="type">void</span>* node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);</span><br><span class="line"> </span><br><span class="line">   <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">   <span class="keyword">if</span> (num_cells &gt;= LEAF_NODE_MAX_CELLS) &#123;</span><br><span class="line">     <span class="comment">// Node full</span></span><br><span class="line">-    <span class="built_in">printf</span>(<span class="string">&quot;Need to implement splitting a leaf node.\n&quot;</span>);</span><br><span class="line">-    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+    <span class="built_in">leaf_node_split_and_insert</span>(cursor, key, value);</span><br><span class="line">+    <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ExecuteResult <span class="title">execute_insert</span><span class="params">(Statement* statement, Table* table)</span> </span>&#123;</span><br><span class="line">   <span class="type">void</span>* node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">   <span class="type">uint32_t</span> num_cells = (*<span class="built_in">leaf_node_num_cells</span>(node));</span><br><span class="line">-  <span class="keyword">if</span> (num_cells &gt;= LEAF_NODE_MAX_CELLS) &#123;</span><br><span class="line">-    <span class="keyword">return</span> EXECUTE_TABLE_FULL;</span><br><span class="line">-  &#125;</span><br><span class="line"> </span><br><span class="line">   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);</span><br><span class="line">   <span class="type">uint32_t</span> key_to_insert = row_to_insert-&gt;id;</span><br></pre></td></tr></table></figure>

<h3 id="Splitting-Algorithm"><a href="#Splitting-Algorithm" class="headerlink" title="Splitting Algorithm"></a>Splitting Algorithm</h3><p>简单的部分结束了,<a target="_blank" rel="noopener" href="https://play.google.com/store/books/details/Sibsankar_Haldar_SQLite_Database_System_Design_and?id=9Z6IQQnX1JEC&amp;hl=en">SQLite Database System: Design and Implementation</a>里面描述了我们接下来要做的事情</p>
<blockquote>
<p>如果叶子节点没有剩余空间了，我们应该将叶子节点已有的记录和新的记录(待插入的那个)分成两个等长的部分:下半部分和上半部分(上半部分的所有键都严格大于下半部分的键.)然后创建一个新的叶子节点，然后上半部分移动到叶子节点里.</p>
</blockquote>
<p>让我们来处理旧的节点然后创建一个新的节点.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">void</span> <span class="title">leaf_node_split_and_insert</span><span class="params">(Cursor* cursor, <span class="type">uint32_t</span> key, Row* value)</span> </span>&#123;</span><br><span class="line">+  <span class="comment">/*</span></span><br><span class="line"><span class="comment">+  Create a new node and move half the cells over.</span></span><br><span class="line"><span class="comment">+  Insert the new value in one of the two nodes.</span></span><br><span class="line"><span class="comment">+  Update parent or create a new parent.</span></span><br><span class="line"><span class="comment">+  */</span></span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* old_node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> new_page_num = <span class="built_in">get_unused_page_num</span>(cursor-&gt;table-&gt;pager);</span><br><span class="line">+  <span class="type">void</span>* new_node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, new_page_num);</span><br><span class="line">+  <span class="built_in">initialize_leaf_node</span>(new_node);</span><br></pre></td></tr></table></figure>

<p>然后，拷贝每个cell到新的位置:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  <span class="comment">/*</span></span><br><span class="line"><span class="comment">+  All existing keys plus new key should be divided</span></span><br><span class="line"><span class="comment">+  evenly between old (left) and new (right) nodes.</span></span><br><span class="line"><span class="comment">+  Starting from the right, move each key to correct position.</span></span><br><span class="line"><span class="comment">+  */</span></span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">int32_t</span> i = LEAF_NODE_MAX_CELLS; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">+    <span class="type">void</span>* destination_node;</span><br><span class="line">+    <span class="keyword">if</span> (i &gt;= LEAF_NODE_LEFT_SPLIT_COUNT) &#123;</span><br><span class="line">+      destination_node = new_node;</span><br><span class="line">+    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+      destination_node = old_node;</span><br><span class="line">+    &#125;</span><br><span class="line">+    <span class="type">uint32_t</span> index_within_node = i % LEAF_NODE_LEFT_SPLIT_COUNT;</span><br><span class="line">+    <span class="type">void</span>* destination = <span class="built_in">leaf_node_cell</span>(destination_node, index_within_node);</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">if</span> (i == cursor-&gt;cell_num) &#123;</span><br><span class="line">+      <span class="built_in">serialize_row</span>(value, destination);</span><br><span class="line">+    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; cursor-&gt;cell_num) &#123;</span><br><span class="line">+      <span class="built_in">memcpy</span>(destination, <span class="built_in">leaf_node_cell</span>(old_node, i - <span class="number">1</span>), LEAF_NODE_CELL_SIZE);</span><br><span class="line">+    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+      <span class="built_in">memcpy</span>(destination, <span class="built_in">leaf_node_cell</span>(old_node, i), LEAF_NODE_CELL_SIZE);</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br></pre></td></tr></table></figure>

<p>然后我们需要更新两个叶子节点的父节点.如果原节点(即被分裂的叶子节点)是根节点,也就是没有父节点.在这种情况下，创建一个新的根节点作为父节点,目前我们暂时不实现更新父节点的操作:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  <span class="keyword">if</span> (<span class="built_in">is_node_root</span>(old_node)) &#123;</span><br><span class="line">+    <span class="keyword">return</span> <span class="built_in">create_new_root</span>(cursor-&gt;table, new_page_num);</span><br><span class="line">+  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Need to implement updating parent after split\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Allocating-New-Pages"><a href="#Allocating-New-Pages" class="headerlink" title="Allocating New Pages"></a>Allocating New Pages</h3><p>让我们回去定义一些新的函数和常量.当我们创建一个新的叶子节点时，我们把它放进由函数<code>get_ununsed_page_num()</code>指定的页中:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+Until we start recycling free pages, new pages will always</span></span><br><span class="line"><span class="comment">+go onto the end of the database file</span></span><br><span class="line"><span class="comment">+*/</span></span><br><span class="line">+<span class="function"><span class="type">uint32_t</span> <span class="title">get_unused_page_num</span><span class="params">(Pager* pager)</span> </span>&#123; <span class="keyword">return</span> pager-&gt;num_pages; &#125;</span><br></pre></td></tr></table></figure>

<p>目前，我们假设数据库有N页，page下标从0到N-1已被分配.所以我们可以分配下标N给新的页.最终在我们执行了删除操作之后，一些页可能是空的并且它们的页下标未被使用，为了提高效率，我们可以重新分配那些空的页.</p>
<h3 id="Leaf-Node-Sizes"><a href="#Leaf-Node-Sizes" class="headerlink" title="Leaf Node Sizes"></a>Leaf Node Sizes</h3><p>为了保持树的平衡，我们将cells平均分配到两个新的节点中.如果一个叶子节点可以保存N个cell,那么在分裂中我们需要分配N+1个cell到两个节点中(N个原cell外加一个待插入的新cell).我决定给<strong>左边</strong>的节点<strong>多分配一个cell</strong>,如果N+1是奇数的话.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_RIGHT_SPLIT_COUNT = (LEAF_NODE_MAX_CELLS + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_LEFT_SPLIT_COUNT =</span><br><span class="line">+    (LEAF_NODE_MAX_CELLS + <span class="number">1</span>) - LEAF_NODE_RIGHT_SPLIT_COUNT;</span><br></pre></td></tr></table></figure>

<h3 id="Creating-a-New-Root"><a href="#Creating-a-New-Root" class="headerlink" title="Creating a New Root"></a>Creating a New Root</h3><p>这里<a target="_blank" rel="noopener" href="https://play.google.com/store/books/details/Sibsankar_Haldar_SQLite_Database_System_Design_and?id=9Z6IQQnX1JEC&amp;hl=en">SQLite Database System</a>阐释了创建一个新的根节点的过程:</p>
<blockquote>
<p>让<code>N</code>变为根节点.首先分配两个节点，叫做<code>L</code>和<code>R</code>.移动N的下半部分元素到L,上半部分元素到R.然后现在N就是空的了.</p>
<p>在N中增加<code>&lt;L,K,R&gt;</code>，<code>K</code>是<code>L</code>中最大的键.第N页也仍然是根节点.注意树的深度增加了1,但是新的树在不违背任何B+tree属性的情况下保持了高度平衡.</p>
</blockquote>
<p>目前，我们已经创建了右孩子并且把上半部分元素移入其中.我们的函数将右孩子作为参数，然后分配一个新的页来存储左孩子.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">void</span> <span class="title">create_new_root</span><span class="params">(Table* table, <span class="type">uint32_t</span> right_child_page_num)</span> </span>&#123;</span><br><span class="line">+  <span class="comment">/*</span></span><br><span class="line"><span class="comment">+  Handle splitting the root.</span></span><br><span class="line"><span class="comment">+  Old root copied to new page, becomes left child.</span></span><br><span class="line"><span class="comment">+  Address of right child passed in.</span></span><br><span class="line"><span class="comment">+  Re-initialize root page to contain the new root node.</span></span><br><span class="line"><span class="comment">+  New root node points to two children.</span></span><br><span class="line"><span class="comment">+  */</span></span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* root = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="type">void</span>* right_child = <span class="built_in">get_page</span>(table-&gt;pager, right_child_page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> left_child_page_num = <span class="built_in">get_unused_page_num</span>(table-&gt;pager);</span><br><span class="line">+  <span class="type">void</span>* left_child = <span class="built_in">get_page</span>(table-&gt;pager, left_child_page_num);</span><br></pre></td></tr></table></figure>

<p>原根节点的数据被拷贝进了左孩子,然后我们就能重新使用该页作为根节点了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  <span class="comment">/* Left child has data copied from old root */</span></span><br><span class="line">+  <span class="built_in">memcpy</span>(left_child, root, PAGE_SIZE);</span><br><span class="line">+  <span class="built_in">set_node_root</span>(left_child, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>最后我们需要将<strong>原根节点</strong>对应的页初始化为一个新的有两个孩子的<strong>内部节点</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  <span class="comment">/* Root node is a new internal node with one key and two children */</span></span><br><span class="line">+  <span class="built_in">initialize_internal_node</span>(root);</span><br><span class="line">+  <span class="built_in">set_node_root</span>(root, <span class="literal">true</span>);</span><br><span class="line">+  *<span class="built_in">internal_node_num_keys</span>(root) = <span class="number">1</span>;</span><br><span class="line">+  *<span class="built_in">internal_node_child</span>(root, <span class="number">0</span>) = left_child_page_num;</span><br><span class="line">+  <span class="type">uint32_t</span> left_child_max_key = <span class="built_in">get_node_max_key</span>(left_child);</span><br><span class="line">+  *<span class="built_in">internal_node_key</span>(root, <span class="number">0</span>) = left_child_max_key;</span><br><span class="line">+  *<span class="built_in">internal_node_right_child</span>(root) = right_child_page_num;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Internal-Node-Format"><a href="#Internal-Node-Format" class="headerlink" title="Internal Node Format"></a>Internal Node Format</h3><p>现在我们终于要创建一个内部节点了,我们要先定义它的布局.</p>
<p>内部节点以普通节点头部开始，然后是它包含的键的数量，然后是它的最右边节点的page number.内部节点存储的指向子节点的指针总是比键的数量多一个.那个额外的子节点指针存储在头部.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Internal Node Header Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_NUM_KEYS_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_NUM_KEYS_OFFSET = COMMON_NODE_HEADER_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_RIGHT_CHILD_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_RIGHT_CHILD_OFFSET =</span><br><span class="line">+    INTERNAL_NODE_NUM_KEYS_OFFSET + INTERNAL_NODE_NUM_KEYS_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_HEADER_SIZE = COMMON_NODE_HEADER_SIZE +</span><br><span class="line">+                                           INTERNAL_NODE_NUM_KEYS_SIZE +</span><br><span class="line">+                                           INTERNAL_NODE_RIGHT_CHILD_SIZE;</span><br></pre></td></tr></table></figure>

<p>body是一个存储cell的数组，每个cell包含一个指向子节点的指针和键.每个键应该是该键左边的子节点中的最大的键值.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Internal Node Body Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_KEY_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_CHILD_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> INTERNAL_NODE_CELL_SIZE =</span><br><span class="line">+    INTERNAL_NODE_CHILD_SIZE + INTERNAL_NODE_KEY_SIZE;</span><br></pre></td></tr></table></figure>

<p>基于这些常量,内部节点的布局应该长这样:</p>
<p>Our internal node format</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/internal-node-format.png"><img src="https://cstack.github.io/db_tutorial/assets/images/internal-node-format.png" alt="内部节点布局"></a></p>
<p>Notice our huge branching factor(不知道咋翻译…).因为每个<code>子节点指针&amp;键</code>组合相当小，每个内部节点可以存储510个键和511个孩子指针.这意味着我们几乎不会需要遍历树的很多层来找到一个给定的键值.</p>
<table id="table">
<thead>
<tr>
<th># 内部节点层数</th>
<th>最多 # 叶子节点</th>
<th>所有叶子节点的总大小</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>511^0&#x3D;1</td>
<td>4KB</td>
</tr>
<tr>
<td>1</td>
<td>511^1&#x3D;512</td>
<td>~ 2MB</td>
</tr>
<tr>
<td>2</td>
<td>511^2&#x3D;261,121</td>
<td>~ 1GB</td>
</tr>
<tr>
<td>3</td>
<td>511^3&#x3D;133,432,831</td>
<td>~ 550GB</td>
</tr>
</tbody></table>

<p>实际上，每个叶子节点不可能将4KB全部用来存储数据,因为还需要存储头部信息,键,还有一些空间被浪费了.但是我们只需要从磁盘中加载4页数据就可以搜索500GB的数据.这就是为什么B-Tree这个数据结构非常适合数据库.</p>
<p>这里有一些函数用来想内部节点读写数据:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">internal_node_num_keys</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + INTERNAL_NODE_NUM_KEYS_OFFSET;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">internal_node_right_child</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + INTERNAL_NODE_RIGHT_CHILD_OFFSET;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">internal_node_cell</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + INTERNAL_NODE_HEADER_SIZE + cell_num * INTERNAL_NODE_CELL_SIZE;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">internal_node_child</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> child_num)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint32_t</span> num_keys = *<span class="built_in">internal_node_num_keys</span>(node);</span><br><span class="line">+  <span class="keyword">if</span> (child_num &gt; num_keys) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Tried to access child_num %d &gt; num_keys %d\n&quot;</span>, child_num, num_keys);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child_num == num_keys) &#123;</span><br><span class="line">+    <span class="keyword">return</span> <span class="built_in">internal_node_right_child</span>(node);</span><br><span class="line">+  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+    <span class="keyword">return</span> <span class="built_in">internal_node_cell</span>(node, child_num);</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">internal_node_key</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> key_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> (<span class="type">uint32_t</span>* )((<span class="type">unsigned</span> <span class="type">char</span>* )<span class="built_in">internal_node_cell</span>(node,key_num)+INTERNAL_NODE_CHILD_SIZE);</span><br><span class="line"><span class="comment">/*译者注: 原文为 return internal_node_cell(node, key_num) + INTERNAL_NODE_CHILD_SIZE;</span></span><br><span class="line"><span class="comment">但是internal_node_cell()返回的是4字节int指针,所以算数运算时单位为4个字节,需要先转换为单字节指针然后加上偏移量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个内部节点，最大的key总是它的最右边的key.对于一个叶子节点,最大的key的下标最大:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">uint32_t</span> <span class="title">get_node_max_key</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">switch</span> (<span class="built_in">get_node_type</span>(node)) &#123;</span><br><span class="line">+    <span class="keyword">case</span> NODE_INTERNAL:</span><br><span class="line">+      <span class="keyword">return</span> *<span class="built_in">internal_node_key</span>(node, *<span class="built_in">internal_node_num_keys</span>(node) - <span class="number">1</span>);</span><br><span class="line">+    <span class="keyword">case</span> NODE_LEAF:</span><br><span class="line">+      <span class="keyword">return</span> *<span class="built_in">leaf_node_key</span>(node, *<span class="built_in">leaf_node_num_cells</span>(node) - <span class="number">1</span>);</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Keeping-Track-of-the-Root"><a href="#Keeping-Track-of-the-Root" class="headerlink" title="Keeping Track of the Root"></a>Keeping Track of the Root</h3><p>我们最后利用的是普通节点头部的<code>is_root</code>值.</p>
<p>记得我们使用它来决定如何分裂一个叶子节点的:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_node_root</span>(old_node)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">create_new_root</span>(cursor-&gt;table, new_page_num);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Need to implement updating parent after split\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有<code>getter &amp; setter</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">bool</span> <span class="title">is_node_root</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint8_t</span> value = *((<span class="type">uint8_t</span>*)(node + IS_ROOT_OFFSET));</span><br><span class="line">+  <span class="keyword">return</span> (<span class="type">bool</span>)value;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">set_node_root</span><span class="params">(<span class="type">void</span>* node, <span class="type">bool</span> is_root)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint8_t</span> value = is_root;</span><br><span class="line">+  *((<span class="type">uint8_t</span>*)(node + IS_ROOT_OFFSET)) = value;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<p>初始化每种节点都应该默认设置<code>is_root</code>为false:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">initialize_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">set_node_type</span>(node, NODE_LEAF);</span><br><span class="line">+  <span class="built_in">set_node_root</span>(node, <span class="literal">false</span>);</span><br><span class="line">   *<span class="built_in">leaf_node_num_cells</span>(node) = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">initialize_internal_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="built_in">set_node_type</span>(node, NODE_INTERNAL);</span><br><span class="line">+  <span class="built_in">set_node_root</span>(node, <span class="literal">false</span>);</span><br><span class="line">+  *<span class="built_in">internal_node_num_keys</span>(node) = <span class="number">0</span>;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<p>我们应该在创建的节点为table中的第一个节点时设置<code>is_root</code>为true:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">     <span class="comment">// New database file. Initialize page 0 as leaf node.</span></span><br><span class="line">     <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(pager, <span class="number">0</span>);</span><br><span class="line">     <span class="built_in">initialize_leaf_node</span>(root_node);</span><br><span class="line">+    <span class="built_in">set_node_root</span>(root_node, <span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> table;</span><br></pre></td></tr></table></figure>

</br>

<h3 id="Printing-the-Tree"><a href="#Printing-the-Tree" class="headerlink" title="Printing the Tree"></a>Printing the Tree</h3><p>为了帮助我们可视化数据库的状态,我们应该更新<code>.btree</code>命令以打印一棵多阶树.</p>
<p>我将会替换现有的<code>print_leaf_node()</code>函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-<span class="function"><span class="type">void</span> <span class="title">print_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">-  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">-  <span class="built_in">printf</span>(<span class="string">&quot;leaf (size %d)\n&quot;</span>, num_cells);</span><br><span class="line">-  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_cells; i++) &#123;</span><br><span class="line">-    <span class="type">uint32_t</span> key = *<span class="built_in">leaf_node_key</span>(node, i);</span><br><span class="line">-    <span class="built_in">printf</span>(<span class="string">&quot;  - %d : %d\n&quot;</span>, i, key);</span><br><span class="line">-  &#125;</span><br><span class="line">-&#125;</span><br></pre></td></tr></table></figure>

<p>用一个递归函数代替它.递归函数接受一个任意节点作为参数，然后打印该节点和所有子节点.还接受一个参数作为缩进等级,在向下递归的时候缩进等级递增.我还添加了一个小的辅助函数用于打印缩进.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">void</span> <span class="title">indent</span><span class="params">(<span class="type">uint32_t</span> level)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">print_tree</span><span class="params">(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> indentation_level)</span> </span>&#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(pager, page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_keys, child;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">switch</span> (<span class="built_in">get_node_type</span>(node)) &#123;</span><br><span class="line">+    <span class="built_in">case</span> (NODE_LEAF):</span><br><span class="line">+      num_keys = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">+      <span class="built_in">indent</span>(indentation_level);</span><br><span class="line">+      <span class="built_in">printf</span>(<span class="string">&quot;- leaf (size %d)\n&quot;</span>, num_keys);</span><br><span class="line">+      <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_keys; i++) &#123;</span><br><span class="line">+        <span class="built_in">indent</span>(indentation_level + <span class="number">1</span>);</span><br><span class="line">+        <span class="built_in">printf</span>(<span class="string">&quot;- %d\n&quot;</span>, *<span class="built_in">leaf_node_key</span>(node, i));</span><br><span class="line">+      &#125;</span><br><span class="line">+      <span class="keyword">break</span>;</span><br><span class="line">+    <span class="built_in">case</span> (NODE_INTERNAL):</span><br><span class="line">+      num_keys = *<span class="built_in">internal_node_num_keys</span>(node);</span><br><span class="line">+      <span class="built_in">indent</span>(indentation_level);</span><br><span class="line">+      <span class="built_in">printf</span>(<span class="string">&quot;- internal (size %d)\n&quot;</span>, num_keys);</span><br><span class="line">+      <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_keys; i++) &#123;</span><br><span class="line">+        child = *<span class="built_in">internal_node_child</span>(node, i);</span><br><span class="line">+        <span class="built_in">print_tree</span>(pager, child, indentation_level + <span class="number">1</span>);</span><br><span class="line">+</span><br><span class="line">+        <span class="built_in">indent</span>(indentation_level + <span class="number">1</span>);</span><br><span class="line">+        <span class="built_in">printf</span>(<span class="string">&quot;- key %d\n&quot;</span>, *<span class="built_in">internal_node_key</span>(node, i));</span><br><span class="line">+      &#125;</span><br><span class="line">+      child = *<span class="built_in">internal_node_right_child</span>(node);</span><br><span class="line">+      <span class="built_in">print_tree</span>(pager, child, indentation_level + <span class="number">1</span>);</span><br><span class="line">+      <span class="keyword">break</span>;</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>

<p>然后更新<code>.btree</code>调用的函数,一开始传递的缩进等级为0.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.btree&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Tree:\n&quot;</span>);</span><br><span class="line">-    <span class="built_in">print_leaf_node</span>(<span class="built_in">get_page</span>(table-&gt;pager, <span class="number">0</span>));</span><br><span class="line">+    <span class="built_in">print_tree</span>(table-&gt;pager, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br></pre></td></tr></table></figure>

<p>这里有测试新的打印函数的代码喔!</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  it <span class="string">&#x27;allows printing out the structure of a 3-leaf-node btree&#x27;</span> <span class="keyword">do</span></span><br><span class="line">+    script = (<span class="number">1.</span><span class="number">.14</span>).map <span class="keyword">do</span> |i|</span><br><span class="line">+      <span class="string">&quot;insert #&#123;i&#125; user#&#123;i&#125; person#&#123;i&#125;@example.com&quot;</span></span><br><span class="line">+    end</span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;.btree&quot;</span></span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;insert 15 user15 person15@example.com&quot;</span></span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;.exit&quot;</span></span><br><span class="line">+    result = <span class="built_in">run_script</span>(script)</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">expect</span>(result[<span class="number">14.</span>..(result.length)]).to <span class="built_in">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; Tree:&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;- internal (size 1)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - leaf (size 7)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 1&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 2&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 3&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 4&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 5&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 6&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 7&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - key 7&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - leaf (size 7)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 8&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 9&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 10&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 11&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 12&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 13&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;    - 14&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Need to implement searching an internal node&quot;</span>,</span><br><span class="line">+    ])</span><br><span class="line">+  end</span><br></pre></td></tr></table></figure>

<p>打印的内容被简化了,所以我们需要更新一下之前的<code>.btree</code>测试:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">       <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">       <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">       <span class="string">&quot;db &gt; Tree:&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;leaf (size 3)&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;  - 0 : 1&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;  - 1 : 2&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;  - 2 : 3&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;- leaf (size 3)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 1&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 2&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 3&quot;</span>,</span><br><span class="line">       <span class="string">&quot;db &gt; &quot;</span></span><br><span class="line">     ])</span><br><span class="line">   end</span><br></pre></td></tr></table></figure>
    </div>
  </div>
</article> 
  </div>
  
<link rel="stylesheet" href="/css/footer.css">


<div id="footer"></div>
 
</body>