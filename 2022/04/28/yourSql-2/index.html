<!DOCTYPE html>
<html lang=" ">
<head>
  <meta charset="utf-8" />
<link rel="icon" href="/images/rev_sheep.png " />
<title>almostSalted</title>
<meta name="referrer" content="no-referrer" />
<meta name="google-site-verification" content="_CsSd0yrTQQrdEyoybq1kZNTZbIVulPo3zdQnaqAR0Y" />
<link rel="stylesheet" href="/css/highlight/styles/monokai.min.css" />
  
<link rel="stylesheet" href="/css/layout.css">

<meta name="generator" content="Hexo 6.1.0"></head>
<body>
  
<link rel="stylesheet" href="/css/header.css">


<div class="topBar">
  <img class="icon" src="/images/rev_sheep.png " />
  <div class="menu">
     
    <a href="/ ">home</a>
     
    <a href="/archives ">archives</a>
     
    <a href="/categories ">categories</a>
     
    <a href="/aboutme ">aboutme</a>
     
    <a href="/diary ">diary</a>
    
  </div>
</div>
<div class="blank"></div>
  <div class="wrapper">
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div id="post">
  <aside id="navigator">
    <ol class="anchor"><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#Original"><span class="anchor-number">1.</span> <span class="anchor-text">Original</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part-8-B-Tree-leaf-Node-Format"><span class="anchor-number">1.1.</span> <span class="anchor-text">Part 8 - B-Tree leaf Node Format</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Alternative-Table-Formats"><span class="anchor-number">1.1.1.</span> <span class="anchor-text">Alternative Table Formats</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Leaf-Node-Format"><span class="anchor-number">1.1.2.</span> <span class="anchor-text">Leaf Node Format</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Accessing-Leaf-Node-Fields"><span class="anchor-number">1.1.3.</span> <span class="anchor-text">Accessing Leaf Node Fields</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Changes-to-Pager-and-Table-Objects"><span class="anchor-number">1.1.4.</span> <span class="anchor-text">Changes to Pager and Table Objects</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Changes-to-the-Cursor-Object"><span class="anchor-number">1.1.5.</span> <span class="anchor-text">Changes to the Cursor Object</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Insertion-Into-a-Leaf-Node"><span class="anchor-number">1.1.6.</span> <span class="anchor-text">Insertion Into a Leaf Node</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Command-to-Print-Constants"><span class="anchor-number">1.1.7.</span> <span class="anchor-text">Command to Print Constants</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Tree-Visualization"><span class="anchor-number">1.1.8.</span> <span class="anchor-text">Tree Visualization</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Next-Time"><span class="anchor-number">1.1.9.</span> <span class="anchor-text">Next Time</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Complete-Diff"><span class="anchor-number">1.1.10.</span> <span class="anchor-text">Complete Diff</span></a></li></ol></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part-9-Binary-Search-and-Duplicate-Keys"><span class="anchor-number">1.2.</span> <span class="anchor-text">Part 9 - Binary Search and Duplicate Keys</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part-10-Splitting-a-Leaf-Node"><span class="anchor-number">1.3.</span> <span class="anchor-text">Part 10 - Splitting a Leaf Node</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Splitting-Algorithm"><span class="anchor-number">1.3.1.</span> <span class="anchor-text">Splitting Algorithm</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Allocating-New-Pages"><span class="anchor-number">1.3.2.</span> <span class="anchor-text">Allocating New Pages</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Leaf-Node-Sizes"><span class="anchor-number">1.3.3.</span> <span class="anchor-text">Leaf Node Sizes</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Creating-a-New-Root"><span class="anchor-number">1.3.4.</span> <span class="anchor-text">Creating a New Root</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Internal-Node-Format"><span class="anchor-number">1.3.5.</span> <span class="anchor-text">Internal Node Format</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Keeping-Track-of-the-Root"><span class="anchor-number">1.3.6.</span> <span class="anchor-text">Keeping Track of the Root</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Printing-the-Tree"><span class="anchor-number">1.3.7.</span> <span class="anchor-text">Printing the Tree</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#A-Major-Problem"><span class="anchor-number">1.3.8.</span> <span class="anchor-text">A Major Problem</span></a></li></ol></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part-11-Recursively-Searching-the-B-Tree"><span class="anchor-number">1.4.</span> <span class="anchor-text">Part 11 -Recursively Searching the B-Tree</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Tests"><span class="anchor-number">1.4.1.</span> <span class="anchor-text">Tests</span></a></li></ol></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part-12-Scanning-a-Multi-Level-B-Tree"><span class="anchor-number">1.5.</span> <span class="anchor-text">Part 12 -Scanning a Multi-Level B-Tree</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part-13-Updating-Parent-Node-After-a-Split"><span class="anchor-number">1.6.</span> <span class="anchor-text">Part 13 - Updating Parent Node After a Split</span></a></li></ol></li><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#%E7%8B%97%E5%B0%BE%E7%BB%AD%E8%B2%82"><span class="anchor-number">2.</span> <span class="anchor-text">狗尾续貂</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part-14-Splitting-a-Internal-Node"><span class="anchor-number">2.1.</span> <span class="anchor-text">Part 14 - Splitting a Internal Node</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Introduction"><span class="anchor-number">2.1.1.</span> <span class="anchor-text">Introduction</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Cell-or-Child"><span class="anchor-number">2.1.2.</span> <span class="anchor-text">Cell or Child?</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Splitting-Algorithm-1"><span class="anchor-number">2.1.3.</span> <span class="anchor-text">Splitting Algorithm</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Create-New-Root"><span class="anchor-number">2.1.4.</span> <span class="anchor-text">Create New Root</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Test"><span class="anchor-number">2.1.5.</span> <span class="anchor-text">Test</span></a></li></ol></li></ol></li></ol>
  </aside>
  <div id="content">
    <div id="postHead">
      <h1>yourSql 2</h1>
      <div class="postDate">
        <img class="dateIcon" src="/images/clockicon.svg" />
        --2022.4.28
      </div>
        
        <div class="postCategory">
            <a href="/categories/translation/">translation</a>
        </div>
         
    </div>
    <div id="postBody">
      <h1 id="Original"><a href="#Original" class="headerlink" title="Original"></a>Original</h1><style>
    #table {
        margin: 0 auto;
        text-align: center;
        border: 1px solid grey;
        border-collapse: collapse;
        line-height: 1.6em;
    }
    #table th,#table td {
        border: 1px solid grey;
        padding: 0.5em;
    }
</style>

</br>

<h2 id="Part-8-B-Tree-leaf-Node-Format"><a href="#Part-8-B-Tree-leaf-Node-Format" class="headerlink" title="Part 8 - B-Tree leaf Node Format"></a>Part 8 - B-Tree leaf Node Format</h2><p>我们即将把 table 的结构从存储 row 的无序数组转变为 B-Tree,这是一个相当大的改变以至于需要好几章来实现.在本章的末尾，我们将会定义叶子节点的布局，以及支持向只有一个节点的树中插入键值对.</p>
<p>不过首先让我们回想一下为什么转换到树结构.</p>
<h3 id="Alternative-Table-Formats"><a href="#Alternative-Table-Formats" class="headerlink" title="Alternative Table Formats"></a>Alternative Table Formats</h3><p>基于目前的存储格式，每页只存储 row(没有元数据)因此空间利用效率很高.插入也很快因为我们只需要插入到末尾.但是寻找指定的 row 只能通过遍历整个 table 来完成,并且如果我们想要删除 row,我们需要将删除的 row 之后的所有行前移以填补空缺.</p>
<p>如果我们以数组的形式存储 table,但是 row 通过 id 排序,我们可以使用二分查找指定的 id.但是插入操作会非常耗时，因为我们要移动很多行以腾出空间.</p>
<p>因此，我们将使用 tree 结构.树中的每一個节点可以包含可变数量的行,所以我们需要在节点中存储一些信息以表示它包含了多少行.此外还有不存储任何行的内部节点的空间开销.作为数据库文件变大的交换，我们得到了快速插入，删除和查找.</p>
<table id="table">
<thead>
<tr>
<th></th>
<th>存储 row 的无序数组</th>
<th>存储 row 的有序数组</th>
<th>树的节点</th>
</tr>
</thead>
<tbody><tr>
<td>page 存储的数据</td>
<td>仅数据</td>
<td>仅数据</td>
<td>元数据，主键值和数据</td>
</tr>
<tr>
<td>每页的行数</td>
<td>more</td>
<td>more</td>
<td>fewer</td>
</tr>
<tr>
<td>插入</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>删除</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>通过 id 查找</td>
<td>O(n)</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
</tr>
</tbody></table>

<p>内部节点和叶子节点拥有不同的布局，让我们定义一个枚举变量表示节点的类型.</p>
<pre><code class="c">//+typedef enum &#123; NODE_INTERNAL, NODE_LEAF &#125; NodeType;
// 译者注: 因为下文要求type大小为1字节，所以制定了enum大小为uint8_t,否则默认为4个字节
typedef enum : uint8_t
&#123;
    NODE_INTERNAL,
    NODE_LEAF
&#125; NodeType;
</code></pre>
<p>每一个节点对应着一页.内部节点存储着指向子节点的指针，该指针实际上是存储着该子节点的页的 page number(译者注:即下标).btree 向 pager 请求指定的 page number,pager 返回指向该页缓存的指针.页根据 page number 有序存储在数据库文件中.</p>
<p>节点需要在页的头部存储一些元数据.每个节点会存储它的类型,是否为根节点，和一个指向父节点的指针(用来寻找兄弟节点).我定义了常量来表示头部的每个字段的大小和偏移量.</p>
<pre><code class="cpp">+/*
+ * Common Node Header Layout
+ */
+const uint32_t NODE_TYPE_SIZE = sizeof(NodeType);
+const uint32_t NODE_TYPE_OFFSET = 0;
+const uint32_t IS_ROOT_SIZE = sizeof(uint8_t);
+const uint32_t IS_ROOT_OFFSET = NODE_TYPE_SIZE;
+const uint32_t PARENT_POINTER_SIZE = sizeof(uint32_t);
+const uint32_t PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;
+const uint8_t COMMON_NODE_HEADER_SIZE =
+    NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;
</code></pre>
<h3 id="Leaf-Node-Format"><a href="#Leaf-Node-Format" class="headerlink" title="Leaf Node Format"></a>Leaf Node Format</h3><p>除了这些通用的头部字段外，叶子节点需要存储包含的”cell”的数量.一个”cell”就是一个键值对.</p>
<pre><code class="cpp">+/*
+ * Leaf Node Header Layout
+ */
+const uint32_t LEAF_NODE_NUM_CELLS_SIZE = sizeof(uint32_t);
+const uint32_t LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;
+const uint32_t LEAF_NODE_HEADER_SIZE =
+    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;
</code></pre>
<p>叶子节点的 body 是 cell 数组.每个 cell 是一个键后面跟着一个值(一个序列化的行).</p>
<pre><code class="cpp">+/*
+ * Leaf Node Body Layout
+ */
+const uint32_t LEAF_NODE_KEY_SIZE = sizeof(uint32_t);
+const uint32_t LEAF_NODE_KEY_OFFSET = 0;
+const uint32_t LEAF_NODE_VALUE_SIZE = ROW_SIZE;
+const uint32_t LEAF_NODE_VALUE_OFFSET =
+    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;
+const uint32_t LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZE;
+const uint32_t LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;
+const uint32_t LEAF_NODE_MAX_CELLS =
+    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;
</code></pre>
<p>基于这些常量,这里是叶子节点目前布局:</p>
<p>Our leaf node format</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/leaf-node-format.png"><img src="https://cstack.github.io/db_tutorial/assets/images/leaf-node-format.png" alt="Our leaf node format"></a></p>
<p>在头部使用一整个字节表示一个 bool 值有点浪费空间，但是这会让通过代码获取这些值更容易一点.</p>
<p>还要注意末尾有一些被浪费的空间.我们在头部之后存储尽可能多的 cell,但是剩余的空间不能存储一整个 cell.我们不使用这片空间以避免把 cell 分割到两个节点.</p>
<h3 id="Accessing-Leaf-Node-Fields"><a href="#Accessing-Leaf-Node-Fields" class="headerlink" title="Accessing Leaf Node Fields"></a>Accessing Leaf Node Fields</h3><p>获取键，值和元数据的函数都涉及到使用我们刚刚定义的常量进行指针算数运算.</p>
<pre><code class="cpp">+uint32_t* leaf_node_num_cells(void* node) &#123;
+  return node + LEAF_NODE_NUM_CELLS_OFFSET;
+&#125;
+
+void* leaf_node_cell(void* node, uint32_t cell_num) &#123;
+  return node + LEAF_NODE_HEADER_SIZE + cell_num * LEAF_NODE_CELL_SIZE;
+&#125;
+
+uint32_t* leaf_node_key(void* node, uint32_t cell_num) &#123;
+  return leaf_node_cell(node, cell_num);
+&#125;
+
+void* leaf_node_value(void* node, uint32_t cell_num) &#123;
+  return leaf_node_cell(node, cell_num) + LEAF_NODE_KEY_SIZE;
+&#125;
+
+void initialize_leaf_node(void* node) &#123; *leaf_node_num_cells(node) = 0; &#125;
+
</code></pre>
<h3 id="Changes-to-Pager-and-Table-Objects"><a href="#Changes-to-Pager-and-Table-Objects" class="headerlink" title="Changes to Pager and Table Objects"></a>Changes to Pager and Table Objects</h3><p>每个节点将确切地占据一页，即使页没满.这意味着我们的 pager 不再需要支持 读&#x2F;写 未满的页了.</p>
<pre><code class="cpp">-void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) &#123;
+void pager_flush(Pager* pager, uint32_t page_num) &#123;
   if (pager-&gt;pages[page_num] == NULL) &#123;
     printf(&quot;Tried to flush null page\n&quot;);
     exit(EXIT_FAILURE);
@@ -242,7 +337,7 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) &#123;
   &#125;

   ssize_t bytes_written =
-      write(pager-&gt;file_descriptor, pager-&gt;pages[page_num], size);
+      write(pager-&gt;file_descriptor, pager-&gt;pages[page_num], PAGE_SIZE);

   if (bytes_written == -1) &#123;
     printf(&quot;Error writing: %d\n&quot;, errno);

 void db_close(Table* table) &#123;
   Pager* pager = table-&gt;pager;
-  uint32_t num_full_pages = table-&gt;num_rows / ROWS_PER_PAGE;

-  for (uint32_t i = 0; i &lt; num_full_pages; i++) &#123;
+  for (uint32_t i = 0; i &lt; pager-&gt;num_pages; i++) &#123;
     if (pager-&gt;pages[i] == NULL) &#123;
       continue;
     &#125;
-    pager_flush(pager, i, PAGE_SIZE);
+    pager_flush(pager, i);
     free(pager-&gt;pages[i]);
     pager-&gt;pages[i] = NULL;
   &#125;

-  // There may be a partial page to write to the end of the file
-  // This should not be needed after we switch to a B-tree
-  uint32_t num_additional_rows = table-&gt;num_rows % ROWS_PER_PAGE;
-  if (num_additional_rows &gt; 0) &#123;
-    uint32_t page_num = num_full_pages;
-    if (pager-&gt;pages[page_num] != NULL) &#123;
-      pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);
-      free(pager-&gt;pages[page_num]);
-      pager-&gt;pages[page_num] = NULL;
-    &#125;
-  &#125;
-
   int result = close(pager-&gt;file_descriptor);
   if (result == -1) &#123;
     printf(&quot;Error closing db file.\n&quot;);
</code></pre>
<p>现在更明智的做法是在数据库中存储 page 的个数而不是 row 的个数.page 的个数和 pager 对象关联，而不是 table,因为这是被数据库使用的 page 的个数，而不是指定的 table.一个 btree 被它的根节点对应的 page 下标标识，所以 table 对象需要保存该下标.</p>
<pre><code class="cpp"> const uint32_t PAGE_SIZE = 4096;
 const uint32_t TABLE_MAX_PAGES = 100;
-const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;
-const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;

 typedef struct &#123;
   int file_descriptor;
   uint32_t file_length;
+  uint32_t num_pages;
   void* pages[TABLE_MAX_PAGES];
 &#125; Pager;

 typedef struct &#123;
   Pager* pager;
-  uint32_t num_rows;
+  uint32_t root_page_num;
 &#125; Table;

@@ -127,6 +200,10 @@ void* get_page(Pager* pager, uint32_t page_num) &#123;
     &#125;

     pager-&gt;pages[page_num] = page;
+
+    if (page_num &gt;= pager-&gt;num_pages) &#123;
+      pager-&gt;num_pages = page_num + 1;
+    &#125;
   &#125;

   return pager-&gt;pages[page_num];

@@ -184,6 +269,12 @@ Pager* pager_open(const char* filename) &#123;
   Pager* pager = malloc(sizeof(Pager));
   pager-&gt;file_descriptor = fd;
   pager-&gt;file_length = file_length;
+  pager-&gt;num_pages = (file_length / PAGE_SIZE);
+
+  if (file_length % PAGE_SIZE != 0) &#123;
+    printf(&quot;Db file is not a whole number of pages. Corrupt file.\n&quot;);
+    exit(EXIT_FAILURE);
+  &#125;

   for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) &#123;
     pager-&gt;pages[i] = NULL;
</code></pre>
<h3 id="Changes-to-the-Cursor-Object"><a href="#Changes-to-the-Cursor-Object" class="headerlink" title="Changes to the Cursor Object"></a>Changes to the Cursor Object</h3><p>cursor 对象表示在 table 中的位置,当我们的 table 只是一个简单的元素为 row 的数组,我们只需要给定 row number 就可以访问该行.现在它是一棵树,我们通过 page number 和 cell 在节点中的 cell number 来标识一个位置.</p>
<pre><code class="cpp"> typedef struct &#123;
   Table* table;
-  uint32_t row_num;
+  uint32_t page_num;
+  uint32_t cell_num;
   bool end_of_table;  // Indicates a position one past the last element
 &#125; Cursor;

 Cursor* table_start(Table* table) &#123;
   Cursor* cursor = malloc(sizeof(Cursor));
   cursor-&gt;table = table;
-  cursor-&gt;row_num = 0;
-  cursor-&gt;end_of_table = (table-&gt;num_rows == 0);
+  cursor-&gt;page_num = table-&gt;root_page_num;
+  cursor-&gt;cell_num = 0;
+
+  void* root_node = get_page(table-&gt;pager, table-&gt;root_page_num);
+  uint32_t num_cells = *leaf_node_num_cells(root_node);
+  cursor-&gt;end_of_table = (num_cells == 0);

   return cursor;
 &#125;

 Cursor* table_end(Table* table) &#123;
   Cursor* cursor = malloc(sizeof(Cursor));
   cursor-&gt;table = table;
-  cursor-&gt;row_num = table-&gt;num_rows;
+  cursor-&gt;page_num = table-&gt;root_page_num;
+
+  void* root_node = get_page(table-&gt;pager, table-&gt;root_page_num);
+  uint32_t num_cells = *leaf_node_num_cells(root_node);
+  cursor-&gt;cell_num = num_cells;
   cursor-&gt;end_of_table = true;

   return cursor;
 &#125;

 void* cursor_value(Cursor* cursor) &#123;
-  uint32_t row_num = cursor-&gt;row_num;
-  uint32_t page_num = row_num / ROWS_PER_PAGE;
+  uint32_t page_num = cursor-&gt;page_num;
   void* page = get_page(cursor-&gt;table-&gt;pager, page_num);
-  uint32_t row_offset = row_num % ROWS_PER_PAGE;
-  uint32_t byte_offset = row_offset * ROW_SIZE;
-  return page + byte_offset;
+  return leaf_node_value(page, cursor-&gt;cell_num);
 &#125;

 void cursor_advance(Cursor* cursor) &#123;
-  cursor-&gt;row_num += 1;
-  if (cursor-&gt;row_num &gt;= cursor-&gt;table-&gt;num_rows) &#123;
+  uint32_t page_num = cursor-&gt;page_num;
+  void* node = get_page(cursor-&gt;table-&gt;pager, page_num);
+
+  cursor-&gt;cell_num += 1;
+  if (cursor-&gt;cell_num &gt;= (*leaf_node_num_cells(node))) &#123;
     cursor-&gt;end_of_table = true;
   &#125;
 &#125;
</code></pre>
<h3 id="Insertion-Into-a-Leaf-Node"><a href="#Insertion-Into-a-Leaf-Node" class="headerlink" title="Insertion Into a Leaf Node"></a>Insertion Into a Leaf Node</h3><p>在本章我们会实现一个只有一个节点的树.回忆一下上一章的一开始只有一个空的叶子节点的树:</p>
<p>empty btree</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree1.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree1.png" alt="empty btree"></a></p>
<p>键值对可以一直放入，直到叶子节点被填满:</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree2.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree2.png" alt="one-node btree"></a></p>
<p>当我们第一次打开数据库，数据库文件是空的，所以我们初始化 page 0 为一个空的叶子节点(也是根节点):</p>
<pre><code class="cpp"> Table* db_open(const char* filename) &#123;
   Pager* pager = pager_open(filename);
-  uint32_t num_rows = pager-&gt;file_length / ROW_SIZE;

   Table* table = malloc(sizeof(Table));
   table-&gt;pager = pager;
-  table-&gt;num_rows = num_rows;
+  table-&gt;root_page_num = 0;
+
+  if (pager-&gt;num_pages == 0) &#123;
+    // New database file. Initialize page 0 as leaf node.
+    void* root_node = get_page(pager, 0);
+    initialize_leaf_node(root_node);
+  &#125;

   return table;
 &#125;
</code></pre>
<p>然后我们会创建一个用来向叶子节点中插入键值对的函数,函数的参数 cursor 包含键值对应该被插入的位置.</p>
<pre><code class="cpp">+void leaf_node_insert(Cursor* cursor, uint32_t key, Row* value) &#123;
+  void* node = get_page(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);
+
+  uint32_t num_cells = *leaf_node_num_cells(node);
+  if (num_cells &gt;= LEAF_NODE_MAX_CELLS) &#123;
+    // Node full
+    printf(&quot;Need to implement splitting a leaf node.\n&quot;);
+    exit(EXIT_FAILURE);
+  &#125;
+
+  if (cursor-&gt;cell_num &lt; num_cells) &#123;
+    // Make room for new cell
+    for (uint32_t i = num_cells; i &gt; cursor-&gt;cell_num; i--) &#123;
+      memcpy(leaf_node_cell(node, i), leaf_node_cell(node, i - 1),
+             LEAF_NODE_CELL_SIZE);
+    &#125;
+  &#125;
+
+  *(leaf_node_num_cells(node)) += 1;
+  *(leaf_node_key(node, cursor-&gt;cell_num)) = key;
+  serialize_row(value, leaf_node_value(node, cursor-&gt;cell_num));
+&#125;
+
</code></pre>
<p>我们现在还没有实现分裂操作,所以如果 node 容量满了会退出程序.然后将插入位置后面的 cell 右移一位以给新的 cell 腾出空间，然后我们向空的空间写入 key&amp;value.</p>
<p>既然我们假设树只有一个节点，<code>execute_insert()</code>函数只需要调用这个辅助函数:</p>
<pre><code class="cpp"> ExecuteResult execute_insert(Statement* statement, Table* table) &#123;
-  if (table-&gt;num_rows &gt;= TABLE_MAX_ROWS) &#123;
+  void* node = get_page(table-&gt;pager, table-&gt;root_page_num);
+  if ((*leaf_node_num_cells(node) &gt;= LEAF_NODE_MAX_CELLS)) &#123;
     return EXECUTE_TABLE_FULL;
   &#125;

   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);
   Cursor* cursor = table_end(table);

-  serialize_row(row_to_insert, cursor_value(cursor));
-  table-&gt;num_rows += 1;
+  leaf_node_insert(cursor, row_to_insert-&gt;id, row_to_insert);

   free(cursor);
</code></pre>
<p>通过这些改动，我们的数据库就能和之前一样工作了!除了现在它会更早地返回”Table 已满”错误，因为我们还不能分裂根节点.</p>
<p>叶子节点可以保存多少行呢?</p>
<h3 id="Command-to-Print-Constants"><a href="#Command-to-Print-Constants" class="headerlink" title="Command to Print Constants"></a>Command to Print Constants</h3><p>我增加了一个新的元命令，用来打印一些有趣的常量.</p>
<pre><code class="cpp">+void print_constants() &#123;
+  printf(&quot;ROW_SIZE: %d\n&quot;, ROW_SIZE);
+  printf(&quot;COMMON_NODE_HEADER_SIZE: %d\n&quot;, COMMON_NODE_HEADER_SIZE);
+  printf(&quot;LEAF_NODE_HEADER_SIZE: %d\n&quot;, LEAF_NODE_HEADER_SIZE);
+  printf(&quot;LEAF_NODE_CELL_SIZE: %d\n&quot;, LEAF_NODE_CELL_SIZE);
+  printf(&quot;LEAF_NODE_SPACE_FOR_CELLS: %d\n&quot;, LEAF_NODE_SPACE_FOR_CELLS);
+  printf(&quot;LEAF_NODE_MAX_CELLS: %d\n&quot;, LEAF_NODE_MAX_CELLS);
+&#125;
+
@@ -294,6 +376,14 @@ MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table* table) &#123;
   if (strcmp(input_buffer-&gt;buffer, &quot;.exit&quot;) == 0) &#123;
     db_close(table);
     exit(EXIT_SUCCESS);
+  &#125; else if (strcmp(input_buffer-&gt;buffer, &quot;.constants&quot;) == 0) &#123;
+    printf(&quot;Constants:\n&quot;);
+    print_constants();
+    return META_COMMAND_SUCCESS;
   &#125; else &#123;
     return META_COMMAND_UNRECOGNIZED_COMMAND;
   &#125;
</code></pre>
<p>我还添加了一个测试，可以用来提醒我们这些变量改变了:</p>
<pre><code class="cpp">+  it &#39;prints constants&#39; do
+    script = [
+      &quot;.constants&quot;,
+      &quot;.exit&quot;,
+    ]
+    result = run_script(script)
+
+    expect(result).to match_array([
+      &quot;db &gt; Constants:&quot;,
+      &quot;ROW_SIZE: 293&quot;,
+      &quot;COMMON_NODE_HEADER_SIZE: 6&quot;,
+      &quot;LEAF_NODE_HEADER_SIZE: 10&quot;,
+      &quot;LEAF_NODE_CELL_SIZE: 297&quot;,
+      &quot;LEAF_NODE_SPACE_FOR_CELLS: 4086&quot;,
+      &quot;LEAF_NODE_MAX_CELLS: 13&quot;,
+      &quot;db &gt; &quot;,
+    ])
+  end
</code></pre>
<p>现在我们的 table 可以保存 13 行喔!</p>
<h3 id="Tree-Visualization"><a href="#Tree-Visualization" class="headerlink" title="Tree Visualization"></a>Tree Visualization</h3><p>为了便于调试和可视化,我还增加了一个元命令来打印出 btree 表现形式.</p>
<pre><code class="cpp">+void print_leaf_node(void* node) &#123;
+  uint32_t num_cells = *leaf_node_num_cells(node);
+  printf(&quot;leaf (size %d)\n&quot;, num_cells);
+  for (uint32_t i = 0; i &lt; num_cells; i++) &#123;
+    uint32_t key = *leaf_node_key(node, i);
+    printf(&quot;  - %d : %d\n&quot;, i, key);
+  &#125;
+&#125;
+

@@ -294,6 +376,14 @@ MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table* table) &#123;
   if (strcmp(input_buffer-&gt;buffer, &quot;.exit&quot;) == 0) &#123;
     db_close(table);
     exit(EXIT_SUCCESS);
+  &#125; else if (strcmp(input_buffer-&gt;buffer, &quot;.btree&quot;) == 0) &#123;
+    printf(&quot;Tree:\n&quot;);
+    print_leaf_node(get_page(table-&gt;pager, 0));
+    return META_COMMAND_SUCCESS;
   &#125; else if (strcmp(input_buffer-&gt;buffer, &quot;.constants&quot;) == 0) &#123;
     printf(&quot;Constants:\n&quot;);
     print_constants();
     return META_COMMAND_SUCCESS;
   &#125; else &#123;
     return META_COMMAND_UNRECOGNIZED_COMMAND;
   &#125;
</code></pre>
<p>以及一个测试</p>
<pre><code class="cpp">+  it &#39;allows printing out the structure of a one-node btree&#39; do
+    script = [3, 1, 2].map do |i|
+      &quot;insert #&#123;i&#125; user#&#123;i&#125; person#&#123;i&#125;@example.com&quot;
+    end
+    script &lt;&lt; &quot;.btree&quot;
+    script &lt;&lt; &quot;.exit&quot;
+    result = run_script(script)
+
+    expect(result).to match_array([
+      &quot;db &gt; Executed.&quot;,
+      &quot;db &gt; Executed.&quot;,
+      &quot;db &gt; Executed.&quot;,
+      &quot;db &gt; Tree:&quot;,
+      &quot;leaf (size 3)&quot;,
+      &quot;  - 0 : 3&quot;,
+      &quot;  - 1 : 1&quot;,
+      &quot;  - 2 : 2&quot;,
+      &quot;db &gt; &quot;
+    ])
+  end
</code></pre>
<p>果咩，我们仍然没能有序地存储行.你可能注意到了<code>execute_insert()</code>函数在叶子节点的插入位置是由函数<code>table_end()</code>返回的.所以行是以插入的顺序排序的,就像之前一样.</p>
</br>

<h3 id="Next-Time"><a href="#Next-Time" class="headerlink" title="Next Time"></a>Next Time</h3><p>本章看起来像是倒退了一步.我们的数据库现在存储的行比之前少，并且我们存储的行仍然是无序的.但就像我在一开始说的，这是我们的一大步，并且将其分解成可管理的步骤很重要.</p>
<p>下一章，我们会实现根据 primary key(主键值)查找记录，然后有序地存储行.</p>
</br>

<h3 id="Complete-Diff"><a href="#Complete-Diff" class="headerlink" title="Complete Diff"></a>Complete Diff</h3><pre><code class="cpp">@@ -62,29 +62,101 @@ const uint32_t ROW_SIZE = ID_SIZE + USERNAME_SIZE + EMAIL_SIZE;

 const uint32_t PAGE_SIZE = 4096;
 #define TABLE_MAX_PAGES 100
-const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;
-const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;

 typedef struct &#123;
   int file_descriptor;
   uint32_t file_length;
+  uint32_t num_pages;
   void* pages[TABLE_MAX_PAGES];
 &#125; Pager;

 typedef struct &#123;
   Pager* pager;
-  uint32_t num_rows;
+  uint32_t root_page_num;
 &#125; Table;

 typedef struct &#123;
   Table* table;
-  uint32_t row_num;
+  uint32_t page_num;
+  uint32_t cell_num;
   bool end_of_table;  // Indicates a position one past the last element
 &#125; Cursor;

+typedef enum &#123; NODE_INTERNAL, NODE_LEAF &#125; NodeType;
+
+/*
+ * Common Node Header Layout
+ */
+const uint32_t NODE_TYPE_SIZE = sizeof(uint8_t);
+const uint32_t NODE_TYPE_OFFSET = 0;
+const uint32_t IS_ROOT_SIZE = sizeof(uint8_t);
+const uint32_t IS_ROOT_OFFSET = NODE_TYPE_SIZE;
+const uint32_t PARENT_POINTER_SIZE = sizeof(uint32_t);
+const uint32_t PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;
+const uint8_t COMMON_NODE_HEADER_SIZE =
+    NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;
+
+/*
+ * Leaf Node Header Layout
+ */
+const uint32_t LEAF_NODE_NUM_CELLS_SIZE = sizeof(uint32_t);
+const uint32_t LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;
+const uint32_t LEAF_NODE_HEADER_SIZE =
+    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;
+
+/*
+ * Leaf Node Body Layout
+ */
+const uint32_t LEAF_NODE_KEY_SIZE = sizeof(uint32_t);
+const uint32_t LEAF_NODE_KEY_OFFSET = 0;
+const uint32_t LEAF_NODE_VALUE_SIZE = ROW_SIZE;
+const uint32_t LEAF_NODE_VALUE_OFFSET =
+    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;
+const uint32_t LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZE;
+const uint32_t LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;
+const uint32_t LEAF_NODE_MAX_CELLS =
+    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;
+
+uint32_t* leaf_node_num_cells(void* node) &#123;
+  return node + LEAF_NODE_NUM_CELLS_OFFSET;
+&#125;
+
+void* leaf_node_cell(void* node, uint32_t cell_num) &#123;
+  return node + LEAF_NODE_HEADER_SIZE + cell_num * LEAF_NODE_CELL_SIZE;
+&#125;
+
+uint32_t* leaf_node_key(void* node, uint32_t cell_num) &#123;
+  return leaf_node_cell(node, cell_num);
+&#125;
+
+void* leaf_node_value(void* node, uint32_t cell_num) &#123;
+  return leaf_node_cell(node, cell_num) + LEAF_NODE_KEY_SIZE;
+&#125;
+
+void print_constants() &#123;
+  printf(&quot;ROW_SIZE: %d\n&quot;, ROW_SIZE);
+  printf(&quot;COMMON_NODE_HEADER_SIZE: %d\n&quot;, COMMON_NODE_HEADER_SIZE);
+  printf(&quot;LEAF_NODE_HEADER_SIZE: %d\n&quot;, LEAF_NODE_HEADER_SIZE);
+  printf(&quot;LEAF_NODE_CELL_SIZE: %d\n&quot;, LEAF_NODE_CELL_SIZE);
+  printf(&quot;LEAF_NODE_SPACE_FOR_CELLS: %d\n&quot;, LEAF_NODE_SPACE_FOR_CELLS);
+  printf(&quot;LEAF_NODE_MAX_CELLS: %d\n&quot;, LEAF_NODE_MAX_CELLS);
+&#125;
+
+void print_leaf_node(void* node) &#123;
+  uint32_t num_cells = *leaf_node_num_cells(node);
+  printf(&quot;leaf (size %d)\n&quot;, num_cells);
+  for (uint32_t i = 0; i &lt; num_cells; i++) &#123;
+    uint32_t key = *leaf_node_key(node, i);
+    printf(&quot;  - %d : %d\n&quot;, i, key);
+  &#125;
+&#125;
+
 void print_row(Row* row) &#123;
     printf(&quot;(%d, %s, %s)\n&quot;, row-&gt;id, row-&gt;username, row-&gt;email);
 &#125;
@@ -101,6 +173,8 @@ void deserialize_row(void *source, Row* destination) &#123;
     memcpy(&amp;(destination-&gt;email), source + EMAIL_OFFSET, EMAIL_SIZE);
 &#125;

+void initialize_leaf_node(void* node) &#123; *leaf_node_num_cells(node) = 0; &#125;
+
 void* get_page(Pager* pager, uint32_t page_num) &#123;
   if (page_num &gt; TABLE_MAX_PAGES) &#123;
     printf(&quot;Tried to fetch page number out of bounds. %d &gt; %d\n&quot;, page_num,
@@ -128,6 +202,10 @@ void* get_page(Pager* pager, uint32_t page_num) &#123;
     &#125;

     pager-&gt;pages[page_num] = page;
+
+    if (page_num &gt;= pager-&gt;num_pages) &#123;
+      pager-&gt;num_pages = page_num + 1;
+    &#125;
   &#125;

   return pager-&gt;pages[page_num];
@@ -136,8 +214,12 @@ void* get_page(Pager* pager, uint32_t page_num) &#123;
 Cursor* table_start(Table* table) &#123;
   Cursor* cursor = malloc(sizeof(Cursor));
   cursor-&gt;table = table;
-  cursor-&gt;row_num = 0;
-  cursor-&gt;end_of_table = (table-&gt;num_rows == 0);
+  cursor-&gt;page_num = table-&gt;root_page_num;
+  cursor-&gt;cell_num = 0;
+
+  void* root_node = get_page(table-&gt;pager, table-&gt;root_page_num);
+  uint32_t num_cells = *leaf_node_num_cells(root_node);
+  cursor-&gt;end_of_table = (num_cells == 0);

   return cursor;
 &#125;
@@ -145,24 +227,28 @@ Cursor* table_start(Table* table) &#123;
 Cursor* table_end(Table* table) &#123;
   Cursor* cursor = malloc(sizeof(Cursor));
   cursor-&gt;table = table;
-  cursor-&gt;row_num = table-&gt;num_rows;
+  cursor-&gt;page_num = table-&gt;root_page_num;
+
+  void* root_node = get_page(table-&gt;pager, table-&gt;root_page_num);
+  uint32_t num_cells = *leaf_node_num_cells(root_node);
+  cursor-&gt;cell_num = num_cells;
   cursor-&gt;end_of_table = true;

   return cursor;
 &#125;

 void* cursor_value(Cursor* cursor) &#123;
-  uint32_t row_num = cursor-&gt;row_num;
-  uint32_t page_num = row_num / ROWS_PER_PAGE;
+  uint32_t page_num = cursor-&gt;page_num;
   void* page = get_page(cursor-&gt;table-&gt;pager, page_num);
-  uint32_t row_offset = row_num % ROWS_PER_PAGE;
-  uint32_t byte_offset = row_offset * ROW_SIZE;
-  return page + byte_offset;
+  return leaf_node_value(page, cursor-&gt;cell_num);
 &#125;

 void cursor_advance(Cursor* cursor) &#123;
-  cursor-&gt;row_num += 1;
-  if (cursor-&gt;row_num &gt;= cursor-&gt;table-&gt;num_rows) &#123;
+  uint32_t page_num = cursor-&gt;page_num;
+  void* node = get_page(cursor-&gt;table-&gt;pager, page_num);
+
+  cursor-&gt;cell_num += 1;
+  if (cursor-&gt;cell_num &gt;= (*leaf_node_num_cells(node))) &#123;
     cursor-&gt;end_of_table = true;
   &#125;
 &#125;
@@ -185,6 +271,12 @@ Pager* pager_open(const char* filename) &#123;
   Pager* pager = malloc(sizeof(Pager));
   pager-&gt;file_descriptor = fd;
   pager-&gt;file_length = file_length;
+  pager-&gt;num_pages = (file_length / PAGE_SIZE);
+
+  if (file_length % PAGE_SIZE != 0) &#123;
+    printf(&quot;Db file is not a whole number of pages. Corrupt file.\n&quot;);
+    exit(EXIT_FAILURE);
+  &#125;

   for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) &#123;
     pager-&gt;pages[i] = NULL;
@@ -194,11 +285,15 @@ Pager* pager_open(const char* filename) &#123;
@@ -195,11 +287,16 @@ Pager* pager_open(const char* filename) &#123;

 Table* db_open(const char* filename) &#123;
   Pager* pager = pager_open(filename);
-  uint32_t num_rows = pager-&gt;file_length / ROW_SIZE;

   Table* table = malloc(sizeof(Table));
   table-&gt;pager = pager;
-  table-&gt;num_rows = num_rows;
+  table-&gt;root_page_num = 0;
+
+  if (pager-&gt;num_pages == 0) &#123;
+    // New database file. Initialize page 0 as leaf node.
+    void* root_node = get_page(pager, 0);
+    initialize_leaf_node(root_node);
+  &#125;

   return table;
 &#125;
@@ -234,7 +331,7 @@ void close_input_buffer(InputBuffer* input_buffer) &#123;
     free(input_buffer);
 &#125;

-void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) &#123;
+void pager_flush(Pager* pager, uint32_t page_num) &#123;
   if (pager-&gt;pages[page_num] == NULL) &#123;
     printf(&quot;Tried to flush null page\n&quot;);
     exit(EXIT_FAILURE);
@@ -242,7 +337,7 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) &#123;
@@ -249,7 +346,7 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) &#123;
   &#125;

   ssize_t bytes_written =
-      write(pager-&gt;file_descriptor, pager-&gt;pages[page_num], size);
+      write(pager-&gt;file_descriptor, pager-&gt;pages[page_num], PAGE_SIZE);

   if (bytes_written == -1) &#123;
     printf(&quot;Error writing: %d\n&quot;, errno);
@@ -252,29 +347,16 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) &#123;
@@ -260,29 +357,16 @@ void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) &#123;

 void db_close(Table* table) &#123;
   Pager* pager = table-&gt;pager;
-  uint32_t num_full_pages = table-&gt;num_rows / ROWS_PER_PAGE;

-  for (uint32_t i = 0; i &lt; num_full_pages; i++) &#123;
+  for (uint32_t i = 0; i &lt; pager-&gt;num_pages; i++) &#123;
     if (pager-&gt;pages[i] == NULL) &#123;
       continue;
     &#125;
-    pager_flush(pager, i, PAGE_SIZE);
+    pager_flush(pager, i);
     free(pager-&gt;pages[i]);
     pager-&gt;pages[i] = NULL;
   &#125;

-  // There may be a partial page to write to the end of the file
-  // This should not be needed after we switch to a B-tree
-  uint32_t num_additional_rows = table-&gt;num_rows % ROWS_PER_PAGE;
-  if (num_additional_rows &gt; 0) &#123;
-    uint32_t page_num = num_full_pages;
-    if (pager-&gt;pages[page_num] != NULL) &#123;
-      pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);
-      free(pager-&gt;pages[page_num]);
-      pager-&gt;pages[page_num] = NULL;
-    &#125;
-  &#125;
-
   int result = close(pager-&gt;file_descriptor);
   if (result == -1) &#123;
     printf(&quot;Error closing db file.\n&quot;);
@@ -305,6 +389,14 @@ MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table *table) &#123;
   if (strcmp(input_buffer-&gt;buffer, &quot;.exit&quot;) == 0) &#123;
     db_close(table);
     exit(EXIT_SUCCESS);
+  &#125; else if (strcmp(input_buffer-&gt;buffer, &quot;.btree&quot;) == 0) &#123;
+    printf(&quot;Tree:\n&quot;);
+    print_leaf_node(get_page(table-&gt;pager, 0));
+    return META_COMMAND_SUCCESS;
+  &#125; else if (strcmp(input_buffer-&gt;buffer, &quot;.constants&quot;) == 0) &#123;
+    printf(&quot;Constants:\n&quot;);
+    print_constants();
+    return META_COMMAND_SUCCESS;
   &#125; else &#123;
     return META_COMMAND_UNRECOGNIZED_COMMAND;
   &#125;
@@ -354,16 +446,39 @@ PrepareResult prepare_statement(InputBuffer* input_buffer,
   return PREPARE_UNRECOGNIZED_STATEMENT;
 &#125;

+void leaf_node_insert(Cursor* cursor, uint32_t key, Row* value) &#123;
+  void* node = get_page(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);
+
+  uint32_t num_cells = *leaf_node_num_cells(node);
+  if (num_cells &gt;= LEAF_NODE_MAX_CELLS) &#123;
+    // Node full
+    printf(&quot;Need to implement splitting a leaf node.\n&quot;);
+    exit(EXIT_FAILURE);
+  &#125;
+
+  if (cursor-&gt;cell_num &lt; num_cells) &#123;
+    // Make room for new cell
+    for (uint32_t i = num_cells; i &gt; cursor-&gt;cell_num; i--) &#123;
+      memcpy(leaf_node_cell(node, i), leaf_node_cell(node, i - 1),
+             LEAF_NODE_CELL_SIZE);
+    &#125;
+  &#125;
+
+  *(leaf_node_num_cells(node)) += 1;
+  *(leaf_node_key(node, cursor-&gt;cell_num)) = key;
+  serialize_row(value, leaf_node_value(node, cursor-&gt;cell_num));
+&#125;
+
 ExecuteResult execute_insert(Statement* statement, Table* table) &#123;
-  if (table-&gt;num_rows &gt;= TABLE_MAX_ROWS) &#123;
+  void* node = get_page(table-&gt;pager, table-&gt;root_page_num);
+  if ((*leaf_node_num_cells(node) &gt;= LEAF_NODE_MAX_CELLS)) &#123;
     return EXECUTE_TABLE_FULL;
   &#125;

   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);
   Cursor* cursor = table_end(table);

-  serialize_row(row_to_insert, cursor_value(cursor));
-  table-&gt;num_rows += 1;
+  leaf_node_insert(cursor, row_to_insert-&gt;id, row_to_insert);

   free(cursor);

And the specs:

+  it &#39;allows printing out the structure of a one-node btree&#39; do
+    script = [3, 1, 2].map do |i|
+      &quot;insert #&#123;i&#125; user#&#123;i&#125; person#&#123;i&#125;@example.com&quot;
+    end
+    script &lt;&lt; &quot;.btree&quot;
+    script &lt;&lt; &quot;.exit&quot;
+    result = run_script(script)
+
+    expect(result).to match_array([
+      &quot;db &gt; Executed.&quot;,
+      &quot;db &gt; Executed.&quot;,
+      &quot;db &gt; Executed.&quot;,
+      &quot;db &gt; Tree:&quot;,
+      &quot;leaf (size 3)&quot;,
+      &quot;  - 0 : 3&quot;,
+      &quot;  - 1 : 1&quot;,
+      &quot;  - 2 : 2&quot;,
+      &quot;db &gt; &quot;
+    ])
+  end
+
+  it &#39;prints constants&#39; do
+    script = [
+      &quot;.constants&quot;,
+      &quot;.exit&quot;,
+    ]
+    result = run_script(script)
+
+    expect(result).to match_array([
+      &quot;db &gt; Constants:&quot;,
+      &quot;ROW_SIZE: 293&quot;,
+      &quot;COMMON_NODE_HEADER_SIZE: 6&quot;,
+      &quot;LEAF_NODE_HEADER_SIZE: 10&quot;,
+      &quot;LEAF_NODE_CELL_SIZE: 297&quot;,
+      &quot;LEAF_NODE_SPACE_FOR_CELLS: 4086&quot;,
+      &quot;LEAF_NODE_MAX_CELLS: 13&quot;,
+      &quot;db &gt; &quot;,
+    ])
+  end
 end
</code></pre>
<h2 id="Part-9-Binary-Search-and-Duplicate-Keys"><a href="#Part-9-Binary-Search-and-Duplicate-Keys" class="headerlink" title="Part 9 - Binary Search and Duplicate Keys"></a>Part 9 - Binary Search and Duplicate Keys</h2><p>在上一章注意到我们仍然存储键的方式仍然是无序的.我们将要修复这个问题，外加检测和拒绝重复的键.</p>
<p>目前，函数<code>execute_insert()</code>总是选择在表的末尾插入，但我们应该在表中搜索合适的插入位置，然后插到那里.如果键值已存在，返回一个错误.</p>
<pre><code class="cpp">ExecuteResult execute_insert(Statement* statement, Table* table) &#123;
   void* node = get_page(table-&gt;pager, table-&gt;root_page_num);
-  if ((*leaf_node_num_cells(node) &gt;= LEAF_NODE_MAX_CELLS)) &#123;
+  uint32_t num_cells = (*leaf_node_num_cells(node));
+  if (num_cells &gt;= LEAF_NODE_MAX_CELLS) &#123;
     return EXECUTE_TABLE_FULL;
   &#125;

   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);
-  Cursor* cursor = table_end(table);
+  uint32_t key_to_insert = row_to_insert-&gt;id;
+  Cursor* cursor = table_find(table, key_to_insert);
+
+  if (cursor-&gt;cell_num &lt; num_cells) &#123;
+    uint32_t key_at_index = *leaf_node_key(node, cursor-&gt;cell_num);
+    if (key_at_index == key_to_insert) &#123;
+      return EXECUTE_DUPLICATE_KEY;
+    &#125;
+  &#125;

   leaf_node_insert(cursor, row_to_insert-&gt;id, row_to_insert);
</code></pre>
<p>我们不再需要函数<code>table_end()</code>了.</p>
<pre><code class="cpp">-Cursor* table_end(Table* table) &#123;
-  Cursor* cursor = malloc(sizeof(Cursor));
-  cursor-&gt;table = table;
-  cursor-&gt;page_num = table-&gt;root_page_num;
-
-  void* root_node = get_page(table-&gt;pager, table-&gt;root_page_num);
-  uint32_t num_cells = *leaf_node_num_cells(root_node);
-  cursor-&gt;cell_num = num_cells;
-  cursor-&gt;end_of_table = true;
-
-  return cursor;
-&#125;
</code></pre>
<p>我们用一个新函数代替它，该函数可以在树中搜索一个给定的key.</p>
<pre><code class="cpp">+/*
+Return the position of the given key.
+If the key is not present, return the position
+where it should be inserted
+*/
+Cursor* table_find(Table* table, uint32_t key) &#123;
+  uint32_t root_page_num = table-&gt;root_page_num;
+  void* root_node = get_page(table-&gt;pager, root_page_num);
+
+  if (get_node_type(root_node) == NODE_LEAF) &#123;
+    return leaf_node_find(table, root_page_num, key);
+  &#125; else &#123;
+    printf(&quot;Need to implement searching an internal node\n&quot;);
+    exit(EXIT_FAILURE);
+  &#125;
+&#125;
</code></pre>
<p>我预留了处理内部节点的分支，尽管我们还没有实现内部节点.不过我们现在可以用二分查找搜索叶子节点.</p>
<pre><code class="cpp">+Cursor* leaf_node_find(Table* table, uint32_t page_num, uint32_t key) &#123;
+  void* node = get_page(table-&gt;pager, page_num);
+  uint32_t num_cells = *leaf_node_num_cells(node);
+
+  Cursor* cursor = malloc(sizeof(Cursor));
+  cursor-&gt;table = table;
+  cursor-&gt;page_num = page_num;
+
+  // Binary search
+  uint32_t min_index = 0;
+  uint32_t one_past_max_index = num_cells;
+  while (one_past_max_index != min_index) &#123;
+    uint32_t index = (min_index + one_past_max_index) / 2;
+    uint32_t key_at_index = *leaf_node_key(node, index);
+    if (key == key_at_index) &#123;
+      cursor-&gt;cell_num = index;
+      return cursor;
+    &#125;
+    if (key &lt; key_at_index) &#123;
+      one_past_max_index = index;
+    &#125; else &#123;
+      min_index = index + 1;
+    &#125;
+  &#125;
+
+  cursor-&gt;cell_num = min_index;
+  return cursor;
+&#125;
</code></pre>
<p>该函数的返回值为:</p>
<ul>
<li>键对应的位置</li>
<li>另一个键的位置，如果我们想要插入新的键的话，就需要移动它，或者</li>
<li>最后一个键的后一个位置</li>
</ul>
<p>因为我们现在需要检查节点类型，所以需要一个函数去获得和设置类型值.</p>
<pre><code class="cpp">+NodeType get_node_type(void* node) &#123;
+  uint8_t value = *((uint8_t*)(node + NODE_TYPE_OFFSET));
+  return (NodeType)value;
+&#125;
+
+void set_node_type(void* node, NodeType type) &#123;
+  uint8_t value = type;
+  *((uint8_t*)(node + NODE_TYPE_OFFSET)) = value;
+&#125;
</code></pre>
<p>我们需要先转换到<code>unt8_t</code>类型以确保其被序列化为一个字节.</p>
<p>我们还需要初始化节点类型.</p>
<pre><code class="cpp">-void initialize_leaf_node(void* node) &#123; *leaf_node_num_cells(node) = 0; &#125;
+void initialize_leaf_node(void* node) &#123;
+  set_node_type(node, NODE_LEAF);
+  *leaf_node_num_cells(node) = 0;
+&#125;
</code></pre>
<p>最后，我们需要创建和处理一个新的错误码.</p>
<pre><code class="cpp">-enum ExecuteResult_t &#123; EXECUTE_SUCCESS, EXECUTE_TABLE_FULL &#125;;
+enum ExecuteResult_t &#123;
+  EXECUTE_SUCCESS,
+  EXECUTE_DUPLICATE_KEY,
+  EXECUTE_TABLE_FULL
+&#125;;

       case (EXECUTE_SUCCESS):
         printf(&quot;Executed.\n&quot;);
         break;
+      case (EXECUTE_DUPLICATE_KEY):
+        printf(&quot;Error: Duplicate key.\n&quot;);
+        break;
       case (EXECUTE_TABLE_FULL):
         printf(&quot;Error: Table full.\n&quot;);
         break;
</code></pre>
<p>通过这些改动，我们的测试可以改为检查顺序.</p>
<pre><code class="cpp">       &quot;db &gt; Executed.&quot;,
       &quot;db &gt; Tree:&quot;,
       &quot;leaf (size 3)&quot;,
-      &quot;  - 0 : 3&quot;,
-      &quot;  - 1 : 1&quot;,
-      &quot;  - 2 : 2&quot;,
+      &quot;  - 0 : 1&quot;,
+      &quot;  - 1 : 2&quot;,
+      &quot;  - 2 : 3&quot;,
       &quot;db &gt; &quot;
     ])
   end
</code></pre>
<p>然后我们可以新增一个检查重复键的测试:</p>
<pre><code class="cpp">+  it &#39;prints an error message if there is a duplicate id&#39; do
+    script = [
+      &quot;insert 1 user1 person1@example.com&quot;,
+      &quot;insert 1 user1 person1@example.com&quot;,
+      &quot;select&quot;,
+      &quot;.exit&quot;,
+    ]
+    result = run_script(script)
+    expect(result).to match_array([
+      &quot;db &gt; Executed.&quot;,
+      &quot;db &gt; Error: Duplicate key.&quot;,
+      &quot;db &gt; (1, user1, person1@example.com)&quot;,
+      &quot;Executed.&quot;,
+      &quot;db &gt; &quot;,
+    ])
+  end
</code></pre>
<p>好辣!在下一章我们将会 - 实施分裂叶子节点并且创建内部节点.</p>
</br>

<h2 id="Part-10-Splitting-a-Leaf-Node"><a href="#Part-10-Splitting-a-Leaf-Node" class="headerlink" title="Part 10 - Splitting a Leaf Node"></a>Part 10 - Splitting a Leaf Node</h2><p>我们的B-Tree不太像一个树，因为只有一个节点.为了修复这个问题，我们需要一些代码来将一个叶子节点分裂成双胞胎.在这之后,我们需要创建一个内部节点作为两个叶子节点的父节点.</p>
<p>本章目标基本上是从这样:</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree2.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree2.png" alt="one-node btree"></a></p>
<p>到这样:</p>
<p>two-level btree</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree3.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree3.png" alt="two-level btree"></a></p>
<p>首先让我们移除叶子节点已满的错误处理:</p>
<pre><code class="cpp"> void leaf_node_insert(Cursor* cursor, uint32_t key, Row* value) &#123;
   void* node = get_page(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);
 
   uint32_t num_cells = *leaf_node_num_cells(node);
   if (num_cells &gt;= LEAF_NODE_MAX_CELLS) &#123;
     // Node full
-    printf(&quot;Need to implement splitting a leaf node.\n&quot;);
-    exit(EXIT_FAILURE);
+    leaf_node_split_and_insert(cursor, key, value);
+    return;
   &#125;

ExecuteResult execute_insert(Statement* statement, Table* table) &#123;
   void* node = get_page(table-&gt;pager, table-&gt;root_page_num);
   uint32_t num_cells = (*leaf_node_num_cells(node));
-  if (num_cells &gt;= LEAF_NODE_MAX_CELLS) &#123;
-    return EXECUTE_TABLE_FULL;
-  &#125;
 
   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);
   uint32_t key_to_insert = row_to_insert-&gt;id;
</code></pre>
<h3 id="Splitting-Algorithm"><a href="#Splitting-Algorithm" class="headerlink" title="Splitting Algorithm"></a>Splitting Algorithm</h3><p>简单的部分结束了,<a target="_blank" rel="noopener" href="https://play.google.com/store/books/details/Sibsankar_Haldar_SQLite_Database_System_Design_and?id=9Z6IQQnX1JEC&amp;hl=en">SQLite Database System: Design and Implementation</a>里面描述了我们接下来要做的事情</p>
<blockquote>
<p>如果叶子节点没有剩余空间了，我们应该将叶子节点已有的记录和新的记录(待插入的那个)分成两个等长的部分:下半部分和上半部分(上半部分的所有键都严格大于下半部分的键.)然后创建一个新的叶子节点，然后上半部分移动到叶子节点里.</p>
</blockquote>
<p>让我们来处理旧的节点然后创建一个新的节点.</p>
<pre><code class="cpp">+void leaf_node_split_and_insert(Cursor* cursor, uint32_t key, Row* value) &#123;
+  /*
+  Create a new node and move half the cells over.
+  Insert the new value in one of the two nodes.
+  Update parent or create a new parent.
+  */
+
+  void* old_node = get_page(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);
+  uint32_t new_page_num = get_unused_page_num(cursor-&gt;table-&gt;pager);
+  void* new_node = get_page(cursor-&gt;table-&gt;pager, new_page_num);
+  initialize_leaf_node(new_node);
</code></pre>
<p>然后，拷贝每个cell到新的位置:</p>
<pre><code class="cpp">+  /*
+  All existing keys plus new key should be divided
+  evenly between old (left) and new (right) nodes.
+  Starting from the right, move each key to correct position.
+  */
+  for (int32_t i = LEAF_NODE_MAX_CELLS; i &gt;= 0; i--) &#123;
+    void* destination_node;
+    if (i &gt;= LEAF_NODE_LEFT_SPLIT_COUNT) &#123;
+      destination_node = new_node;
+    &#125; else &#123;
+      destination_node = old_node;
+    &#125;
+    uint32_t index_within_node = i % LEAF_NODE_LEFT_SPLIT_COUNT;
+    void* destination = leaf_node_cell(destination_node, index_within_node);
+
+    if (i == cursor-&gt;cell_num) &#123;
+      serialize_row(value, destination);
+    &#125; else if (i &gt; cursor-&gt;cell_num) &#123;
+      memcpy(destination, leaf_node_cell(old_node, i - 1), LEAF_NODE_CELL_SIZE);
+    &#125; else &#123;
+      memcpy(destination, leaf_node_cell(old_node, i), LEAF_NODE_CELL_SIZE);
+    &#125;
+  &#125;
</code></pre>
<p>然后我们需要更新两个叶子节点的父节点.如果原节点(即被分裂的叶子节点)是根节点,也就是没有父节点.在这种情况下，创建一个新的根节点作为父节点,目前我们暂时不实现更新父节点的操作:</p>
<pre><code class="cpp">+  if (is_node_root(old_node)) &#123;
+    return create_new_root(cursor-&gt;table, new_page_num);
+  &#125; else &#123;
+    printf(&quot;Need to implement updating parent after split\n&quot;);
+    exit(EXIT_FAILURE);
+  &#125;
+&#125;
</code></pre>
<h3 id="Allocating-New-Pages"><a href="#Allocating-New-Pages" class="headerlink" title="Allocating New Pages"></a>Allocating New Pages</h3><p>让我们回去定义一些新的函数和常量.当我们创建一个新的叶子节点时，我们把它放进由函数<code>get_ununsed_page_num()</code>指定的页中:</p>
<pre><code class="cpp">+/*
+Until we start recycling free pages, new pages will always
+go onto the end of the database file
+*/
+uint32_t get_unused_page_num(Pager* pager) &#123; return pager-&gt;num_pages; &#125;
</code></pre>
<p>目前，我们假设数据库有N页，page下标从0到N-1已被分配.所以我们可以分配下标N给新的页.最终在我们执行了删除操作之后，一些页可能是空的并且它们的页下标未被使用，为了提高效率，我们可以重新分配那些空的页.</p>
<h3 id="Leaf-Node-Sizes"><a href="#Leaf-Node-Sizes" class="headerlink" title="Leaf Node Sizes"></a>Leaf Node Sizes</h3><p>为了保持树的平衡，我们将cells平均分配到两个新的节点中.如果一个叶子节点可以保存N个cell,那么在分裂中我们需要分配N+1个cell到两个节点中(N个原cell外加一个待插入的新cell).我决定给<strong>左边</strong>的节点<strong>多分配一个cell</strong>,如果N+1是奇数的话.</p>
<pre><code class="cpp">+const uint32_t LEAF_NODE_RIGHT_SPLIT_COUNT = (LEAF_NODE_MAX_CELLS + 1) / 2;
+const uint32_t LEAF_NODE_LEFT_SPLIT_COUNT =
+    (LEAF_NODE_MAX_CELLS + 1) - LEAF_NODE_RIGHT_SPLIT_COUNT;
</code></pre>
<h3 id="Creating-a-New-Root"><a href="#Creating-a-New-Root" class="headerlink" title="Creating a New Root"></a>Creating a New Root</h3><p>这里<a target="_blank" rel="noopener" href="https://play.google.com/store/books/details/Sibsankar_Haldar_SQLite_Database_System_Design_and?id=9Z6IQQnX1JEC&amp;hl=en">SQLite Database System</a>阐释了创建一个新的根节点的过程:</p>
<blockquote>
<p>让<code>N</code>变为根节点.首先分配两个节点，叫做<code>L</code>和<code>R</code>.移动N的下半部分元素到L,上半部分元素到R.然后现在N就是空的了.</p>
<p>在N中增加<code>&lt;L,K,R&gt;</code>，<code>K</code>是<code>L</code>中最大的键.第N页也仍然是根节点.注意树的深度增加了1,但是新的树在不违背任何B+tree属性的情况下保持了高度平衡.</p>
</blockquote>
<p>目前，我们已经创建了右孩子并且把上半部分元素移入其中.我们的函数将右孩子作为参数，然后分配一个新的页来存储左孩子.</p>
<pre><code class="cpp">+void create_new_root(Table* table, uint32_t right_child_page_num) &#123;
+  /*
+  Handle splitting the root.
+  Old root copied to new page, becomes left child.
+  Address of right child passed in.
+  Re-initialize root page to contain the new root node.
+  New root node points to two children.
+  */
+
+  void* root = get_page(table-&gt;pager, table-&gt;root_page_num);
+  void* right_child = get_page(table-&gt;pager, right_child_page_num);
+  uint32_t left_child_page_num = get_unused_page_num(table-&gt;pager);
+  void* left_child = get_page(table-&gt;pager, left_child_page_num);
</code></pre>
<p>原根节点的数据被拷贝进了左孩子,然后我们就能重新使用该页作为根节点了.</p>
<pre><code class="cpp">+  /* Left child has data copied from old root */
+  memcpy(left_child, root, PAGE_SIZE);
+  set_node_root(left_child, false);
</code></pre>
<p>最后我们需要将<strong>原根节点</strong>对应的页初始化为一个新的有两个孩子的<strong>内部节点</strong>.</p>
<pre><code class="cpp">+  /* Root node is a new internal node with one key and two children */
+  initialize_internal_node(root);
+  set_node_root(root, true);
+  *internal_node_num_keys(root) = 1;
+  *internal_node_child(root, 0) = left_child_page_num;
+  uint32_t left_child_max_key = get_node_max_key(left_child);
+  *internal_node_key(root, 0) = left_child_max_key;
+  *internal_node_right_child(root) = right_child_page_num;
+&#125;
</code></pre>
<h3 id="Internal-Node-Format"><a href="#Internal-Node-Format" class="headerlink" title="Internal Node Format"></a>Internal Node Format</h3><p>现在我们终于要创建一个内部节点了,我们要先定义它的布局.</p>
<p>内部节点以普通节点头部开始，然后是它包含的键的数量，然后是它的最右边节点的page number.内部节点存储的指向子节点的指针总是比键的数量多一个.那个额外的子节点指针存储在头部.</p>
<pre><code class="cpp">+/*
+ * Internal Node Header Layout
+ */
+const uint32_t INTERNAL_NODE_NUM_KEYS_SIZE = sizeof(uint32_t);
+const uint32_t INTERNAL_NODE_NUM_KEYS_OFFSET = COMMON_NODE_HEADER_SIZE;
+const uint32_t INTERNAL_NODE_RIGHT_CHILD_SIZE = sizeof(uint32_t);
+const uint32_t INTERNAL_NODE_RIGHT_CHILD_OFFSET =
+    INTERNAL_NODE_NUM_KEYS_OFFSET + INTERNAL_NODE_NUM_KEYS_SIZE;
+const uint32_t INTERNAL_NODE_HEADER_SIZE = COMMON_NODE_HEADER_SIZE +
+                                           INTERNAL_NODE_NUM_KEYS_SIZE +
+                                           INTERNAL_NODE_RIGHT_CHILD_SIZE;
</code></pre>
<p>body是一个存储cell的数组，每个cell包含一个指向子节点的指针和键.每个键应该是该键左边的子节点中的最大的键值.</p>
<pre><code class="cpp">+/*
+ * Internal Node Body Layout
+ */
+const uint32_t INTERNAL_NODE_KEY_SIZE = sizeof(uint32_t);
+const uint32_t INTERNAL_NODE_CHILD_SIZE = sizeof(uint32_t);
+const uint32_t INTERNAL_NODE_CELL_SIZE =
+    INTERNAL_NODE_CHILD_SIZE + INTERNAL_NODE_KEY_SIZE;
</code></pre>
<p>基于这些常量,内部节点的布局应该长这样:</p>
<p>Our internal node format</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/internal-node-format.png"><img src="https://cstack.github.io/db_tutorial/assets/images/internal-node-format.png" alt="内部节点布局"></a></p>
<p>Notice our huge branching factor(不知道咋翻译…).因为每个<code>子节点指针&amp;键</code>组合相当小，每个内部节点可以存储510个键和511个孩子指针.这意味着我们几乎不会需要遍历树的很多层来找到一个给定的键值.</p>
<table id="table">
<thead>
<tr>
<th># 内部节点层数</th>
<th>最多 # 叶子节点</th>
<th>所有叶子节点的总大小</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>511^0&#x3D;1</td>
<td>4KB</td>
</tr>
<tr>
<td>1</td>
<td>511^1&#x3D;512</td>
<td>~ 2MB</td>
</tr>
<tr>
<td>2</td>
<td>511^2&#x3D;261,121</td>
<td>~ 1GB</td>
</tr>
<tr>
<td>3</td>
<td>511^3&#x3D;133,432,831</td>
<td>~ 550GB</td>
</tr>
</tbody></table>

<p>实际上，每个叶子节点不可能将4KB全部用来存储数据,因为还需要存储头部信息,键,还有一些空间被浪费了.但是我们只需要从磁盘中加载4页数据就可以搜索500GB的数据.这就是为什么B-Tree这个数据结构非常适合数据库.</p>
<p>这里有一些函数用来想内部节点读写数据:</p>
<pre><code class="cpp">+uint32_t* internal_node_num_keys(void* node) &#123;
+  return node + INTERNAL_NODE_NUM_KEYS_OFFSET;
+&#125;
+
+uint32_t* internal_node_right_child(void* node) &#123;
+  return node + INTERNAL_NODE_RIGHT_CHILD_OFFSET;
+&#125;
+
+uint32_t* internal_node_cell(void* node, uint32_t cell_num) &#123;
+  return node + INTERNAL_NODE_HEADER_SIZE + cell_num * INTERNAL_NODE_CELL_SIZE;
+&#125;
+
+uint32_t* internal_node_child(void* node, uint32_t child_num) &#123;
+  uint32_t num_keys = *internal_node_num_keys(node);
+  if (child_num &gt; num_keys) &#123;
+    printf(&quot;Tried to access child_num %d &gt; num_keys %d\n&quot;, child_num, num_keys);
+    exit(EXIT_FAILURE);
+  &#125; else if (child_num == num_keys) &#123;
+    return internal_node_right_child(node);
+  &#125; else &#123;
+    return internal_node_cell(node, child_num);
+  &#125;
+&#125;
+
+uint32_t* internal_node_key(void* node, uint32_t key_num) &#123;
+  return (uint32_t* )((unsigned char* )internal_node_cell(node,key_num)+INTERNAL_NODE_CHILD_SIZE);
+&#125;
</code></pre>
<blockquote>
<p id="fixBug1"></p>译者注: 函数`internal_node_key()`的返回值原文为

<p><code>return internal_node_cell(node, key_num) + INTERNAL_NODE_CHILD_SIZE;</code></p>
<p>但是<code>internal_node_cell()</code>函数返回值是<strong>4字节</strong>int指针,所以指针算数运算的单位为4个字节,需要<strong>先转换为单字节指针</strong>然后再加上偏移量</p>
</blockquote>
<p>对于一个内部节点，最大的key总是它的最右边的key.对于一个叶子节点,最大的key的下标最大:</p>
<pre><code class="cpp">+uint32_t get_node_max_key(void* node) &#123;
+  switch (get_node_type(node)) &#123;
+    case NODE_INTERNAL:
+      return *internal_node_key(node, *internal_node_num_keys(node) - 1);
+    case NODE_LEAF:
+      return *leaf_node_key(node, *leaf_node_num_cells(node) - 1);
+  &#125;
+&#125;
</code></pre>
<h3 id="Keeping-Track-of-the-Root"><a href="#Keeping-Track-of-the-Root" class="headerlink" title="Keeping Track of the Root"></a>Keeping Track of the Root</h3><p>我们最后利用的是普通节点头部的<code>is_root</code>值.</p>
<p>记得我们使用它来决定如何分裂一个叶子节点的:</p>
<pre><code class="cpp">  if (is_node_root(old_node)) &#123;
    return create_new_root(cursor-&gt;table, new_page_num);
  &#125; else &#123;
    printf(&quot;Need to implement updating parent after split\n&quot;);
    exit(EXIT_FAILURE);
  &#125;
&#125;
</code></pre>
<p>这里有<code>getter &amp; setter</code>:</p>
<pre><code class="cpp">+bool is_node_root(void* node) &#123;
+  uint8_t value = *((uint8_t*)(node + IS_ROOT_OFFSET));
+  return (bool)value;
+&#125;
+
+void set_node_root(void* node, bool is_root) &#123;
+  uint8_t value = is_root;
+  *((uint8_t*)(node + IS_ROOT_OFFSET)) = value;
+&#125;
</code></pre>
<p>初始化每种节点都应该默认设置<code>is_root</code>为false:</p>
<pre><code class="cpp"> void initialize_leaf_node(void* node) &#123;
   set_node_type(node, NODE_LEAF);
+  set_node_root(node, false);
   *leaf_node_num_cells(node) = 0;
 &#125;

+void initialize_internal_node(void* node) &#123;
+  set_node_type(node, NODE_INTERNAL);
+  set_node_root(node, false);
+  *internal_node_num_keys(node) = 0;
+&#125;
</code></pre>
<p>我们应该在创建的节点为table中的第一个节点时设置<code>is_root</code>为true:</p>
<pre><code class="cpp">     // New database file. Initialize page 0 as leaf node.
     void* root_node = get_page(pager, 0);
     initialize_leaf_node(root_node);
+    set_node_root(root_node, true);
   &#125;
 
   return table;
</code></pre>
</br>

<h3 id="Printing-the-Tree"><a href="#Printing-the-Tree" class="headerlink" title="Printing the Tree"></a>Printing the Tree</h3><p>为了帮助我们可视化数据库的状态,我们应该更新<code>.btree</code>命令以打印一棵多阶树.</p>
<p>我将会替换现有的<code>print_leaf_node()</code>函数:</p>
<pre><code class="cpp">-void print_leaf_node(void* node) &#123;
-  uint32_t num_cells = *leaf_node_num_cells(node);
-  printf(&quot;leaf (size %d)\n&quot;, num_cells);
-  for (uint32_t i = 0; i &lt; num_cells; i++) &#123;
-    uint32_t key = *leaf_node_key(node, i);
-    printf(&quot;  - %d : %d\n&quot;, i, key);
-  &#125;
-&#125;
</code></pre>
<p>用一个递归函数代替它.递归函数接受一个任意节点作为参数，然后打印该节点和所有子节点.还接受一个参数作为缩进等级,在向下递归的时候缩进等级递增.我还添加了一个小的辅助函数用于打印缩进.</p>
<pre><code class="cpp">+void indent(uint32_t level) &#123;
+  for (uint32_t i = 0; i &lt; level; i++) &#123;
+    printf(&quot;  &quot;);
+  &#125;
+&#125;
+
+void print_tree(Pager* pager, uint32_t page_num, uint32_t indentation_level) &#123;
+  void* node = get_page(pager, page_num);
+  uint32_t num_keys, child;
+
+  switch (get_node_type(node)) &#123;
+    case (NODE_LEAF):
+      num_keys = *leaf_node_num_cells(node);
+      indent(indentation_level);
+      printf(&quot;- leaf (size %d)\n&quot;, num_keys);
+      for (uint32_t i = 0; i &lt; num_keys; i++) &#123;
+        indent(indentation_level + 1);
+        printf(&quot;- %d\n&quot;, *leaf_node_key(node, i));
+      &#125;
+      break;
+    case (NODE_INTERNAL):
+      num_keys = *internal_node_num_keys(node);
+      indent(indentation_level);
+      printf(&quot;- internal (size %d)\n&quot;, num_keys);
+      for (uint32_t i = 0; i &lt; num_keys; i++) &#123;
+        child = *internal_node_child(node, i);
+        print_tree(pager, child, indentation_level + 1);
+
+        indent(indentation_level + 1);
+        printf(&quot;- key %d\n&quot;, *internal_node_key(node, i));
+      &#125;
+      child = *internal_node_right_child(node);
+      print_tree(pager, child, indentation_level + 1);
+      break;
+  &#125;
+&#125;
</code></pre>
<p>然后更新<code>.btree</code>调用的函数,一开始传递的缩进等级为0.</p>
<pre><code class="cpp">   &#125; else if (strcmp(input_buffer-&gt;buffer, &quot;.btree&quot;) == 0) &#123;
     printf(&quot;Tree:\n&quot;);
-    print_leaf_node(get_page(table-&gt;pager, 0));
+    print_tree(table-&gt;pager, 0, 0);
     return META_COMMAND_SUCCESS;
</code></pre>
<p>这里有测试新的打印函数的代码喔!</p>
<pre><code class="cpp">+  it &#39;allows printing out the structure of a 3-leaf-node btree&#39; do
+    script = (1..14).map do |i|
+      &quot;insert #&#123;i&#125; user#&#123;i&#125; person#&#123;i&#125;@example.com&quot;
+    end
+    script &lt;&lt; &quot;.btree&quot;
+    script &lt;&lt; &quot;insert 15 user15 person15@example.com&quot;
+    script &lt;&lt; &quot;.exit&quot;
+    result = run_script(script)
+
+    expect(result[14...(result.length)]).to match_array([
+      &quot;db &gt; Tree:&quot;,
+      &quot;- internal (size 1)&quot;,
+      &quot;  - leaf (size 7)&quot;,
+      &quot;    - 1&quot;,
+      &quot;    - 2&quot;,
+      &quot;    - 3&quot;,
+      &quot;    - 4&quot;,
+      &quot;    - 5&quot;,
+      &quot;    - 6&quot;,
+      &quot;    - 7&quot;,
+      &quot;  - key 7&quot;,
+      &quot;  - leaf (size 7)&quot;,
+      &quot;    - 8&quot;,
+      &quot;    - 9&quot;,
+      &quot;    - 10&quot;,
+      &quot;    - 11&quot;,
+      &quot;    - 12&quot;,
+      &quot;    - 13&quot;,
+      &quot;    - 14&quot;,
+      &quot;db &gt; Need to implement searching an internal node&quot;,
+    ])
+  end
</code></pre>
<p>打印的内容被简化了,所以我们需要更新一下之前的<code>.btree</code>测试:</p>
<pre><code class="cpp">       &quot;db &gt; Executed.&quot;,
       &quot;db &gt; Executed.&quot;,
       &quot;db &gt; Tree:&quot;,
-      &quot;leaf (size 3)&quot;,
-      &quot;  - 0 : 1&quot;,
-      &quot;  - 1 : 2&quot;,
-      &quot;  - 2 : 3&quot;,
+      &quot;- leaf (size 3)&quot;,
+      &quot;  - 1&quot;,
+      &quot;  - 2&quot;,
+      &quot;  - 3&quot;,
       &quot;db &gt; &quot;
     ])
   end
</code></pre>
<p>这是<code>.btree</code>测试的输出:</p>
<pre><code>Tree:
- internal (size 1)
  - leaf (size 7)
    - 1
    - 2
    - 3
    - 4
    - 5
    - 6
    - 7
  - key 7
  - leaf (size 7)
    - 8
    - 9
    - 10
    - 11
    - 12
    - 13
    - 14
</code></pre>
<p>在缩进级别0，我们看到了根节点(这是个内部节点喔).<code>size 1</code>表示它只有一个键.在缩进级别1,有一个叶子节点,一个键和另一个叶子节点.在根节点的键(7)是它的第一个左孩子的最大的键.所有比7大的键在第二个叶子节点里.</p>
<h3 id="A-Major-Problem"><a href="#A-Major-Problem" class="headerlink" title="A Major Problem"></a>A Major Problem</h3><p>如果你观察仔细的话就会注意到我们忽略了很重要的事情.当我们尝试再插入一行时会变成这样:</p>
<pre><code>db &gt; insert 15 user15 person15@example.com
Need to implement searching an internal node
</code></pre>
<p>哎呀!谁写下的TODO信息? :P 😤😤</p>
<p>在下一章我们会继续B-tree的传奇，实现在一个多阶树中搜索.</p>
</br>

<h2 id="Part-11-Recursively-Searching-the-B-Tree"><a href="#Part-11-Recursively-Searching-the-B-Tree" class="headerlink" title="Part 11 -Recursively Searching the B-Tree"></a>Part 11 -Recursively Searching the B-Tree</h2><p>上一章结尾我们插入第15行得到了一个错误:</p>
<pre><code class="cpp">db &gt; insert 15 user15 person15@example.com
Need to implement searching an internal node
</code></pre>
<p>首先，用一个新的函数调用替换代码存根.</p>
<pre><code class="cpp">   if (get_node_type(root_node) == NODE_LEAF) &#123;
     return leaf_node_find(table, root_page_num, key);
   &#125; else &#123;
-    printf(&quot;Need to implement searching an internal node\n&quot;);
-    exit(EXIT_FAILURE);
+    return internal_node_find(table, root_page_num, key);
   &#125;
 &#125;
</code></pre>
<p>该函数会用二分查找包含给定key的子节点.记住每个子节点指针的右边的key是该子节点包含的最大的key.</p>
<p>three-level btree</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree6.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree6.png" alt="three-level btree"></a></p>
<p>所以我们的二分查找会比较需要找到的key和子节点指针右边的key:</p>
<pre><code class="cpp">+Cursor* internal_node_find(Table* table, uint32_t page_num, uint32_t key) &#123;
+  void* node = get_page(table-&gt;pager, page_num);
+  uint32_t num_keys = *internal_node_num_keys(node);
+
+  /* Binary search to find index of child to search */
+  uint32_t min_index = 0;
+  uint32_t max_index = num_keys; /* there is one more child than key */
+
+  while (min_index != max_index) &#123;
+    uint32_t index = (min_index + max_index) / 2;
+    uint32_t key_to_right = *internal_node_key(node, index);
+    if (key_to_right &gt;= key) &#123;
+      max_index = index;
+    &#125; else &#123;
+      min_index = index + 1;
+    &#125;
+  &#125;
</code></pre>
<p>还要记住一个内部节点的子节点可能是叶子节点或者内部节点.在我们找到正确的孩子后,要调用恰当的搜索函数:</p>
<pre><code class="cpp">+  uint32_t child_num = *internal_node_child(node, min_index);
+  void* child = get_page(table-&gt;pager, child_num);
+  switch (get_node_type(child)) &#123;
+    case NODE_LEAF:
+      return leaf_node_find(table, child_num, key);
+    case NODE_INTERNAL:
+      return internal_node_find(table, child_num, key);
+  &#125;
+&#125;
</code></pre>
<blockquote>
<p>译者注: 还有一个地方需要修改-<code>execute_insert</code></p>
<p><img src="https://gitee.com/salt3dfish/images/raw/master/hexo/22-04-30/dedd9d12883cad9c4047e8b84fead216.png" alt="image-20220430155156393"></p>
<p>因为现在搜索后的<code>cursor</code>不一定指向根节点，所以node应该是cursor指向的节点</p>
</blockquote>
<h3 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h3><p>现在向多节点btree中插入键不再会导致错误了.然后我们可以更新下我们的测试:</p>
<pre><code>       &quot;    - 12&quot;,
       &quot;    - 13&quot;,
       &quot;    - 14&quot;,
-      &quot;db &gt; Need to implement searching an internal node&quot;,
+      &quot;db &gt; Executed.&quot;,
+      &quot;db &gt; &quot;,
     ])
   end
</code></pre>
<p>我认为还可以重用一下另一个测试,就是那个试图插入1400行的.它仍然会出错，但是错误信息变了.目前该测试在程序中断的时候不能很好地处理.如果程序崩溃了，我们只需要使用目前使用的错误信息:</p>
<pre><code class="rust">     raw_output = nil
     IO.popen(&quot;./db test.db&quot;, &quot;r+&quot;) do |pipe|
       commands.each do |command|
-        pipe.puts command
+        begin
+          pipe.puts command
+        rescue Errno::EPIPE
+          break
+        end
       end

       pipe.close_write
</code></pre>
<p>然后这揭露了1400行测试的错误信息是这个:</p>
<pre><code class="rust">     end
     script &lt;&lt; &quot;.exit&quot;
     result = run_script(script)
-    expect(result[-2]).to eq(&#39;db &gt; Error: Table full.&#39;)
+    expect(result.last(2)).to match_array([
+      &quot;db &gt; Executed.&quot;,
+      &quot;db &gt; Need to implement updating parent after split&quot;,
+    ])
   end
</code></pre>
<p>这看起来好像是我们to-do列表的下一个目标!</p>
</br>



<h2 id="Part-12-Scanning-a-Multi-Level-B-Tree"><a href="#Part-12-Scanning-a-Multi-Level-B-Tree" class="headerlink" title="Part 12 -Scanning a Multi-Level B-Tree"></a>Part 12 -Scanning a Multi-Level B-Tree</h2><p>目前我们的数据库程序支持构建多阶btree,但是我们在这个过程中破坏了<code>select</code>语句.这里有一个测试插入15行然后尝试打印它们.</p>
<pre><code class="cpp">+  it &#39;prints all rows in a multi-level tree&#39; do
+    script = []
+    (1..15).each do |i|
+      script &lt;&lt; &quot;insert #&#123;i&#125; user#&#123;i&#125; person#&#123;i&#125;@example.com&quot;
+    end
+    script &lt;&lt; &quot;select&quot;
+    script &lt;&lt; &quot;.exit&quot;
+    result = run_script(script)
+
+    expect(result[15...result.length]).to match_array([
+      &quot;db &gt; (1, user1, person1@example.com)&quot;,
+      &quot;(2, user2, person2@example.com)&quot;,
+      &quot;(3, user3, person3@example.com)&quot;,
+      &quot;(4, user4, person4@example.com)&quot;,
+      &quot;(5, user5, person5@example.com)&quot;,
+      &quot;(6, user6, person6@example.com)&quot;,
+      &quot;(7, user7, person7@example.com)&quot;,
+      &quot;(8, user8, person8@example.com)&quot;,
+      &quot;(9, user9, person9@example.com)&quot;,
+      &quot;(10, user10, person10@example.com)&quot;,
+      &quot;(11, user11, person11@example.com)&quot;,
+      &quot;(12, user12, person12@example.com)&quot;,
+      &quot;(13, user13, person13@example.com)&quot;,
+      &quot;(14, user14, person14@example.com)&quot;,
+      &quot;(15, user15, person15@example.com)&quot;,
+      &quot;Executed.&quot;, &quot;db &gt; &quot;,
+    ])
+  end
</code></pre>
<p>但是当我们运行这个测试的时候，实际上会发生这个:</p>
<pre><code>db &gt; select
(2, user1, person1@example.com)
Executed.
</code></pre>
<p>这很奇怪不是阿木.它只打印了一行数据，并且该行看起来已经损坏了(注意id和username不匹配).</p>
<p>产生这个问题的原因是<code>execute_select()</code>从table的开头开始,然后我们当前的<code>table_start()</code>函数返回的是根节点的下标为0的cell.但是我们的btree的根节点现在是一个内部节点，不包含任何行.所以打印出来的数据一定是从根节点还是叶子节点的时候留下来的.<code>execute_select()</code>真正应该返回的是最左边叶子节点的下标为0的cell.</p>
<p>所以让我们先清除旧的实现:</p>
<pre><code class="cpp">-Cursor* table_start(Table* table) &#123;
-  Cursor* cursor = malloc(sizeof(Cursor));
-  cursor-&gt;table = table;
-  cursor-&gt;page_num = table-&gt;root_page_num;
-  cursor-&gt;cell_num = 0;
-
-  void* root_node = get_page(table-&gt;pager, table-&gt;root_page_num);
-  uint32_t num_cells = *leaf_node_num_cells(root_node);
-  cursor-&gt;end_of_table = (num_cells == 0);
-
-  return cursor;
-&#125;
</code></pre>
<p>然后添加新的实现，搜索key<sub>0</sub>(可能的最小key).即使key<sub>0</sub>在表中不存在,该函数会返回最小的id的位置(最左边的叶子节点的开头).</p>
<pre><code class="cpp">+Cursor* table_start(Table* table) &#123;
+  Cursor* cursor =  table_find(table, 0);
+
+  void* node = get_page(table-&gt;pager, cursor-&gt;page_num);
+  uint32_t num_cells = *leaf_node_num_cells(node);
+  cursor-&gt;end_of_table = (num_cells == 0);
+
+  return cursor;
+&#125;
</code></pre>
<p>通过这些改动，它仍然只打印一个叶子节点的所有行:</p>
<pre><code>db &gt; select
(1, user1, person1@example.com)
(2, user2, person2@example.com)
(3, user3, person3@example.com)
(4, user4, person4@example.com)
(5, user5, person5@example.com)
(6, user6, person6@example.com)
(7, user7, person7@example.com)
Executed.
db &gt;
</code></pre>
<p>因为一共有15条记录,我们的btree包含一个内部节点和两个叶子节点，就像这样:</p>
<p>structure of our btree</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree3.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree3.png" alt="structure of our btree"></a></p>
<p>为了扫描整个表,当我们到达第一个叶子节点的末尾后需要跳到第二个叶子节点.为了实现这个操作，我们将在叶子节点的头部存储一个新的字段 - “next_leaf”,该字段的值为该叶子节点的右边的兄弟节点的page number.最右边的叶子节点的<code>next_leaf</code>的值为0以表示它没有右兄弟(page<sub>0</sub>不论何时都预留给表的根节点).</p>
<p>更新叶子节点的头部格式以包含新的字段:</p>
<pre><code class="cpp"> const uint32_t LEAF_NODE_NUM_CELLS_SIZE = sizeof(uint32_t);
 const uint32_t LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;
-const uint32_t LEAF_NODE_HEADER_SIZE =
-    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;
+const uint32_t LEAF_NODE_NEXT_LEAF_SIZE = sizeof(uint32_t);
+const uint32_t LEAF_NODE_NEXT_LEAF_OFFSET =
+    LEAF_NODE_NUM_CELLS_OFFSET + LEAF_NODE_NUM_CELLS_SIZE;
+const uint32_t LEAF_NODE_HEADER_SIZE = COMMON_NODE_HEADER_SIZE +
+                                       LEAF_NODE_NUM_CELLS_SIZE +
+                                       LEAF_NODE_NEXT_LEAF_SIZE;
</code></pre>
<p>以及一个函数用来获取该字段:</p>
<pre><code class="cpp">+uint32_t* leaf_node_next_leaf(void* node) &#123;
+  return node + LEAF_NODE_NEXT_LEAF_OFFSET;
+&#125;
</code></pre>
<p>初始化一个新的叶子节点时令<code>next_leaf</code>为0：</p>
<pre><code class="cpp">@@ -322,6 +330,7 @@ void initialize_leaf_node(void* node) &#123;
   set_node_type(node, NODE_LEAF);
   set_node_root(node, false);
   *leaf_node_num_cells(node) = 0;
+  *leaf_node_next_leaf(node) = 0;  // 0 represents no sibling
 &#125;
</code></pre>
<p>当我们分裂一个叶子节点时,更新兄弟指针.旧的叶子节点的兄弟变成了新创建的叶子,然后新的叶子节点的兄弟是旧叶子节点的原兄弟,无论原兄弟是什么.</p>
<pre><code class="cpp">@@ -659,6 +671,8 @@ void leaf_node_split_and_insert(Cursor* cursor, uint32_t key, Row* value) &#123;
   uint32_t new_page_num = get_unused_page_num(cursor-&gt;table-&gt;pager);
   void* new_node = get_page(cursor-&gt;table-&gt;pager, new_page_num);
   initialize_leaf_node(new_node);
+  *leaf_node_next_leaf(new_node) = *leaf_node_next_leaf(old_node);
+  *leaf_node_next_leaf(old_node) = new_page_num;
</code></pre>
<p>增加一个新的字段会改变一些常量:</p>
<pre><code>   it &#39;prints constants&#39; do
     script = [
       &quot;.constants&quot;,
@@ -199,9 +228,9 @@ describe &#39;database&#39; do
       &quot;db &gt; Constants:&quot;,
       &quot;ROW_SIZE: 293&quot;,
       &quot;COMMON_NODE_HEADER_SIZE: 6&quot;,
-      &quot;LEAF_NODE_HEADER_SIZE: 10&quot;,
+      &quot;LEAF_NODE_HEADER_SIZE: 14&quot;,
       &quot;LEAF_NODE_CELL_SIZE: 297&quot;,
-      &quot;LEAF_NODE_SPACE_FOR_CELLS: 4086&quot;,
+      &quot;LEAF_NODE_SPACE_FOR_CELLS: 4082&quot;,
       &quot;LEAF_NODE_MAX_CELLS: 13&quot;,
       &quot;db &gt; &quot;,
     ])
</code></pre>
<p>现在无论何时我们想要cursor从一个叶子节点的末尾前进,我们可以检查该叶子节点是否有兄弟.如果有就跳到它那里,没有的话就意味着我们就到达了表的末尾.</p>
<pre><code class="cpp">@@ -428,7 +432,15 @@ void cursor_advance(Cursor* cursor) &#123;
 
   cursor-&gt;cell_num += 1;
   if (cursor-&gt;cell_num &gt;= (*leaf_node_num_cells(node))) &#123;
-    cursor-&gt;end_of_table = true;
+    /* Advance to next leaf node */
+    uint32_t next_page_num = *leaf_node_next_leaf(node);
+    if (next_page_num == 0) &#123;
+      /* This was rightmost leaf */
+      cursor-&gt;end_of_table = true;
+    &#125; else &#123;
+      cursor-&gt;page_num = next_page_num;
+      cursor-&gt;cell_num = 0;
+    &#125;
   &#125;
 &#125;
</code></pre>
<p>做了这些改动之后，我们雀食打印了15行了喔…</p>
<pre><code>db &gt; select
(1, user1, person1@example.com)
(2, user2, person2@example.com)
(3, user3, person3@example.com)
(4, user4, person4@example.com)
(5, user5, person5@example.com)
(6, user6, person6@example.com)
(7, user7, person7@example.com)
(8, user8, person8@example.com)
(9, user9, person9@example.com)
(10, user10, person10@example.com)
(11, user11, person11@example.com)
(12, user12, person12@example.com)
(13, user13, person13@example.com)
(1919251317, 14, on14@example.com)
(15, user15, person15@example.com)
Executed.
db &gt;
</code></pre>
<p>…但是其中的一行看起来好像损坏了.</p>
<p>在经过一些调试之后，我发现这个bug来自分裂叶子节点的函数:</p>
<pre><code class="cpp">@@ -676,7 +690,9 @@ void leaf_node_split_and_insert(Cursor* cursor, uint32_t key, Row* value) &#123;
     void* destination = leaf_node_cell(destination_node, index_within_node);
 
     if (i == cursor-&gt;cell_num) &#123;
-      serialize_row(value, destination);
+      serialize_row(value,
+                    leaf_node_value(destination_node, index_within_node));
+      *leaf_node_key(destination_node, index_within_node) = key;
     &#125; else if (i &gt; cursor-&gt;cell_num) &#123;
       memcpy(destination, leaf_node_cell(old_node, i - 1), LEAF_NODE_CELL_SIZE);
     &#125; else &#123;
</code></pre>
<p>请记住叶子节点的每一个cell包含key和value,key在前,value在后喔:</p>
<p>Original leaf node format</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/leaf-node-format.png"><img src="https://cstack.github.io/db_tutorial/assets/images/leaf-node-format.png" alt="Original leaf node format"></a></p>
<p>我们把待插入的行(的value)写入了cell的开头,而这应该是存储key的地方.这意味着username的一部分变成了id(导致id大的变态).</p>
<blockquote>
<p>译者注: 呃，让我来解释一下…</p>
<p>cell的存储格式为key+value,但是分裂函数中只写入了value,而value是key+username+email,所以即使格式错了,但是key是对的,能被正确索引.</p>
<p>但是读取的时候是直接读取value部分的,而这部分现在变成了username+email(本来应该是key+usn+email).</p>
</blockquote>
<p>修复了bug之后,我们最终可以如期打印整个表了:</p>
<pre><code>db &gt; select
(1, user1, person1@example.com)
(2, user2, person2@example.com)
(3, user3, person3@example.com)
(4, user4, person4@example.com)
(5, user5, person5@example.com)
(6, user6, person6@example.com)
(7, user7, person7@example.com)
(8, user8, person8@example.com)
(9, user9, person9@example.com)
(10, user10, person10@example.com)
(11, user11, person11@example.com)
(12, user12, person12@example.com)
(13, user13, person13@example.com)
(14, user14, person14@example.com)
(15, user15, person15@example.com)
Executed.
db &gt;
</code></pre>
<p>😼😼!一个接一个的bug,但是我们一直在前进.</p>
<p>直到下一次.</p>
</br>

<h2 id="Part-13-Updating-Parent-Node-After-a-Split"><a href="#Part-13-Updating-Parent-Node-After-a-Split" class="headerlink" title="Part 13 - Updating Parent Node After a Split"></a>Part 13 - Updating Parent Node After a Split</h2><p>对于史诗般的b-tree之旅的下一步,我们将要在分裂叶子节点之后处理父节点,我会使用下面的例子作为参考:</p>
<p>Example of updating internal node</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/updating-internal-node.png"><img src="https://cstack.github.io/db_tutorial/assets/images/updating-internal-node.png" alt="Example of updating internal node"></a></p>
<p>在这个例子中,我们给树添加了key<sub>3</sub>.这导致了左边叶子节点的分裂.在分裂之后我们通过下面这些步骤修复这棵树:</p>
<ol>
<li>更新父节点的第一个key为最左边子节点的key<sub>max</sub>(本例中是3).</li>
<li>在更新后的key后面添加一个子节点指针&#x2F;key对<ul>
<li>新的子节点指针指向新的子节点</li>
<li>新的key是新的子节点的key<sub>max</sub></li>
</ul>
</li>
</ol>
<p>那么第一件事是,用两个新函数调用替换我们的占坑代码:</p>
<pre><code class="cpp">update_internal_node_key() for step 1 and internal_node_insert() for step 2

@@ -670,9 +725,11 @@ void leaf_node_split_and_insert(Cursor* cursor, uint32_t key, Row* value) &#123;
   */
 
   void* old_node = get_page(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);
+  uint32_t old_max = get_node_max_key(old_node);
   uint32_t new_page_num = get_unused_page_num(cursor-&gt;table-&gt;pager);
   void* new_node = get_page(cursor-&gt;table-&gt;pager, new_page_num);
   initialize_leaf_node(new_node);
+  *node_parent(new_node) = *node_parent(old_node);
   *leaf_node_next_leaf(new_node) = *leaf_node_next_leaf(old_node);
   *leaf_node_next_leaf(old_node) = new_page_num;
 
@@ -709,8 +766,12 @@ void leaf_node_split_and_insert(Cursor* cursor, uint32_t key, Row* value) &#123;
   if (is_node_root(old_node)) &#123;
     return create_new_root(cursor-&gt;table, new_page_num);
   &#125; else &#123;
-    printf(&quot;Need to implement updating parent after split\n&quot;);
-    exit(EXIT_FAILURE);
+    uint32_t parent_page_num = *node_parent(old_node);
+    uint32_t new_max = get_node_max_key(old_node);
+    void* parent = get_page(cursor-&gt;table-&gt;pager, parent_page_num);
+
+    update_internal_node_key(parent, old_max, new_max);
+    internal_node_insert(cursor-&gt;table, parent_page_num, new_page_num);
+    return;
   &#125;
 &#125;
</code></pre>
<p>为了获取父节点的引用，我们需要在每个节点中记录指向父节点的指针.</p>
<pre><code class="cpp">+uint32_t* node_parent(void* node) &#123; return node + PARENT_POINTER_OFFSET; &#125;

@@ -660,6 +675,48 @@ void create_new_root(Table* table, uint32_t right_child_page_num) &#123;
   uint32_t left_child_max_key = get_node_max_key(left_child);
   *internal_node_key(root, 0) = left_child_max_key;
   *internal_node_right_child(root) = right_child_page_num;
+  *node_parent(left_child) = table-&gt;root_page_num;
+  *node_parent(right_child) = table-&gt;root_page_num;
 &#125;
</code></pre>
<p>现在我们需要找到在父节点中因为分裂操作而受到影响的cell.(分裂的)子节点不知道它在父节点中的cell<sub>index</sub>,所以我们不能根据下标找到它.但是我们知道该子节点的key<sub>max</sub>,所以我们可以在父节点中搜索这个key.</p>
<pre><code class="cpp">+void update_internal_node_key(void* node, uint32_t old_key, uint32_t new_key) &#123;
+  uint32_t old_child_index = internal_node_find_child(node, old_key);
+  *internal_node_key(node, old_child_index) = new_key;
 &#125;
</code></pre>
<p>函数<code>internal_node_find_child()</code>内部复用了一些在内部节点搜索key的代码.重构<code>internal_node_find()</code>以使用新的辅助函数.</p>
<pre><code class="cpp">-Cursor* internal_node_find(Table* table, uint32_t page_num, uint32_t key) &#123;
-  void* node = get_page(table-&gt;pager, page_num);
+uint32_t internal_node_find_child(void* node, uint32_t key) &#123;
+  /*
+  Return the index of the child which should contain
+  the given key.
+  */
+
   uint32_t num_keys = *internal_node_num_keys(node);
 
-  /* Binary search to find index of child to search */
+  /* Binary search */
   uint32_t min_index = 0;
   uint32_t max_index = num_keys; /* there is one more child than key */
 
@@ -386,7 +394,14 @@ Cursor* internal_node_find(Table* table, uint32_t page_num, uint32_t key) &#123;
     &#125;
   &#125;
 
-  uint32_t child_num = *internal_node_child(node, min_index);
+  return min_index;
+&#125;
+
+Cursor* internal_node_find(Table* table, uint32_t page_num, uint32_t key) &#123;
+  void* node = get_page(table-&gt;pager, page_num);
+
+  uint32_t child_index = internal_node_find_child(node, key);
+  uint32_t child_num = *internal_node_child(node, child_index);
   void* child = get_page(table-&gt;pager, child_num);
   switch (get_node_type(child)) &#123;
     case NODE_LEAF:
</code></pre>
<p>现在我们到了这一章的核心部分,实现函数<code>internal_node_insert()</code>.我将分成几个部分来解释这玩意.</p>
<pre><code class="cpp">+void internal_node_insert(Table* table, uint32_t parent_page_num,
+                          uint32_t child_page_num) &#123;
+  /*
+  Add a new child/key pair to parent that corresponds to child
+  */
+
+  void* parent = get_page(table-&gt;pager, parent_page_num);
+  void* child = get_page(table-&gt;pager, child_page_num);
+  uint32_t child_max_key = get_node_max_key(child);
+  uint32_t index = internal_node_find_child(parent, child_max_key);
+
+  uint32_t original_num_keys = *internal_node_num_keys(parent);
+  *internal_node_num_keys(parent) = original_num_keys + 1;
+
+  if (original_num_keys &gt;= INTERNAL_NODE_MAX_CELLS) &#123;
+    printf(&quot;Need to implement splitting internal node\n&quot;);
+    exit(EXIT_FAILURE);
+  &#125;
</code></pre>
<p>根据新的子节点的key<sub>max</sub>得到新的cell(子节点指针&amp;键 pair)应该插入的位置的下标index.在我们看到的例子中,<code>child_max_key</code>是5然后下标为1.</p>
<p>如果内部节点没有空间来插入一个cell,抛出一个错误.我们将会在后续章实现分裂内部节点.</p>
<p>现在看一下函数的其余部分:</p>
<pre><code class="cpp">+
+  uint32_t right_child_page_num = *internal_node_right_child(parent);
+  void* right_child = get_page(table-&gt;pager, right_child_page_num);
+
+  if (child_max_key &gt; get_node_max_key(right_child)) &#123;
+    /* Replace right child */
+    *internal_node_child(parent, original_num_keys) = right_child_page_num;
+    *internal_node_key(parent, original_num_keys) =
+        get_node_max_key(right_child);
+    *internal_node_right_child(parent) = child_page_num;
+  &#125; else &#123;
+    /* Make room for the new cell */
+    for (uint32_t i = original_num_keys; i &gt; index; i--) &#123;
+      void* destination = internal_node_cell(parent, i);
+      void* source = internal_node_cell(parent, i - 1);
+      memcpy(destination, source, INTERNAL_NODE_CELL_SIZE);
+    &#125;
+    *internal_node_child(parent, index) = child_page_num;
+    *internal_node_key(parent, index) = child_max_key;
+  &#125;
+&#125;
</code></pre>
<p>因为我们将最右边子节点指针与其余的<code>子节点指针&amp;键 pair</code>分开来存储,所以需要特殊处理当新的子节点成为最右边子节点的情况.</p>
<p>在函数中,我们可能会进入<code>else</code>块.首先为新的cell腾出空间,将其他cell右移一个cell单位.(尽管在我们的示例中没有cell需要移动)</p>
<p>然后，将新的<code>子节点指针&amp;key pair</code>写入<code>index</code>对应的cell位置.</p>
<p>为了减少测试用例的大小,我目前硬编码了<code>INTERNAL_NODE_MAX_CELLS</code></p>
<pre><code class="cpp">@@ -126,6 +126,8 @@ const uint32_t INTERNAL_NODE_KEY_SIZE = sizeof(uint32_t);
 const uint32_t INTERNAL_NODE_CHILD_SIZE = sizeof(uint32_t);
 const uint32_t INTERNAL_NODE_CELL_SIZE =
     INTERNAL_NODE_CHILD_SIZE + INTERNAL_NODE_KEY_SIZE;
+/* Keep this small for testing */
+const uint32_t INTERNAL_NODE_MAX_CELLS = 3;
</code></pre>
<p>说到测试,我们的大量数据测试用例需要修改一下:</p>
<pre><code>@@ -65,7 +65,7 @@ describe &#39;database&#39; do
     result = run_script(script)
     expect(result.last(2)).to match_array([
       &quot;db &gt; Executed.&quot;,
-      &quot;db &gt; Need to implement updating parent after split&quot;,
+      &quot;db &gt; Need to implement splitting internal node&quot;,
     ])
</code></pre>
<p>Very satisfying, I know.</p>
<p>再加个测试来打印一棵4个节点的树.目前为止我们的测试的插入ID都是顺序的,这个测试将会以伪随机顺序插入记录.</p>
<pre><code>+  it &#39;allows printing out the structure of a 4-leaf-node btree&#39; do
+    script = [
+      &quot;insert 18 user18 person18@example.com&quot;,
+      &quot;insert 7 user7 person7@example.com&quot;,
+      &quot;insert 10 user10 person10@example.com&quot;,
+      &quot;insert 29 user29 person29@example.com&quot;,
+      &quot;insert 23 user23 person23@example.com&quot;,
+      &quot;insert 4 user4 person4@example.com&quot;,
+      &quot;insert 14 user14 person14@example.com&quot;,
+      &quot;insert 30 user30 person30@example.com&quot;,
+      &quot;insert 15 user15 person15@example.com&quot;,
+      &quot;insert 26 user26 person26@example.com&quot;,
+      &quot;insert 22 user22 person22@example.com&quot;,
+      &quot;insert 19 user19 person19@example.com&quot;,
+      &quot;insert 2 user2 person2@example.com&quot;,
+      &quot;insert 1 user1 person1@example.com&quot;,
+      &quot;insert 21 user21 person21@example.com&quot;,
+      &quot;insert 11 user11 person11@example.com&quot;,
+      &quot;insert 6 user6 person6@example.com&quot;,
+      &quot;insert 20 user20 person20@example.com&quot;,
+      &quot;insert 5 user5 person5@example.com&quot;,
+      &quot;insert 8 user8 person8@example.com&quot;,
+      &quot;insert 9 user9 person9@example.com&quot;,
+      &quot;insert 3 user3 person3@example.com&quot;,
+      &quot;insert 12 user12 person12@example.com&quot;,
+      &quot;insert 27 user27 person27@example.com&quot;,
+      &quot;insert 17 user17 person17@example.com&quot;,
+      &quot;insert 16 user16 person16@example.com&quot;,
+      &quot;insert 13 user13 person13@example.com&quot;,
+      &quot;insert 24 user24 person24@example.com&quot;,
+      &quot;insert 25 user25 person25@example.com&quot;,
+      &quot;insert 28 user28 person28@example.com&quot;,
+      &quot;.btree&quot;,
+      &quot;.exit&quot;,
+    ]
+    result = run_script(script)
</code></pre>
<p>它应该会输出这个:</p>
<pre><code>- internal (size 3)
  - leaf (size 7)
    - 1
    - 2
    - 3
    - 4
    - 5
    - 6
    - 7
  - key 1
  - leaf (size 8)
    - 8
    - 9
    - 10
    - 11
    - 12
    - 13
    - 14
    - 15
  - key 15
  - leaf (size 7)
    - 16
    - 17
    - 18
    - 19
    - 20
    - 21
    - 22
  - key 22
  - leaf (size 8)
    - 23
    - 24
    - 25
    - 26
    - 27
    - 28
    - 29
    - 30
db &gt;
</code></pre>
<p>仔细观察你会发现一个bug:</p>
<p>这里的key应该是7,而不是1!</p>
<p>在经过一堆debug和i后,我发现错误原因是一些错误的指针运算.</p>
<pre><code class="cpp"> uint32_t* internal_node_key(void* node, uint32_t key_num) &#123;
-  return internal_node_cell(node, key_num) + INTERNAL_NODE_CHILD_SIZE;
+  return (void*)internal_node_cell(node, key_num) + INTERNAL_NODE_CHILD_SIZE;
 &#125;
</code></pre>
<blockquote>
<p>译者注: 如果你认真看的话,就应该知道我已经<a href="#fixBug1">改正</a>过这个错误了</p>
</blockquote>
<p><strong>INTERNAL_NODE_CHILD_SIZE</strong>的值为4.我的原意是令<code>internal_node_cell()</code>返回的指针地址加上4字节,但是因为<code>internal_node_cell()</code>返回的是一个<code>uint32_t*</code>指针,所以实际上加了<code>4*sizeof(uint32_t)</code>字节.在进行算数运算之前先把指针显式类型转换为<code>void*</code>类型，这样就能修复问题了.</p>
<p><strong>注意!</strong><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3523145/pointer-arithmetic-for-void-pointer-in-c/46238658#46238658">void指针的算数运算并不是C标准内容的一部分,所以可能在你的编译器上无效.</a>未来我也许会写一篇关于可移植性的文章,但是目前我会保留void指针运算.</p>
<p>好了.One more step toward a fully-operational btree implementation.下一步应该是分裂内部节点.</p>
<p>Until then!</p>
</br>

</br>

</br>

<blockquote>
<p>译者注: 原作者在2021.11.27更新了最后一章 - part 13.</p>
<p>然后彻底的鸽了(悲).本人本着人道主义精神,决定尽可能地狗尾续貂,至少得完成B树的完整架构.</p>
<p>当然,我也可能会鸽(毕竟我每天都做牛做马,如果实在没时间继续,我就鸽😤😤).</p>
</blockquote>
</br>

<h1 id="狗尾续貂"><a href="#狗尾续貂" class="headerlink" title="狗尾续貂"></a>狗尾续貂</h1></br>

<h2 id="Part-14-Splitting-a-Internal-Node"><a href="#Part-14-Splitting-a-Internal-Node" class="headerlink" title="Part 14 - Splitting a Internal Node"></a>Part 14 - Splitting a Internal Node</h2><p>基于目前的btree架构,我们的内部节点一共可以存储3个key,4个子节点.</p>
<p>在上一章的<code>internal_node_insert()</code>函数中,留了一个占坑<code>if</code>块.<img src="https://gitee.com/salt3dfish/images/raw/master/hexo/22-05-02/c91af8b382055446b404e5577a18f4f4.png" alt="image-20220502152912307"></p>
<p>然后稍作修改:</p>
<p><img src="https://gitee.com/salt3dfish/images/raw/master/hexo/22-05-03/e0e62256d54e2cae72f174d25cac3bb3.png" alt="img" title="cnm"></p>
<p>本章将主要实现分裂内部节点的操作.</p>
</br>

<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>这是一棵有4个叶子节点的树:</p>
<p><img src="https://gitee.com/salt3dfish/images/raw/master/hexo/22-05-02/594788697d9ed0c836e182abb1f0c6e5.png" alt="img">(*指孩子,K指该子节点的最大的key)</p>
<p>现在叶子节点3需要进行分裂,分裂后一共有5个叶子节点，超出了内部节点的容量,所以需要分裂内部节点.</p>
<p>而我们新创建的函数<code>internal_node_split_and_insert()</code>将完成分裂操作.</p>
<p>在继续之前，我们先梳理一下插入操作:</p>
<ol>
<li>根据key找到应该插入的位置-cursor(如果key重复的话,不会进行下面的步骤)</li>
<li>判断叶子节点是否填满 <code>leaf_node_insert()</code><ul>
<li>未满: 执行插入,然后结束.</li>
<li>已满: <code>leaf_node_split_and_insert()</code><ul>
<li>如果该节点为根节点,那么分裂根节点并且创建一个新的根节点(内部节点) - <code>create_new_root()</code>,调整树的结构后结束.</li>
<li>如果该节点非根节点,那么需要更新父节点中的key - <code>update_internal_node_key</code>,以及再向父节点插入一对子节点指针&amp;key - <code>internal_node_insert()</code>:<ul>
<li>如果父节点未满,插入cell,结束.</li>
<li>如果父节点已满,分裂父节点: <code>internal_node_split_and_insert()</code><ul>
<li>如果父节点为根节点,那么分裂根节点并且创建一个新的根节点</li>
<li>父节点非根节点,那么需要更新父节点的父节点(即爷爷节点)的key,以及向爷爷节点插入一对子节点指针&amp;key<ul>
<li>还需要考虑爷爷节点是否已满,所以这实际上是一个递归的过程…</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>而本章主要解决<strong>需要分裂的内部节点为根节点</strong>的情况.在分裂父节点之前,函数调用过程已经为我们做了一些准备工作:</p>
<ol>
<li>待分裂的叶子节点已经分裂完毕 <code>old &amp; new</code></li>
<li>旧的叶子节点(old)在根节点中对应的key已经更新(<code>update_internal_node_key</code>).</li>
</ol>
<p>所以类似<a href="#splitting-algorithm">Part 10 - Splitting Algorithm</a>的操作,此时需要分裂的内部节点是root节点,操作有2步:</p>
<ul>
<li>分裂root为两个内部节点(要包括待插入的cell)</li>
<li>创建一个新的root节点成为这两个内部节点的父节点</li>
</ul>
<p>延续上文分裂节点3,假设节点3被分裂成了2个节点 - 3&amp;5</p>
<p><img src="https://gitee.com/salt3dfish/images/raw/master/hexo/22-05-02/01a1e3f623ab04556f13f2ae3c97ac74.png"></p>
<p>那么分裂后的树应该长这样:</p>
<p><img src="https://gitee.com/salt3dfish/images/raw/master/hexo/22-05-02/c716416be22f9a379322d433cdcb4c6a.png"></p>
<p>在part 10分裂叶子节点的时候我们将左边的节点多分配了一个cell,同样,在分裂内部节点的时候,如果不能均分,那么左边的节点多一个cell.</p>
<p>先在宏文件中定义分裂后的子节点指针数量:</p>
<pre><code class="cpp">cuint32 INTERNAL_NODE_MAX_CHILD=INTERNAL_NODE_MAX_CELLS+1;
cuint32 INTERNAL_NODE_SPLIT_RIGHT_CHILD_COUNT=(INTERNAL_NODE_MAX_CHILD+1)/2;
cuint32 INTERNAL_NODE_SPLIT_LEFT_CHILD_COUNT=INTERNAL_NODE_MAX_CHILD+1-INTERNAL_NODE_SPLIT_RIGHT_CHILD_COUNT;
</code></pre>
<p>注意这里的是子节点的数量,对于内部节点来说,<code>key</code>(或者说cell)的数量为子节点的数量-1.</p>
</br>

<h3 id="Cell-or-Child"><a href="#Cell-or-Child" class="headerlink" title="Cell or Child?"></a>Cell or Child?</h3><p>在上一版本的<code>internal_node_insert</code>函数中,调用分裂内部节点的函数之前,就已经把key的数量加上了.</p>
<p><img src="https://gitee.com/salt3dfish/images/raw/master/hexo/22-05-03/fedf9993cdcf1504e9e2e9edca077f8b.png" alt="image-20220503172201776"></p>
<p>我们要把它移动到<code>if</code>判断之后.</p>
<p><img src="https://gitee.com/salt3dfish/images/raw/master/hexo/22-05-03/0e39a6357996b5851444f9e62f2b55df.png" alt="image-20220503172246587"></p>
<p>因为调用<code>internal_node_insert</code>的时候还未将新的child ptr &amp; key插入到内部节点中,如果先增加key的数量,会产生一些比较讨厌的问题.</p>
<blockquote>
<p>例如原本<code>right child</code>的下标为2,<code>num(keys)=2</code></p>
<p>现在增加了key的数量,<code>num(keys)=3</code>,那么在调用函数<code>internal_node_child(node,child_num)</code>的时候,因为子节点指针的数量为key+1,原本<code>2 == num(keys)-1</code>就是最右边子节点的下标,现在变成了下标为2的cell对应的子节点指针,而此时该cell还未插入内部节点中.</p>
</blockquote>
<p>此外,还需要判断新增的节点与最右边子节点的位置关系.</p>
<p>因为<code>internal_node_find_child(node,key)</code>最多就到最右边的子节点,也就是说新增的节点如果插入下标为最右边节点对应的下标,不一定是该新增节点最终应该插入的位置.还要与最右边子节点的key进行比较以决定是放在最右边子节点的左边还是右边.</p>
<p><code>child_index</code>为新增的子节点在父节点(是一个内部节点)的所有子节点指针中的顺序(从0开始),该下标<strong>不是</strong>其对应的cell的下标,因为内部节点的结构有cell(子节点指针&amp;key)和最右子节点指针,所以用子节点下标比较方便.</p>
</br>

<h3 id="Splitting-Algorithm-1"><a href="#Splitting-Algorithm-1" class="headerlink" title="Splitting Algorithm"></a>Splitting Algorithm</h3><p>分裂内部节点的操作和分裂叶子节点的逻辑差不多,只不过因为内部节点的特殊结构 - 元素为子节点指针&amp;key(即cell)的数组以及一个最右子节点指针,有很多边界条件需要判断.</p>
<blockquote>
<p>例如新增的节点为分裂后的节点的最右边孩子的情况.</p>
<p>以及原本不是最右边节点的cell,但是因为分裂操作而变成了最右边子节点指针的情况…</p>
</blockquote>
<p>和分裂叶子节点一样.根据key值将内部节点分为upper和lower两个部分.upper里的任意元素的key都严格大于lower里的元素的最大的key.</p>
<p>我就不详细讲了,代码如下:</p>
<pre><code class="cpp">void internal_node_split_and_insert(Table* table,
                                    uint32_t internal_node_page_num,
                                    uint32_t child_page_num,
                                    uint32_t child_index)&#123;
    void* node=get_page(table-&gt;pager,internal_node_page_num);
    void* child=get_page(table-&gt;pager,child_page_num);
    uint32_t child_max_key=get_node_max_key(child);
    //待分裂的internal节点的原最大key,之后可能用于更新其在父节点中的key
    uint32_t old_max_key=get_internal_node_max_key(table-&gt;pager,node);

    uint32_t existing_num_child=*(internal_node_num_keys(node))+1; //已经存在的孩子的个数
    // parent origin rightest child
    uint32_t origin_rightest_child_index=existing_num_child-1;
    uint32_t origin_rightest_child_page_num=*(internal_node_right_child(node));
    void* origin_rightest_child=get_page(table-&gt;pager,origin_rightest_child_page_num);

    //right(new) node
    uint32_t new_node_page_num=get_unused_page_num(table-&gt;pager);
    void* new_node=get_page(table-&gt;pager,new_node_page_num);
    initialize_internal_node(new_node);
    *(internal_node_num_keys(new_node))=INTERNAL_NODE_SPLIT_RIGHT_CHILD_COUNT-1;

    for(int32_t i=existing_num_child;i&gt;=0;i--)&#123;
        void* destination_node=NULL;
        uint32_t right_child_index;
        bool is_rightest=false; //是否是 目标节点 的最右边的孩子
        //在目标节点的下标.
        int index=i%INTERNAL_NODE_SPLIT_LEFT_CHILD_COUNT;

        if (i&gt;=INTERNAL_NODE_SPLIT_LEFT_CHILD_COUNT)&#123; // in new node
            destination_node=new_node;
            is_rightest=(index==INTERNAL_NODE_SPLIT_RIGHT_CHILD_COUNT-1);
        &#125;else&#123; // in old node
            destination_node=node;
            is_rightest=(index==INTERNAL_NODE_SPLIT_LEFT_CHILD_COUNT-1);
        &#125;

        if (i&gt;child_index)&#123; //在待插入元素右边的元素.
            if (is_rightest)&#123; //如果是目标节点的最右边的子节点.
                *(internal_node_right_child(destination_node))=*(internal_node_child(node,i-1));
            &#125;else &#123; // 非目标节点的最右边的子节点,copy child_ptr &amp; key
                if (i-1==origin_rightest_child_index)&#123; //判断该节点是否为原节点的最右边的子节点
                    //赋值子节点指针
                    *(internal_node_child(destination_node,index))=origin_rightest_child_page_num;
                    //赋值key
                    *(uint32_t* )(internal_node_key(destination_node,index))=
                        get_node_max_key(origin_rightest_child);
                &#125;
                else&#123; //源cell非最右边的孩子
                    memcpy(internal_node_cell(destination_node,index),
                    internal_node_cell(node,i-1),
                    INTERNAL_NODE_CELL_SIZE);
                &#125;
            &#125;
        &#125;else if (i==child_index)&#123; //待插入的元素
            if (is_rightest)&#123;
                *(internal_node_right_child(destination_node))=child_page_num;
            &#125;else &#123;
                //page num
                *(internal_node_child(destination_node,index))=child_page_num;
                //key
                *(internal_node_key(destination_node,index))=child_max_key;
            &#125;
        &#125;else&#123; // 在插入的元素的左边
            if (is_rightest)&#123; //目标位置为最右边
                uint32_t page_num=*(internal_node_child(node,i));
                *(internal_node_right_child(destination_node))=page_num;
            &#125;else&#123; //目标位置不是最右边
                if (i==origin_rightest_child_index)&#123; //在原节点中为最右边的孩子.
                    *(internal_node_child(destination_node,index))=*(internal_node_child(node,i));
                    *(internal_node_key(destination_node,index))=get_node_max_key(origin_rightest_child);
                &#125; else &#123; //不是原节点的最右边孩子
                    memcpy(internal_node_cell(destination_node,index),
                    internal_node_cell(node,i),
                    INTERNAL_NODE_CELL_SIZE);
                &#125;
            &#125;
        &#125;
    &#125;

    // modify num of keys
    *(internal_node_num_keys(node))=INTERNAL_NODE_SPLIT_LEFT_CHILD_COUNT-1;
    *(internal_node_num_keys(new_node))=INTERNAL_NODE_SPLIT_RIGHT_CHILD_COUNT-1;
    
    //到此,internal node已经分裂为两个internal
    if (is_node_root(node))&#123; // 分裂的internal为root
        create_new_internal_root(table,new_node_page_num);
    &#125; else &#123; // 分裂的internal非root,更新parent
        //update lower key in parent
        uint32_t new_max_key=get_internal_node_max_key(table-&gt;pager,node);
        uint32_t parent_page_num=*(node_parent(node));
        void* parent=get_page(table-&gt;pager,parent_page_num);
        update_internal_node_key(parent,old_max_key,new_max_key);
        //insert new cell in parent node
        internal_node_insert(table,parent_page_num,new_node_page_num);
    &#125;

&#125;
</code></pre>
<blockquote>
<p>注: 我也觉得写得很丑陋,但是我水平比较凑合所以将就看一下吧…</p>
</blockquote>
<p>在该函数中还使用了一个新的用于获取内部节点的最大key的函数<code>get_internal_node_max_key</code></p>
<pre><code class="cpp">uint32_t get_internal_node_max_key(Pager* pager,void* node)&#123;
    switch (get_node_type(node))&#123;
        case NODE_INTERNAL:&#123;
            uint32_t right_child=*(internal_node_right_child(node));
            return get_internal_node_max_key(pager,get_page(pager,right_child));
        &#125;
        case NODE_LEAF:
            return get_node_max_key(node);
        default:
            cout&lt;&lt;&quot;UNRECOGNIZED NODE TYPE: &quot;&lt;&lt;get_node_type(node)&lt;&lt;endl;
            exit(EXIT_FAILURE);
    &#125;
    
&#125;
</code></pre>
<p>原来的获取最大key的函数<code>get_node_max_key</code>在处理内部节点时，不会递归搜索叶子节点,而<code>get_internal_node_max_key()</code>会获取该子树的最大key</p>
<h3 id="Create-New-Root"><a href="#Create-New-Root" class="headerlink" title="Create New Root"></a>Create New Root</h3><p>如果分裂的内部节点为根节点,就进行分裂根节点的操作:</p>
<pre><code class="cpp">void create_new_internal_root(Table* table,uint32_t right_child_page_num)&#123;
    //root node(lower)
    uint32_t root_page_num=table-&gt;root_page_num;
    void* root_node=get_page(table-&gt;pager,root_page_num);

    //create a new node to be lower node
    uint32_t new_node_page_num=get_unused_page_num(table-&gt;pager);
    void* new_node=get_page(table-&gt;pager,new_node_page_num);
    initialize_internal_node(new_node);
    *(internal_node_num_keys(new_node))=*(internal_node_num_keys(root_node));
    *(node_parent(new_node))=root_page_num; // new node&#39;s parent ptr to root_page_num
    set_node_root(new_node,false);

    //copy cell from root to new node
    for(uint32_t i=0;i&lt;*(internal_node_num_keys(root_node));i++)&#123;
        memcpy(internal_node_cell(new_node,i),
        internal_node_cell(root_node,i),
        INTERNAL_NODE_CELL_SIZE);
    &#125;
    //rightest child of new node
    *(internal_node_right_child(new_node))=*(internal_node_right_child(root_node));

    //ROOT NODE
    set_node_root(root_node,true);
    *(internal_node_num_keys(root_node))=1;
    *(internal_node_child(root_node,0))=new_node_page_num;
    //注意,这里获取的max key是整棵子树,而不是一个internal节点的最大key
    *(internal_node_key(root_node,0))=get_internal_node_max_key(table-&gt;pager,root_node);
    *(internal_node_right_child(root_node))=right_child_page_num;

    // set Parent
    void* right_child=get_page(table-&gt;pager,right_child_page_num);
    *(node_parent(new_node))=table-&gt;root_page_num;
    *(node_parent(right_child))=table-&gt;root_page_num;

&#125;
</code></pre>
<p>目前已经把原内部节点分裂成upper和lower两个部分.</p>
<p>根节点对应lower,<code>right_child_page_num</code>对应upper</p>
<p>首先申请一个新page,然后将根节点的数据全部拷贝进新节点<code>new_node</code>：</p>
<p>cell和最右边子节点指针,以及内部节点头部的一些信息.</p>
<p>因为根节点只有两个内部节点.所以只需要把<code>new_node</code>对应的<code>子节点指针&amp;key</code>插入根节点中,然后再将根节点的<code>right_child</code>赋值为<code>right_child_page_num</code>即可.</p>
<p>最后给两个新的内部节点的<code>parent</code>指向根节点.</p>
</br>


<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><p>测试我就懒得贴出来了.</p>
<p>在我的版本中额外加了一个<code>.test begin num</code>功能,用来向表中插入数据.</p>
<p>例如<code>.test 10 5</code>就是从<code>id=10</code>开始,连续插入5行,每行id递增.</p>
</br>

<p>我大概也不会完成这个项目了.</p>
<p>最近太累了.</p>
    </div>
  </div>
</article> 
  </div>
  
<link rel="stylesheet" href="/css/footer.css">



<script src="/js/highlight.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>

<div id="footer"></div>
 
</body>