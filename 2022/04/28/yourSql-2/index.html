<!DOCTYPE html>
<html lang=" ">
<head>
  <meta charset="utf-8" />
<link rel="icon" href="/images/rev_sheep.png " />
<title>almostSalted</title>
<meta name="referrer" content="no-referrer" />
<meta name="google-site-verification" content="_CsSd0yrTQQrdEyoybq1kZNTZbIVulPo3zdQnaqAR0Y" />
  
<link rel="stylesheet" href="/css/layout.css">

<meta name="generator" content="Hexo 6.1.0"></head>
<body>
  
<link rel="stylesheet" href="/css/header.css">


<div class="topBar">
  <img class="icon" src="/images/rev_sheep.png " />
  <div class="menu">
     
    <a href="/ ">home</a>
     
    <a href="/archives ">archives</a>
     
    <a href="/categories ">categories</a>
     
    <a href="/aboutme ">aboutme</a>
     
    <a href="/diary ">diary</a>
    
  </div>
</div>
<div class="blank"></div>
  <div class="wrapper">
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div id="post">
  <aside id="navigator">
    <ol class="anchor"><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#Content"><span class="anchor-number">1.</span> <span class="anchor-text">Content</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part-8-B-Tree-leaf-Node-Format"><span class="anchor-number">1.1.</span> <span class="anchor-text">Part 8 - B-Tree leaf Node Format</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Alternative-Table-Formats"><span class="anchor-number">1.1.1.</span> <span class="anchor-text">Alternative Table Formats</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Leaf-Node-Format"><span class="anchor-number">1.1.2.</span> <span class="anchor-text">Leaf Node Format</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Accessing-Leaf-Node-Fields"><span class="anchor-number">1.1.3.</span> <span class="anchor-text">Accessing Leaf Node Fields</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Changes-to-Pager-and-Table-Objects"><span class="anchor-number">1.1.4.</span> <span class="anchor-text">Changes to Pager and Table Objects</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Changes-to-the-Cursor-Object"><span class="anchor-number">1.1.5.</span> <span class="anchor-text">Changes to the Cursor Object</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Insertion-Into-a-Leaf-Node"><span class="anchor-number">1.1.6.</span> <span class="anchor-text">Insertion Into a Leaf Node</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Command-to-Print-Constants"><span class="anchor-number">1.1.7.</span> <span class="anchor-text">Command to Print Constants</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Tree-Visualization"><span class="anchor-number">1.1.8.</span> <span class="anchor-text">Tree Visualization</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Next-Time"><span class="anchor-number">1.1.9.</span> <span class="anchor-text">Next Time</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Complete-Diff"><span class="anchor-number">1.1.10.</span> <span class="anchor-text">Complete Diff</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Part-9-Binary-Search-and-Duplicate-Keys"><span class="anchor-number">1.1.11.</span> <span class="anchor-text">Part 9 - Binary Search and Duplicate Keys</span></a></li></ol></li></ol></li></ol>
  </aside>
  <div id="content">
    <div id="postHead">
      <h1>yourSql 2</h1>
      <div class="postDate">
        <img class="dateIcon" src="/images/clockicon.svg" />
        --2022.4.28
      </div>
        
        <div class="postCategory">
            <a href="/categories/translation/">translation</a>
        </div>
         
    </div>
    <div id="postBody">
      <h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><style>
    #table {
        margin: 0 auto;
        text-align: center;
        border: 1px solid grey;
        border-collapse: collapse;
        line-height: 1.6em;
    }
    #table th,#table td {
        border: 1px solid grey;
        padding: 0.5em;
    }
</style>

</br>

<h2 id="Part-8-B-Tree-leaf-Node-Format"><a href="#Part-8-B-Tree-leaf-Node-Format" class="headerlink" title="Part 8 - B-Tree leaf Node Format"></a>Part 8 - B-Tree leaf Node Format</h2><p>我们即将把 table 的结构从存储 row 的无序数组转变为 B-Tree,这是一个相当大的改变以至于需要好几章来实现.在本章的末尾，我们将会定义叶子节点的布局，以及支持向只有一个节点的树中插入键值对.</p>
<p>不过首先让我们回想一下为什么转换到树结构.</p>
<h3 id="Alternative-Table-Formats"><a href="#Alternative-Table-Formats" class="headerlink" title="Alternative Table Formats"></a>Alternative Table Formats</h3><p>基于目前的存储格式，每页只存储 row(没有元数据)因此空间利用效率很高.插入也很快因为我们只需要插入到末尾.但是寻找指定的 row 只能通过遍历整个 table 来完成,并且如果我们想要删除 row,我们需要将删除的 row 之后的所有行前移以填补空缺.</p>
<p>如果我们以数组的形式存储 table,但是 row 通过 id 排序,我们可以使用二分查找指定的 id.但是插入操作会非常耗时，因为我们要移动很多行以腾出空间.</p>
<p>因此，我们将使用 tree 结构.树中的每一個节点可以包含可变数量的行,所以我们需要在节点中存储一些信息以表示它包含了多少行.此外还有不存储任何行的内部节点的空间开销.作为数据库文件变大的交换，我们得到了快速插入，删除和查找.</p>
<table>
<thead>
<tr>
<th></th>
<th>存储 row 的无序数组</th>
<th>存储 row 的有序数组</th>
<th>树的节点</th>
</tr>
</thead>
<tbody><tr>
<td>page 存储的数据</td>
<td>仅数据</td>
<td>仅数据</td>
<td>元数据，主键值和数据</td>
</tr>
<tr>
<td>每页的行数</td>
<td>more</td>
<td>more</td>
<td>fewer</td>
</tr>
<tr>
<td>插入</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>删除</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>通过 id 查找</td>
<td>O(n)</td>
<td>O(log(n))</td>
<td>O(log(n))</td>
</tr>
</tbody></table>
<p>内部节点和叶子节点拥有不同的布局，让我们定义一个枚举变量表示节点的类型.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//+typedef enum &#123; NODE_INTERNAL, NODE_LEAF &#125; NodeType;</span></span><br><span class="line"><span class="comment">// 译者注: 因为下文要求type大小为1字节，所以制定了enum大小为uint8_t,否则默认为4个字节</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> : <span class="type">uint8_t</span></span><br><span class="line">&#123;</span><br><span class="line">    NODE_INTERNAL,</span><br><span class="line">    NODE_LEAF</span><br><span class="line">&#125; NodeType;</span><br></pre></td></tr></table></figure>

<p>每一个节点对应着一页.内部节点存储着指向子节点的指针，该指针实际上是存储着该子节点的页的 page number(译者注:即下标).btree 向 pager 请求指定的 page number,pager 返回指向该页缓存的指针.页根据 page number 有序存储在数据库文件中.</p>
<p>节点需要在页的头部存储一些元数据.每个节点会存储它的类型,是否为根节点，和一个指向父节点的指针(用来寻找兄弟节点).我定义了常量来表示头部的每个字段的大小和偏移量.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Common Node Header Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> NODE_TYPE_SIZE = <span class="built_in">sizeof</span>(NodeType);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> NODE_TYPE_OFFSET = <span class="number">0</span>;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> IS_ROOT_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> IS_ROOT_OFFSET = NODE_TYPE_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> PARENT_POINTER_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint8_t</span> COMMON_NODE_HEADER_SIZE =</span><br><span class="line">+    NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;</span><br></pre></td></tr></table></figure>

<h3 id="Leaf-Node-Format"><a href="#Leaf-Node-Format" class="headerlink" title="Leaf Node Format"></a>Leaf Node Format</h3><p>除了这些通用的头部字段外，叶子节点需要存储包含的”cell”的数量.一个”cell”就是一个键值对.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Leaf Node Header Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_NUM_CELLS_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_HEADER_SIZE =</span><br><span class="line">+    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;</span><br></pre></td></tr></table></figure>

<p>叶子节点的 body 是 cell 数组.每个 cell 是一个键后面跟着一个值(一个序列化的行).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Leaf Node Body Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_KEY_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_KEY_OFFSET = <span class="number">0</span>;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_VALUE_SIZE = ROW_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_VALUE_OFFSET =</span><br><span class="line">+    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_MAX_CELLS =</span><br><span class="line">+    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;</span><br></pre></td></tr></table></figure>

<p>基于这些常量,这里是叶子节点目前布局:</p>
<p>Our leaf node format</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/leaf-node-format.png"><img src="https://cstack.github.io/db_tutorial/assets/images/leaf-node-format.png" alt="Our leaf node format"></a></p>
<p>在头部使用一整个字节表示一个 bool 值有点浪费空间，但是这会让通过代码获取这些值更容易一点.</p>
<p>还要注意末尾有一些被浪费的空间.我们在头部之后存储尽可能多的 cell,但是剩余的空间不能存储一整个 cell.我们不使用这片空间以避免把 cell 分割到两个节点.</p>
<h3 id="Accessing-Leaf-Node-Fields"><a href="#Accessing-Leaf-Node-Fields" class="headerlink" title="Accessing Leaf Node Fields"></a>Accessing Leaf Node Fields</h3><p>获取键，值和元数据的函数都涉及到使用我们刚刚定义的常量进行指针算数运算.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">leaf_node_num_cells</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + LEAF_NODE_NUM_CELLS_OFFSET;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span>* <span class="title">leaf_node_cell</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + LEAF_NODE_HEADER_SIZE + cell_num * LEAF_NODE_CELL_SIZE;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">leaf_node_key</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_cell</span>(node, cell_num);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span>* <span class="title">leaf_node_value</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_cell</span>(node, cell_num) + LEAF_NODE_KEY_SIZE;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">initialize_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123; *<span class="built_in">leaf_node_num_cells</span>(node) = <span class="number">0</span>; &#125;</span><br><span class="line">+</span><br></pre></td></tr></table></figure>

<h3 id="Changes-to-Pager-and-Table-Objects"><a href="#Changes-to-Pager-and-Table-Objects" class="headerlink" title="Changes to Pager and Table Objects"></a>Changes to Pager and Table Objects</h3><p>每个节点将确切地占据一页，即使页没满.这意味着我们的 pager 不再需要支持 读&#x2F;写 未满的页了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-<span class="function"><span class="type">void</span> <span class="title">pager_flush</span><span class="params">(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size)</span> </span>&#123;</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">pager_flush</span><span class="params">(Pager* pager, <span class="type">uint32_t</span> page_num)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (pager-&gt;pages[page_num] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Tried to flush null page\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">@@ <span class="number">-242</span>,<span class="number">7</span> +<span class="number">337</span>,<span class="number">7</span> @@ <span class="function"><span class="type">void</span> <span class="title">pager_flush</span><span class="params">(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size)</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">ssize_t</span> bytes_written =</span><br><span class="line">-      <span class="built_in">write</span>(pager-&gt;file_descriptor, pager-&gt;pages[page_num], size);</span><br><span class="line">+      <span class="built_in">write</span>(pager-&gt;file_descriptor, pager-&gt;pages[page_num], PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Error writing: %d\n&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">db_close</span><span class="params">(Table* table)</span> </span>&#123;</span><br><span class="line">   Pager* pager = table-&gt;pager;</span><br><span class="line">-  <span class="type">uint32_t</span> num_full_pages = table-&gt;num_rows / ROWS_PER_PAGE;</span><br><span class="line"></span><br><span class="line">-  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_full_pages; i++) &#123;</span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; pager-&gt;num_pages; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (pager-&gt;pages[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">-    <span class="built_in">pager_flush</span>(pager, i, PAGE_SIZE);</span><br><span class="line">+    <span class="built_in">pager_flush</span>(pager, i);</span><br><span class="line">     <span class="built_in">free</span>(pager-&gt;pages[i]);</span><br><span class="line">     pager-&gt;pages[i] = <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">-  <span class="comment">// There may be a partial page to write to the end of the file</span></span><br><span class="line">-  <span class="comment">// This should not be needed after we switch to a B-tree</span></span><br><span class="line">-  <span class="type">uint32_t</span> num_additional_rows = table-&gt;num_rows % ROWS_PER_PAGE;</span><br><span class="line">-  <span class="keyword">if</span> (num_additional_rows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">-    <span class="type">uint32_t</span> page_num = num_full_pages;</span><br><span class="line">-    <span class="keyword">if</span> (pager-&gt;pages[page_num] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">-      <span class="built_in">pager_flush</span>(pager, page_num, num_additional_rows * ROW_SIZE);</span><br><span class="line">-      <span class="built_in">free</span>(pager-&gt;pages[page_num]);</span><br><span class="line">-      pager-&gt;pages[page_num] = <span class="literal">NULL</span>;</span><br><span class="line">-    &#125;</span><br><span class="line">-  &#125;</span><br><span class="line">-</span><br><span class="line">   <span class="type">int</span> result = <span class="built_in">close</span>(pager-&gt;file_descriptor);</span><br><span class="line">   <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Error closing db file.\n&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在更明智的做法是在数据库中存储 page 的个数而不是 row 的个数.page 的个数和 pager 对象关联，而不是 table,因为这是被数据库使用的 page 的个数，而不是指定的 table.一个 btree 被它的根节点对应的 page 下标标识，所以 table 对象需要保存该下标.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="type">const</span> <span class="type">uint32_t</span> PAGE_SIZE = <span class="number">4096</span>;</span><br><span class="line"> <span class="type">const</span> <span class="type">uint32_t</span> TABLE_MAX_PAGES = <span class="number">100</span>;</span><br><span class="line">-<span class="type">const</span> <span class="type">uint32_t</span> ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;</span><br><span class="line">-<span class="type">const</span> <span class="type">uint32_t</span> TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="type">int</span> file_descriptor;</span><br><span class="line">   <span class="type">uint32_t</span> file_length;</span><br><span class="line">+  <span class="type">uint32_t</span> num_pages;</span><br><span class="line">   <span class="type">void</span>* pages[TABLE_MAX_PAGES];</span><br><span class="line"> &#125; Pager;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   Pager* pager;</span><br><span class="line">-  <span class="type">uint32_t</span> num_rows;</span><br><span class="line">+  <span class="type">uint32_t</span> root_page_num;</span><br><span class="line"> &#125; Table;</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-127</span>,<span class="number">6</span> +<span class="number">200</span>,<span class="number">10</span> @@ <span class="function"><span class="type">void</span>* <span class="title">get_page</span><span class="params">(Pager* pager, <span class="type">uint32_t</span> page_num)</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     pager-&gt;pages[page_num] = page;</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">if</span> (page_num &gt;= pager-&gt;num_pages) &#123;</span><br><span class="line">+      pager-&gt;num_pages = page_num + <span class="number">1</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> pager-&gt;pages[page_num];</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-184</span>,<span class="number">6</span> +<span class="number">269</span>,<span class="number">12</span> @@ <span class="function">Pager* <span class="title">pager_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">   Pager* pager = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Pager));</span><br><span class="line">   pager-&gt;file_descriptor = fd;</span><br><span class="line">   pager-&gt;file_length = file_length;</span><br><span class="line">+  pager-&gt;num_pages = (file_length / PAGE_SIZE);</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (file_length % PAGE_SIZE != <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Db file is not a whole number of pages. Corrupt file.\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; TABLE_MAX_PAGES; i++) &#123;</span><br><span class="line">     pager-&gt;pages[i] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Changes-to-the-Cursor-Object"><a href="#Changes-to-the-Cursor-Object" class="headerlink" title="Changes to the Cursor Object"></a>Changes to the Cursor Object</h3><p>cursor 对象表示在 table 中的位置,当我们的 table 只是一个简单的元素为 row 的数组,我们只需要给定 row number 就可以访问该行.现在它是一棵树,我们通过 page number 和 cell 在节点中的 cell number 来标识一个位置.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   Table* table;</span><br><span class="line">-  <span class="type">uint32_t</span> row_num;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num;</span><br><span class="line">+  <span class="type">uint32_t</span> cell_num;</span><br><span class="line">   <span class="type">bool</span> end_of_table;  <span class="comment">// Indicates a position one past the last element</span></span><br><span class="line"> &#125; Cursor;</span><br><span class="line"></span><br><span class="line"> <span class="function">Cursor* <span class="title">table_start</span><span class="params">(Table* table)</span> </span>&#123;</span><br><span class="line">   Cursor* cursor = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Cursor));</span><br><span class="line">   cursor-&gt;table = table;</span><br><span class="line">-  cursor-&gt;row_num = <span class="number">0</span>;</span><br><span class="line">-  cursor-&gt;end_of_table = (table-&gt;num_rows == <span class="number">0</span>);</span><br><span class="line">+  cursor-&gt;page_num = table-&gt;root_page_num;</span><br><span class="line">+  cursor-&gt;cell_num = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(root_node);</span><br><span class="line">+  cursor-&gt;end_of_table = (num_cells == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cursor;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">Cursor* <span class="title">table_end</span><span class="params">(Table* table)</span> </span>&#123;</span><br><span class="line">   Cursor* cursor = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Cursor));</span><br><span class="line">   cursor-&gt;table = table;</span><br><span class="line">-  cursor-&gt;row_num = table-&gt;num_rows;</span><br><span class="line">+  cursor-&gt;page_num = table-&gt;root_page_num;</span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(root_node);</span><br><span class="line">+  cursor-&gt;cell_num = num_cells;</span><br><span class="line">   cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cursor;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span>* <span class="title">cursor_value</span><span class="params">(Cursor* cursor)</span> </span>&#123;</span><br><span class="line">-  <span class="type">uint32_t</span> row_num = cursor-&gt;row_num;</span><br><span class="line">-  <span class="type">uint32_t</span> page_num = row_num / ROWS_PER_PAGE;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num = cursor-&gt;page_num;</span><br><span class="line">   <span class="type">void</span>* page = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, page_num);</span><br><span class="line">-  <span class="type">uint32_t</span> row_offset = row_num % ROWS_PER_PAGE;</span><br><span class="line">-  <span class="type">uint32_t</span> byte_offset = row_offset * ROW_SIZE;</span><br><span class="line">-  <span class="keyword">return</span> page + byte_offset;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_value</span>(page, cursor-&gt;cell_num);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">cursor_advance</span><span class="params">(Cursor* cursor)</span> </span>&#123;</span><br><span class="line">-  cursor-&gt;row_num += <span class="number">1</span>;</span><br><span class="line">-  <span class="keyword">if</span> (cursor-&gt;row_num &gt;= cursor-&gt;table-&gt;num_rows) &#123;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num = cursor-&gt;page_num;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, page_num);</span><br><span class="line">+</span><br><span class="line">+  cursor-&gt;cell_num += <span class="number">1</span>;</span><br><span class="line">+  <span class="keyword">if</span> (cursor-&gt;cell_num &gt;= (*<span class="built_in">leaf_node_num_cells</span>(node))) &#123;</span><br><span class="line">     cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Insertion-Into-a-Leaf-Node"><a href="#Insertion-Into-a-Leaf-Node" class="headerlink" title="Insertion Into a Leaf Node"></a>Insertion Into a Leaf Node</h3><p>在本章我们会实现一个只有一个节点的树.回忆一下上一章的一开始只有一个空的叶子节点的树:</p>
<p>empty btree</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree1.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree1.png" alt="empty btree"></a></p>
<p>键值对可以一直放入，直到叶子节点被填满:</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree2.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree2.png" alt="one-node btree"></a></p>
<p>当我们第一次打开数据库，数据库文件是空的，所以我们初始化 page 0 为一个空的叶子节点(也是根节点):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function">Table* <span class="title">db_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span> </span>&#123;</span><br><span class="line">   Pager* pager = <span class="built_in">pager_open</span>(filename);</span><br><span class="line">-  <span class="type">uint32_t</span> num_rows = pager-&gt;file_length / ROW_SIZE;</span><br><span class="line"></span><br><span class="line">   Table* table = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Table));</span><br><span class="line">   table-&gt;pager = pager;</span><br><span class="line">-  table-&gt;num_rows = num_rows;</span><br><span class="line">+  table-&gt;root_page_num = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (pager-&gt;num_pages == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="comment">// New database file. Initialize page 0 as leaf node.</span></span><br><span class="line">+    <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(pager, <span class="number">0</span>);</span><br><span class="line">+    <span class="built_in">initialize_leaf_node</span>(root_node);</span><br><span class="line">+  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> table;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>然后我们会创建一个用来向叶子节点中插入键值对的函数,函数的参数 cursor 包含键值对应该被插入的位置.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">void</span> <span class="title">leaf_node_insert</span><span class="params">(Cursor* cursor, <span class="type">uint32_t</span> key, Row* value)</span> </span>&#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);</span><br><span class="line">+</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">+  <span class="keyword">if</span> (num_cells &gt;= LEAF_NODE_MAX_CELLS) &#123;</span><br><span class="line">+    <span class="comment">// Node full</span></span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Need to implement splitting a leaf node.\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (cursor-&gt;cell_num &lt; num_cells) &#123;</span><br><span class="line">+    <span class="comment">// Make room for new cell</span></span><br><span class="line">+    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = num_cells; i &gt; cursor-&gt;cell_num; i--) &#123;</span><br><span class="line">+      <span class="built_in">memcpy</span>(<span class="built_in">leaf_node_cell</span>(node, i), <span class="built_in">leaf_node_cell</span>(node, i - <span class="number">1</span>),</span><br><span class="line">+             LEAF_NODE_CELL_SIZE);</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  *(<span class="built_in">leaf_node_num_cells</span>(node)) += <span class="number">1</span>;</span><br><span class="line">+  *(<span class="built_in">leaf_node_key</span>(node, cursor-&gt;cell_num)) = key;</span><br><span class="line">+  <span class="built_in">serialize_row</span>(value, <span class="built_in">leaf_node_value</span>(node, cursor-&gt;cell_num));</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br></pre></td></tr></table></figure>

<p>我们现在还没有实现分裂操作,所以如果 node 容量满了会退出程序.然后将插入位置后面的 cell 右移一位以给新的 cell 腾出空间，然后我们向空的空间写入 key&amp;value.</p>
<p>既然我们假设树只有一个节点，<code>execute_insert()</code>函数只需要调用这个辅助函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function">ExecuteResult <span class="title">execute_insert</span><span class="params">(Statement* statement, Table* table)</span> </span>&#123;</span><br><span class="line">-  <span class="keyword">if</span> (table-&gt;num_rows &gt;= TABLE_MAX_ROWS) &#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="keyword">if</span> ((*<span class="built_in">leaf_node_num_cells</span>(node) &gt;= LEAF_NODE_MAX_CELLS)) &#123;</span><br><span class="line">     <span class="keyword">return</span> EXECUTE_TABLE_FULL;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);</span><br><span class="line">   Cursor* cursor = <span class="built_in">table_end</span>(table);</span><br><span class="line"></span><br><span class="line">-  <span class="built_in">serialize_row</span>(row_to_insert, <span class="built_in">cursor_value</span>(cursor));</span><br><span class="line">-  table-&gt;num_rows += <span class="number">1</span>;</span><br><span class="line">+  <span class="built_in">leaf_node_insert</span>(cursor, row_to_insert-&gt;id, row_to_insert);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(cursor);</span><br></pre></td></tr></table></figure>

<p>通过这些改动，我们的数据库就能和之前一样工作了!除了现在它会更早地返回”Table 已满”错误，因为我们还不能分裂根节点.</p>
<p>叶子节点可以保存多少行呢?</p>
<h3 id="Command-to-Print-Constants"><a href="#Command-to-Print-Constants" class="headerlink" title="Command to Print Constants"></a>Command to Print Constants</h3><p>我增加了一个新的元命令，用来打印一些有趣的常量.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">void</span> <span class="title">print_constants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;ROW_SIZE: %d\n&quot;</span>, ROW_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;COMMON_NODE_HEADER_SIZE: %d\n&quot;</span>, COMMON_NODE_HEADER_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_HEADER_SIZE: %d\n&quot;</span>, LEAF_NODE_HEADER_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_CELL_SIZE: %d\n&quot;</span>, LEAF_NODE_CELL_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_SPACE_FOR_CELLS: %d\n&quot;</span>, LEAF_NODE_SPACE_FOR_CELLS);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_MAX_CELLS: %d\n&quot;</span>, LEAF_NODE_MAX_CELLS);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">@@ <span class="number">-294</span>,<span class="number">6</span> +<span class="number">376</span>,<span class="number">14</span> @@ <span class="function">MetaCommandResult <span class="title">do_meta_command</span><span class="params">(InputBuffer* input_buffer, Table* table)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">db_close</span>(table);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">+  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.constants&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Constants:\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">print_constants</span>();</span><br><span class="line">+    <span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> META_COMMAND_UNRECOGNIZED_COMMAND;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>我还添加了一个测试，可以用来提醒我们这些变量改变了:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  it <span class="string">&#x27;prints constants&#x27;</span> <span class="keyword">do</span></span><br><span class="line">+    script = [</span><br><span class="line">+      <span class="string">&quot;.constants&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;.exit&quot;</span>,</span><br><span class="line">+    ]</span><br><span class="line">+    result = <span class="built_in">run_script</span>(script)</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">expect</span>(result).to <span class="built_in">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; Constants:&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;ROW_SIZE: 293&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;COMMON_NODE_HEADER_SIZE: 6&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_HEADER_SIZE: 10&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_CELL_SIZE: 297&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_SPACE_FOR_CELLS: 4086&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_MAX_CELLS: 13&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; &quot;</span>,</span><br><span class="line">+    ])</span><br><span class="line">+  end</span><br></pre></td></tr></table></figure>

<p>现在我们的 table 可以保存 13 行喔!</p>
<h3 id="Tree-Visualization"><a href="#Tree-Visualization" class="headerlink" title="Tree Visualization"></a>Tree Visualization</h3><p>为了便于调试和可视化,我还增加了一个元命令来打印出 btree 表现形式.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+<span class="function"><span class="type">void</span> <span class="title">print_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;leaf (size %d)\n&quot;</span>, num_cells);</span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_cells; i++) &#123;</span><br><span class="line">+    <span class="type">uint32_t</span> key = *<span class="built_in">leaf_node_key</span>(node, i);</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;  - %d : %d\n&quot;</span>, i, key);</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-294</span>,<span class="number">6</span> +<span class="number">376</span>,<span class="number">14</span> @@ <span class="function">MetaCommandResult <span class="title">do_meta_command</span><span class="params">(InputBuffer* input_buffer, Table* table)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">db_close</span>(table);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">+  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.btree&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Tree:\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">print_leaf_node</span>(<span class="built_in">get_page</span>(table-&gt;pager, <span class="number">0</span>));</span><br><span class="line">+    <span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.constants&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Constants:\n&quot;</span>);</span><br><span class="line">     <span class="built_in">print_constants</span>();</span><br><span class="line">     <span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> META_COMMAND_UNRECOGNIZED_COMMAND;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以及一个测试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+  it <span class="string">&#x27;allows printing out the structure of a one-node btree&#x27;</span> <span class="keyword">do</span></span><br><span class="line">+    script = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>].map <span class="keyword">do</span> |i|</span><br><span class="line">+      <span class="string">&quot;insert #&#123;i&#125; user#&#123;i&#125; person#&#123;i&#125;@example.com&quot;</span></span><br><span class="line">+    end</span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;.btree&quot;</span></span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;.exit&quot;</span></span><br><span class="line">+    result = <span class="built_in">run_script</span>(script)</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">expect</span>(result).to <span class="built_in">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Tree:&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;leaf (size 3)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 0 : 3&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 1 : 1&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 2 : 2&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; &quot;</span></span><br><span class="line">+    ])</span><br><span class="line">+  end</span><br></pre></td></tr></table></figure>

<p>果咩，我们仍然没能有序地存储行.你可能注意到了<code>execute_insert()</code>函数在叶子节点的插入位置是由函数<code>table_end()</code>返回的.所以行是以插入的顺序排序的,就像之前一样.</p>
</br>

<h3 id="Next-Time"><a href="#Next-Time" class="headerlink" title="Next Time"></a>Next Time</h3><p>本章看起来像是倒退了一步.我们的数据库现在存储的行比之前少，并且我们存储的行仍然是无序的.但就像我在一开始说的，这是我们的一大步，并且将其分解成可管理的步骤很重要.</p>
<p>下一章，我们会实现根据 primary key(主键值)查找记录，然后有序地存储行.</p>
</br>

<h3 id="Complete-Diff"><a href="#Complete-Diff" class="headerlink" title="Complete Diff"></a>Complete Diff</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@@ <span class="number">-62</span>,<span class="number">29</span> +<span class="number">62</span>,<span class="number">101</span> @@ <span class="type">const</span> <span class="type">uint32_t</span> ROW_SIZE = ID_SIZE + USERNAME_SIZE + EMAIL_SIZE;</span><br><span class="line"></span><br><span class="line"> <span class="type">const</span> <span class="type">uint32_t</span> PAGE_SIZE = <span class="number">4096</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> TABLE_MAX_PAGES 100</span></span><br><span class="line">-<span class="type">const</span> <span class="type">uint32_t</span> ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;</span><br><span class="line">-<span class="type">const</span> <span class="type">uint32_t</span> TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="type">int</span> file_descriptor;</span><br><span class="line">   <span class="type">uint32_t</span> file_length;</span><br><span class="line">+  <span class="type">uint32_t</span> num_pages;</span><br><span class="line">   <span class="type">void</span>* pages[TABLE_MAX_PAGES];</span><br><span class="line"> &#125; Pager;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   Pager* pager;</span><br><span class="line">-  <span class="type">uint32_t</span> num_rows;</span><br><span class="line">+  <span class="type">uint32_t</span> root_page_num;</span><br><span class="line"> &#125; Table;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   Table* table;</span><br><span class="line">-  <span class="type">uint32_t</span> row_num;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num;</span><br><span class="line">+  <span class="type">uint32_t</span> cell_num;</span><br><span class="line">   <span class="type">bool</span> end_of_table;  <span class="comment">// Indicates a position one past the last element</span></span><br><span class="line"> &#125; Cursor;</span><br><span class="line"></span><br><span class="line">+<span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; NODE_INTERNAL, NODE_LEAF &#125; NodeType;</span><br><span class="line">+</span><br><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Common Node Header Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> NODE_TYPE_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> NODE_TYPE_OFFSET = <span class="number">0</span>;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> IS_ROOT_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> IS_ROOT_OFFSET = NODE_TYPE_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> PARENT_POINTER_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint8_t</span> COMMON_NODE_HEADER_SIZE =</span><br><span class="line">+    NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;</span><br><span class="line">+</span><br><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Leaf Node Header Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_NUM_CELLS_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_HEADER_SIZE =</span><br><span class="line">+    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;</span><br><span class="line">+</span><br><span class="line">+<span class="comment">/*</span></span><br><span class="line"><span class="comment">+ * Leaf Node Body Layout</span></span><br><span class="line"><span class="comment">+ */</span></span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_KEY_SIZE = <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_KEY_OFFSET = <span class="number">0</span>;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_VALUE_SIZE = ROW_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_VALUE_OFFSET =</span><br><span class="line">+    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;</span><br><span class="line">+<span class="type">const</span> <span class="type">uint32_t</span> LEAF_NODE_MAX_CELLS =</span><br><span class="line">+    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">leaf_node_num_cells</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + LEAF_NODE_NUM_CELLS_OFFSET;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span>* <span class="title">leaf_node_cell</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> node + LEAF_NODE_HEADER_SIZE + cell_num * LEAF_NODE_CELL_SIZE;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">uint32_t</span>* <span class="title">leaf_node_key</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_cell</span>(node, cell_num);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span>* <span class="title">leaf_node_value</span><span class="params">(<span class="type">void</span>* node, <span class="type">uint32_t</span> cell_num)</span> </span>&#123;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_cell</span>(node, cell_num) + LEAF_NODE_KEY_SIZE;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">print_constants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;ROW_SIZE: %d\n&quot;</span>, ROW_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;COMMON_NODE_HEADER_SIZE: %d\n&quot;</span>, COMMON_NODE_HEADER_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_HEADER_SIZE: %d\n&quot;</span>, LEAF_NODE_HEADER_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_CELL_SIZE: %d\n&quot;</span>, LEAF_NODE_CELL_SIZE);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_SPACE_FOR_CELLS: %d\n&quot;</span>, LEAF_NODE_SPACE_FOR_CELLS);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;LEAF_NODE_MAX_CELLS: %d\n&quot;</span>, LEAF_NODE_MAX_CELLS);</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">print_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123;</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">+  <span class="built_in">printf</span>(<span class="string">&quot;leaf (size %d)\n&quot;</span>, num_cells);</span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_cells; i++) &#123;</span><br><span class="line">+    <span class="type">uint32_t</span> key = *<span class="built_in">leaf_node_key</span>(node, i);</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;  - %d : %d\n&quot;</span>, i, key);</span><br><span class="line">+  &#125;</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">print_row</span><span class="params">(Row* row)</span> </span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;(%d, %s, %s)\n&quot;</span>, row-&gt;id, row-&gt;username, row-&gt;email);</span><br><span class="line"> &#125;</span><br><span class="line">@@ <span class="number">-101</span>,<span class="number">6</span> +<span class="number">173</span>,<span class="number">8</span> @@ <span class="function"><span class="type">void</span> <span class="title">deserialize_row</span><span class="params">(<span class="type">void</span> *source, Row* destination)</span> </span>&#123;</span><br><span class="line">     <span class="built_in">memcpy</span>(&amp;(destination-&gt;email), source + EMAIL_OFFSET, EMAIL_SIZE);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="type">void</span> <span class="title">initialize_leaf_node</span><span class="params">(<span class="type">void</span>* node)</span> </span>&#123; *<span class="built_in">leaf_node_num_cells</span>(node) = <span class="number">0</span>; &#125;</span><br><span class="line">+</span><br><span class="line"> <span class="function"><span class="type">void</span>* <span class="title">get_page</span><span class="params">(Pager* pager, <span class="type">uint32_t</span> page_num)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (page_num &gt; TABLE_MAX_PAGES) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Tried to fetch page number out of bounds. %d &gt; %d\n&quot;</span>, page_num,</span><br><span class="line">@@ <span class="number">-128</span>,<span class="number">6</span> +<span class="number">202</span>,<span class="number">10</span> @@ <span class="type">void</span>* <span class="built_in">get_page</span>(Pager* pager, <span class="type">uint32_t</span> page_num) &#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     pager-&gt;pages[page_num] = page;</span><br><span class="line">+</span><br><span class="line">+    <span class="keyword">if</span> (page_num &gt;= pager-&gt;num_pages) &#123;</span><br><span class="line">+      pager-&gt;num_pages = page_num + <span class="number">1</span>;</span><br><span class="line">+    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> pager-&gt;pages[page_num];</span><br><span class="line">@@ <span class="number">-136</span>,<span class="number">8</span> +<span class="number">214</span>,<span class="number">12</span> @@ <span class="type">void</span>* <span class="built_in">get_page</span>(Pager* pager, <span class="type">uint32_t</span> page_num) &#123;</span><br><span class="line"> Cursor* <span class="built_in">table_start</span>(Table* table) &#123;</span><br><span class="line">   Cursor* cursor = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Cursor));</span><br><span class="line">   cursor-&gt;table = table;</span><br><span class="line">-  cursor-&gt;row_num = <span class="number">0</span>;</span><br><span class="line">-  cursor-&gt;end_of_table = (table-&gt;num_rows == <span class="number">0</span>);</span><br><span class="line">+  cursor-&gt;page_num = table-&gt;root_page_num;</span><br><span class="line">+  cursor-&gt;cell_num = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(root_node);</span><br><span class="line">+  cursor-&gt;end_of_table = (num_cells == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cursor;</span><br><span class="line"> &#125;</span><br><span class="line">@@ <span class="number">-145</span>,<span class="number">24</span> +<span class="number">227</span>,<span class="number">28</span> @@ Cursor* <span class="built_in">table_start</span>(Table* table) &#123;</span><br><span class="line"> Cursor* <span class="built_in">table_end</span>(Table* table) &#123;</span><br><span class="line">   Cursor* cursor = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Cursor));</span><br><span class="line">   cursor-&gt;table = table;</span><br><span class="line">-  cursor-&gt;row_num = table-&gt;num_rows;</span><br><span class="line">+  cursor-&gt;page_num = table-&gt;root_page_num;</span><br><span class="line">+</span><br><span class="line">+  <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(root_node);</span><br><span class="line">+  cursor-&gt;cell_num = num_cells;</span><br><span class="line">   cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cursor;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span>* <span class="built_in">cursor_value</span>(Cursor* cursor) &#123;</span><br><span class="line">-  <span class="type">uint32_t</span> row_num = cursor-&gt;row_num;</span><br><span class="line">-  <span class="type">uint32_t</span> page_num = row_num / ROWS_PER_PAGE;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num = cursor-&gt;page_num;</span><br><span class="line">   <span class="type">void</span>* page = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, page_num);</span><br><span class="line">-  <span class="type">uint32_t</span> row_offset = row_num % ROWS_PER_PAGE;</span><br><span class="line">-  <span class="type">uint32_t</span> byte_offset = row_offset * ROW_SIZE;</span><br><span class="line">-  <span class="keyword">return</span> page + byte_offset;</span><br><span class="line">+  <span class="keyword">return</span> <span class="built_in">leaf_node_value</span>(page, cursor-&gt;cell_num);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> <span class="built_in">cursor_advance</span>(Cursor* cursor) &#123;</span><br><span class="line">-  cursor-&gt;row_num += <span class="number">1</span>;</span><br><span class="line">-  <span class="keyword">if</span> (cursor-&gt;row_num &gt;= cursor-&gt;table-&gt;num_rows) &#123;</span><br><span class="line">+  <span class="type">uint32_t</span> page_num = cursor-&gt;page_num;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, page_num);</span><br><span class="line">+</span><br><span class="line">+  cursor-&gt;cell_num += <span class="number">1</span>;</span><br><span class="line">+  <span class="keyword">if</span> (cursor-&gt;cell_num &gt;= (*<span class="built_in">leaf_node_num_cells</span>(node))) &#123;</span><br><span class="line">     cursor-&gt;end_of_table = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">@@ <span class="number">-185</span>,<span class="number">6</span> +<span class="number">271</span>,<span class="number">12</span> @@ Pager* <span class="built_in">pager_open</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line">   Pager* pager = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Pager));</span><br><span class="line">   pager-&gt;file_descriptor = fd;</span><br><span class="line">   pager-&gt;file_length = file_length;</span><br><span class="line">+  pager-&gt;num_pages = (file_length / PAGE_SIZE);</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (file_length % PAGE_SIZE != <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Db file is not a whole number of pages. Corrupt file.\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; TABLE_MAX_PAGES; i++) &#123;</span><br><span class="line">     pager-&gt;pages[i] = <span class="literal">NULL</span>;</span><br><span class="line">@@ <span class="number">-194</span>,<span class="number">11</span> +<span class="number">285</span>,<span class="number">15</span> @@ Pager* <span class="built_in">pager_open</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line">@@ <span class="number">-195</span>,<span class="number">11</span> +<span class="number">287</span>,<span class="number">16</span> @@ Pager* <span class="built_in">pager_open</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line"></span><br><span class="line"> Table* <span class="built_in">db_open</span>(<span class="type">const</span> <span class="type">char</span>* filename) &#123;</span><br><span class="line">   Pager* pager = <span class="built_in">pager_open</span>(filename);</span><br><span class="line">-  <span class="type">uint32_t</span> num_rows = pager-&gt;file_length / ROW_SIZE;</span><br><span class="line"></span><br><span class="line">   Table* table = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Table));</span><br><span class="line">   table-&gt;pager = pager;</span><br><span class="line">-  table-&gt;num_rows = num_rows;</span><br><span class="line">+  table-&gt;root_page_num = <span class="number">0</span>;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (pager-&gt;num_pages == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="comment">// New database file. Initialize page 0 as leaf node.</span></span><br><span class="line">+    <span class="type">void</span>* root_node = <span class="built_in">get_page</span>(pager, <span class="number">0</span>);</span><br><span class="line">+    <span class="built_in">initialize_leaf_node</span>(root_node);</span><br><span class="line">+  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> table;</span><br><span class="line"> &#125;</span><br><span class="line">@@ <span class="number">-234</span>,<span class="number">7</span> +<span class="number">331</span>,<span class="number">7</span> @@ <span class="type">void</span> <span class="built_in">close_input_buffer</span>(InputBuffer* input_buffer) &#123;</span><br><span class="line">     <span class="built_in">free</span>(input_buffer);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">-<span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size) &#123;</span><br><span class="line">+<span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num) &#123;</span><br><span class="line">   <span class="keyword">if</span> (pager-&gt;pages[page_num] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Tried to flush null page\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">@@ <span class="number">-242</span>,<span class="number">7</span> +<span class="number">337</span>,<span class="number">7</span> @@ <span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size) &#123;</span><br><span class="line">@@ <span class="number">-249</span>,<span class="number">7</span> +<span class="number">346</span>,<span class="number">7</span> @@ <span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size) &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">ssize_t</span> bytes_written =</span><br><span class="line">-      <span class="built_in">write</span>(pager-&gt;file_descriptor, pager-&gt;pages[page_num], size);</span><br><span class="line">+      <span class="built_in">write</span>(pager-&gt;file_descriptor, pager-&gt;pages[page_num], PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Error writing: %d\n&quot;</span>, errno);</span><br><span class="line">@@ <span class="number">-252</span>,<span class="number">29</span> +<span class="number">347</span>,<span class="number">16</span> @@ <span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size) &#123;</span><br><span class="line">@@ <span class="number">-260</span>,<span class="number">29</span> +<span class="number">357</span>,<span class="number">16</span> @@ <span class="type">void</span> <span class="built_in">pager_flush</span>(Pager* pager, <span class="type">uint32_t</span> page_num, <span class="type">uint32_t</span> size) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> <span class="built_in">db_close</span>(Table* table) &#123;</span><br><span class="line">   Pager* pager = table-&gt;pager;</span><br><span class="line">-  <span class="type">uint32_t</span> num_full_pages = table-&gt;num_rows / ROWS_PER_PAGE;</span><br><span class="line"></span><br><span class="line">-  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_full_pages; i++) &#123;</span><br><span class="line">+  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; pager-&gt;num_pages; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (pager-&gt;pages[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">-    <span class="built_in">pager_flush</span>(pager, i, PAGE_SIZE);</span><br><span class="line">+    <span class="built_in">pager_flush</span>(pager, i);</span><br><span class="line">     <span class="built_in">free</span>(pager-&gt;pages[i]);</span><br><span class="line">     pager-&gt;pages[i] = <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">-  <span class="comment">// There may be a partial page to write to the end of the file</span></span><br><span class="line">-  <span class="comment">// This should not be needed after we switch to a B-tree</span></span><br><span class="line">-  <span class="type">uint32_t</span> num_additional_rows = table-&gt;num_rows % ROWS_PER_PAGE;</span><br><span class="line">-  <span class="keyword">if</span> (num_additional_rows &gt; <span class="number">0</span>) &#123;</span><br><span class="line">-    <span class="type">uint32_t</span> page_num = num_full_pages;</span><br><span class="line">-    <span class="keyword">if</span> (pager-&gt;pages[page_num] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">-      <span class="built_in">pager_flush</span>(pager, page_num, num_additional_rows * ROW_SIZE);</span><br><span class="line">-      <span class="built_in">free</span>(pager-&gt;pages[page_num]);</span><br><span class="line">-      pager-&gt;pages[page_num] = <span class="literal">NULL</span>;</span><br><span class="line">-    &#125;</span><br><span class="line">-  &#125;</span><br><span class="line">-</span><br><span class="line">   <span class="type">int</span> result = <span class="built_in">close</span>(pager-&gt;file_descriptor);</span><br><span class="line">   <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Error closing db file.\n&quot;</span>);</span><br><span class="line">@@ <span class="number">-305</span>,<span class="number">6</span> +<span class="number">389</span>,<span class="number">14</span> @@ MetaCommandResult <span class="built_in">do_meta_command</span>(InputBuffer* input_buffer, Table *table) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.exit&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">db_close</span>(table);</span><br><span class="line">     <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">+  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.btree&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Tree:\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">print_leaf_node</span>(<span class="built_in">get_page</span>(table-&gt;pager, <span class="number">0</span>));</span><br><span class="line">+    <span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br><span class="line">+  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(input_buffer-&gt;buffer, <span class="string">&quot;.constants&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Constants:\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">print_constants</span>();</span><br><span class="line">+    <span class="keyword">return</span> META_COMMAND_SUCCESS;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> META_COMMAND_UNRECOGNIZED_COMMAND;</span><br><span class="line">   &#125;</span><br><span class="line">@@ <span class="number">-354</span>,<span class="number">16</span> +<span class="number">446</span>,<span class="number">39</span> @@ PrepareResult <span class="built_in">prepare_statement</span>(InputBuffer* input_buffer,</span><br><span class="line">   <span class="keyword">return</span> PREPARE_UNRECOGNIZED_STATEMENT;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">+<span class="type">void</span> <span class="built_in">leaf_node_insert</span>(Cursor* cursor, <span class="type">uint32_t</span> key, Row* value) &#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);</span><br><span class="line">+</span><br><span class="line">+  <span class="type">uint32_t</span> num_cells = *<span class="built_in">leaf_node_num_cells</span>(node);</span><br><span class="line">+  <span class="keyword">if</span> (num_cells &gt;= LEAF_NODE_MAX_CELLS) &#123;</span><br><span class="line">+    <span class="comment">// Node full</span></span><br><span class="line">+    <span class="built_in">printf</span>(<span class="string">&quot;Need to implement splitting a leaf node.\n&quot;</span>);</span><br><span class="line">+    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="keyword">if</span> (cursor-&gt;cell_num &lt; num_cells) &#123;</span><br><span class="line">+    <span class="comment">// Make room for new cell</span></span><br><span class="line">+    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = num_cells; i &gt; cursor-&gt;cell_num; i--) &#123;</span><br><span class="line">+      <span class="built_in">memcpy</span>(<span class="built_in">leaf_node_cell</span>(node, i), <span class="built_in">leaf_node_cell</span>(node, i - <span class="number">1</span>),</span><br><span class="line">+             LEAF_NODE_CELL_SIZE);</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  *(<span class="built_in">leaf_node_num_cells</span>(node)) += <span class="number">1</span>;</span><br><span class="line">+  *(<span class="built_in">leaf_node_key</span>(node, cursor-&gt;cell_num)) = key;</span><br><span class="line">+  <span class="built_in">serialize_row</span>(value, <span class="built_in">leaf_node_value</span>(node, cursor-&gt;cell_num));</span><br><span class="line">+&#125;</span><br><span class="line">+</span><br><span class="line"> ExecuteResult <span class="built_in">execute_insert</span>(Statement* statement, Table* table) &#123;</span><br><span class="line">-  <span class="keyword">if</span> (table-&gt;num_rows &gt;= TABLE_MAX_ROWS) &#123;</span><br><span class="line">+  <span class="type">void</span>* node = <span class="built_in">get_page</span>(table-&gt;pager, table-&gt;root_page_num);</span><br><span class="line">+  <span class="keyword">if</span> ((*<span class="built_in">leaf_node_num_cells</span>(node) &gt;= LEAF_NODE_MAX_CELLS)) &#123;</span><br><span class="line">     <span class="keyword">return</span> EXECUTE_TABLE_FULL;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);</span><br><span class="line">   Cursor* cursor = <span class="built_in">table_end</span>(table);</span><br><span class="line"></span><br><span class="line">-  <span class="built_in">serialize_row</span>(row_to_insert, <span class="built_in">cursor_value</span>(cursor));</span><br><span class="line">-  table-&gt;num_rows += <span class="number">1</span>;</span><br><span class="line">+  <span class="built_in">leaf_node_insert</span>(cursor, row_to_insert-&gt;id, row_to_insert);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(cursor);</span><br><span class="line"></span><br><span class="line">And the specs:</span><br><span class="line"></span><br><span class="line">+  it <span class="string">&#x27;allows printing out the structure of a one-node btree&#x27;</span> <span class="keyword">do</span></span><br><span class="line">+    script = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>].map <span class="keyword">do</span> |i|</span><br><span class="line">+      <span class="string">&quot;insert #&#123;i&#125; user#&#123;i&#125; person#&#123;i&#125;@example.com&quot;</span></span><br><span class="line">+    end</span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;.btree&quot;</span></span><br><span class="line">+    script &lt;&lt; <span class="string">&quot;.exit&quot;</span></span><br><span class="line">+    result = <span class="built_in">run_script</span>(script)</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">expect</span>(result).to <span class="built_in">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Executed.&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; Tree:&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;leaf (size 3)&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 0 : 3&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 1 : 1&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;  - 2 : 2&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; &quot;</span></span><br><span class="line">+    ])</span><br><span class="line">+  end</span><br><span class="line">+</span><br><span class="line">+  it <span class="string">&#x27;prints constants&#x27;</span> <span class="keyword">do</span></span><br><span class="line">+    script = [</span><br><span class="line">+      <span class="string">&quot;.constants&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;.exit&quot;</span>,</span><br><span class="line">+    ]</span><br><span class="line">+    result = <span class="built_in">run_script</span>(script)</span><br><span class="line">+</span><br><span class="line">+    <span class="built_in">expect</span>(result).to <span class="built_in">match_array</span>([</span><br><span class="line">+      <span class="string">&quot;db &gt; Constants:&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;ROW_SIZE: 293&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;COMMON_NODE_HEADER_SIZE: 6&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_HEADER_SIZE: 10&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_CELL_SIZE: 297&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_SPACE_FOR_CELLS: 4086&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;LEAF_NODE_MAX_CELLS: 13&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;db &gt; &quot;</span>,</span><br><span class="line">+    ])</span><br><span class="line">+  end</span><br><span class="line"> end</span><br></pre></td></tr></table></figure>



<h3 id="Part-9-Binary-Search-and-Duplicate-Keys"><a href="#Part-9-Binary-Search-and-Duplicate-Keys" class="headerlink" title="Part 9 - Binary Search and Duplicate Keys"></a>Part 9 - Binary Search and Duplicate Keys</h3>
    </div>
  </div>
</article> 
  </div>
  
<link rel="stylesheet" href="/css/footer.css">


<div id="footer"></div>
 
</body>