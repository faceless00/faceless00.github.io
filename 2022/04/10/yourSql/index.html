<!DOCTYPE html>
<html lang=" ">
<head>
  <meta charset="utf-8" />
<link rel="icon" href="/images/rev_sheep.png " />
<title>almostSalted</title>
<meta name="referrer" content="no-referrer" />
<meta name="google-site-verification" content="_CsSd0yrTQQrdEyoybq1kZNTZbIVulPo3zdQnaqAR0Y" />
<link rel="stylesheet" href="/css/highlight/styles/monokai.min.css" />
  
<link rel="stylesheet" href="/css/layout.css">

<meta name="generator" content="Hexo 6.1.0"></head>
<body>
  
<link rel="stylesheet" href="/css/header.css">


<div class="topBar">
  <img class="icon" src="/images/rev_sheep.png " />
  <div class="menu">
     
    <a href="/ ">home</a>
     
    <a href="/archives ">archives</a>
     
    <a href="/categories ">categories</a>
     
    <a href="/aboutme ">aboutme</a>
     
    <a href="/diary ">diary</a>
    
  </div>
</div>
<div class="blank"></div>
  <div class="wrapper">
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div id="post">
  <aside id="navigator">
    <ol class="anchor"><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#Prerequisites"><span class="anchor-number">1.</span> <span class="anchor-text">Prerequisites</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#AVL-%E6%A0%91"><span class="anchor-number">1.1.</span> <span class="anchor-text">AVL æ ‘</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Definition"><span class="anchor-number">1.1.1.</span> <span class="anchor-text">Definition</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#%E5%B9%B3%E8%A1%A1"><span class="anchor-number">1.1.2.</span> <span class="anchor-text">å¹³è¡¡</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="anchor-number">1.1.3.</span> <span class="anchor-text">ä»£ç å®ç°</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Conclusion"><span class="anchor-number">1.1.4.</span> <span class="anchor-text">Conclusion</span></a></li></ol></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#B-tree"><span class="anchor-number">1.2.</span> <span class="anchor-text">B tree</span></a></li></ol></li><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#Content"><span class="anchor-number">2.</span> <span class="anchor-text">Content</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part-1-Introduction-and-Setting-up-the-REPL"><span class="anchor-number">2.1.</span> <span class="anchor-text">Part 1-Introduction and Setting up the REPL</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Sqlite"><span class="anchor-number">2.1.1.</span> <span class="anchor-text">Sqlite</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Making-a-Simple-REPL"><span class="anchor-number">2.1.2.</span> <span class="anchor-text">Making a Simple REPL</span></a></li></ol></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part-2-World%E2%80%99s-Simplest-SQL-Compiler-and-Virtual-Machine"><span class="anchor-number">2.2.</span> <span class="anchor-text">Part 2 - Worldâ€™s Simplest SQL Compiler and Virtual Machine</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part3-An-In-Memory-Append-Only-Single-Table-Database"><span class="anchor-number">2.3.</span> <span class="anchor-text">Part3 - An In-Memory,Append-Only,Single-Table Database</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part-4-Our-First-Tests-and-Bugs"><span class="anchor-number">2.4.</span> <span class="anchor-text">Part 4 - Our First Tests (and Bugs)</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part-5-Persistence-to-Disk"><span class="anchor-number">2.5.</span> <span class="anchor-text">Part 5 - Persistence to Disk</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Conclusion-1"><span class="anchor-number">2.5.1.</span> <span class="anchor-text">Conclusion</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Complete-Diff"><span class="anchor-number">2.5.2.</span> <span class="anchor-text">Complete Diff</span></a></li></ol></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part-6-The-Cursor-Abstraction"><span class="anchor-number">2.6.</span> <span class="anchor-text">Part 6 - The Cursor Abstraction</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Part-7-Introduction-to-the-B-Tree"><span class="anchor-number">2.7.</span> <span class="anchor-text">Part 7 - Introduction to the B-Tree</span></a></li></ol></li></ol>
  </aside>
  <div id="content">
    <div id="postHead">
      <h1>yourSql 1</h1>
      <div class="postDate">
        <img class="dateIcon" src="/images/clockicon.svg" />
        --2022.4.10
      </div>
        
        <div class="postCategory">
            <a href="/categories/translation/">translation</a>
        </div>
         
    </div>
    <div id="postBody">
      <h1 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h1><h2 id="AVL-æ ‘"><a href="#AVL-æ ‘" class="headerlink" title="AVL æ ‘"></a>AVL æ ‘</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p><code>Adelson-Velsky &amp; Landis</code>æ ‘ï¼Œä¹Ÿå«å¹³è¡¡äºŒå‰æ ‘ï¼Œç®€ç•¥çš„è¯´å°±æ˜¯<code>BST</code>å’Œé«˜åº¦å¹³è¡¡çš„äºŒå‰æ ‘çš„èåˆ</p>
<blockquote>
<p><code>BST</code>ï¼ŒäºŒå‰æœç´¢æ ‘ï¼Œå¯ä»¥çœ‹ä½œæ˜¯ä»¥æ ‘ç»“æ„å­˜å‚¨çš„å‡åºæ•°ç»„</p>
<p>é«˜åº¦å¹³è¡¡çš„äºŒå‰æ ‘ï¼Œä»»æ„èŠ‚ç‚¹çš„å·¦å³å­æ ‘é«˜åº¦å·®<code>&lt;=1</code>ï¼Œæ¯”å¦‚è¿™æ£µå°±æ˜¯<img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-10/01a11ac9dc0c3bc1f67c7403cb1523d3.png" alt="image-20220410171609821"></p>
</blockquote>
<p><code>AVL</code>çš„é€’å½’å®šä¹‰ä¸º:</p>
<ol>
<li>æ˜¯<code>BST</code>ï¼Œä¸”å·¦å³å­æ ‘é«˜åº¦å·®çš„ç»å¯¹å€¼<code>&lt;=1</code></li>
<li>å­æ ‘ä¹Ÿæ˜¯<code>AVL</code></li>
</ol>
<blockquote>
<p><code>balance factor</code>:å¹³è¡¡å› å­ï¼Œå› ä¸º<code>AVL</code>æ˜¯é«˜åº¦å¹³è¡¡çš„ï¼Œæ‰€ä»¥éœ€è¦ä¸€ä¸ªæŒ‡æ ‡åˆ¤æ–­æ˜¯å¦å¹³è¡¡ï¼Œåœ¨å¤±è¡¡åè§¦å‘å¹³è¡¡æ“ä½œ</p>
<p><code>BL=abs(h(n-&gt;left)-h(n-&gt;right))</code>ï¼Œå³å·¦å³å­æ ‘çš„é«˜åº¦å·®</p>
<p>åŸºäºå¹³è¡¡å› å­ï¼Œ<code>AVL</code>çš„ç¬¬äºŒæ¡å®šä¹‰å¯ä»¥ä¸º:ä»»æ„èŠ‚ç‚¹çš„å¹³è¡¡å› å­çš„ç»å¯¹å€¼<code>&lt;=1</code></p>
<p>æ ‘çš„é«˜åº¦å®šä¹‰:</p>
<blockquote>
<p>ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„åŒ…å«çš„èŠ‚ç‚¹æ•°çš„æœ€å¤§å€¼(åŒ…æ‹¬æ ¹èŠ‚ç‚¹)</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">leetcode</a>ï¼Œè™½ç„¶æ±‚å¾—æ˜¯æœ€å¤§æ·±åº¦ï¼Œä¸è¿‡æ·±åº¦å’Œé«˜åº¦å…¶å®å·®ä¸å¤š</p>
<p>ååºéå†:<img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-10/2ce9c3e7010ec20c30d927cd2d5e5975.png" alt="image-20220410173756581"></p>
<p>å…ˆåºéå†:<img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-10/c853a40ef29f606d41b721cd861de3f6.png" alt="image-20220410174114294"></p>
</blockquote>
</blockquote>
<p>æ’å…¥å’Œåˆ é™¤èŠ‚ç‚¹ä¹‹åï¼Œè¦æ›´æ–°é«˜åº¦ï¼Œè¦æ›´æ–°é«˜åº¦çš„èŠ‚ç‚¹ä¸ºæ“ä½œèŠ‚ç‚¹çš„æ‰€æœ‰ç¥–å…ˆèŠ‚ç‚¹</p>
<h3 id="å¹³è¡¡"><a href="#å¹³è¡¡" class="headerlink" title="å¹³è¡¡"></a>å¹³è¡¡</h3><p>å¹³è¡¡æ˜¯è‡ªåº•è€Œä¸Šçš„ï¼Œå³ä»ç¦»æ“ä½œèŠ‚ç‚¹æœ€è¿‘çš„å¤±è¡¡çš„ç¥–å…ˆèŠ‚ç‚¹å¼€å§‹ï¼Œå¹³è¡¡æœ‰ä¸¤ç§æ“ä½œï¼Œå·¦æ—‹å’Œå³æ—‹</p>
<p>å³æ—‹:</p>
<blockquote>
<p><code>c.balanceFactor &gt; 1</code></p>
<p><img src="https://pic3.zhimg.com/80/v2-eee97a3e3e45d8cb6668841f6b44191a_720w.jpg" alt="img"></p>
<p><code>C</code>èŠ‚ç‚¹åŠå…¶å­èŠ‚ç‚¹éƒ½æ˜¯<code>&gt;=</code>B çš„ï¼Œæ‰€ä»¥å¯ä»¥æ¥åˆ° B çš„å³å­æ ‘ï¼Œå¦‚æœèŠ‚ç‚¹ B æœ‰å³å­æ ‘ï¼Œé€šå¸¸çš„ç­–ç•¥æ˜¯å…ˆæ–­å¼€ B çš„å³å­æ ‘ï¼Œå°† C æ¥åˆ° B çš„å³è¾¹ï¼Œç„¶åæŠŠå³å­æ ‘æ¥åˆ° C çš„å·¦è¾¹</p>
</blockquote>
<p>åŒç†ï¼Œå·¦æ—‹å’Œå³æ—‹åŸºæœ¬æ˜¯å¯¹ç§°çš„æ“ä½œ</p>
<p>æ—‹è½¬æ“ä½œä¼šæ”¹å˜æ ‘çš„ç»“æ„ï¼Œæ–¹ä¾¿èµ·è§ï¼ŒèŠ‚ç‚¹çš„ç»“æ„ä¸­<code>parent</code>ä¸ºæŒ‡å‘çˆ¶èŠ‚ç‚¹çš„æŒ‡é’ˆ</p>
<p>å·¦æ—‹ç¤ºä¾‹:</p>
<pre><code class="c">typedef struct Node &#123;
    Node* left;
    Node* right;
    Node* parent;
    int val;
    int height;
    int factor;
&#125;node,*nptr;
node* LeftRotate(node* cur) &#123;	//å·¦æ—‹cur
    if (!cur) return;
    if (cur-&gt;parent) &#123;
        node* n =
            (cur-&gt;parent-&gt;left == cur) ? cur-&gt;parent-&gt;left : cur-&gt;parent-&gt;right;
        n = cur-&gt;right;
        cur-&gt;right-&gt;parent = cur-&gt;parent;
    &#125;
    node* cr = cur-&gt;right;
    node* crl = cr-&gt;left;
    if (crl) crl-&gt;parent = cur;
    cur-&gt;right = crl;
    cr-&gt;left = cur;
    return cur-&gt;parent = cr;	//cur-&gt;parent=cr;return cr;
&#125;
</code></pre>
<p>ä¸¾ä¸ªç®€å•çš„ä¾‹å­ï¼š</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-11/9a705d5ca9bc82655603ccbe19cbc402.png" alt="image-20220411224513434"></p>
<p><code>x</code>æ˜¯æ–°æ’å…¥çš„èŠ‚ç‚¹ï¼Œæ­¤æ—¶ R çš„å¹³è¡¡å› å­ä¸º<code>&gt; 1</code>ï¼Œè¿™ç§æƒ…å†µå¯ä»¥å«åš<code>LL</code>å‹ï¼ŒR çš„<strong>å·¦å­æ ‘</strong>RL çš„<strong>å·¦å­æ ‘</strong>æ–°æ’å…¥äº†èŠ‚ç‚¹ï¼Œå¹³è¡¡æ“ä½œä¸ºèŠ‚ç‚¹ R å³æ—‹</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-11/13bd3c2daacc4cacd35af2f113b079c5.png" alt="image-20220411224902843">ç„¶åå°±å¹³è¡¡äº† ğŸ¤ </p>
<p>å†ä¸¾ä¸€ä¸ªä¾‹å­ï¼š</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-11/9a57fd7e0fff43b08f3b2b3061e5b160.png" alt="image-20220411225349437"></p>
<p>R çš„å¹³è¡¡å› å­ä»ç„¶æ˜¯ 2,ä½†æ˜¯æ’å…¥çš„èŠ‚ç‚¹åœ¨ RL çš„å³å­æ ‘ï¼Œè¿™ç§æƒ…å†µå¯ä»¥å«åš LR å‹ï¼Œéœ€è¦è¿›è¡Œä¸¤æ¬¡æ—‹è½¬æ“ä½œç„¶åå¹³è¡¡</p>
<p>é¦–å…ˆç»™ RL å·¦æ—‹:</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-11/65c9aca259f50d0751f6b59d9492db2f.png" alt="image-20220411225739881">èªæ˜çš„ä½ ä¸€å®šå‘ç°äº†ï¼Œå·¦æ—‹ä¹‹åå˜æˆäº† LL å‹ï¼Œæ‰€ä»¥æ¥ä¸‹æ¥å†ç»™ R è¿›è¡Œä¸€æ¬¡å³æ—‹æ“ä½œ:</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-11/be1b88cbb344601ef3faee1320fafe5a.png" alt="image-20220411225944026">äºæ˜¯åˆå¹³è¡¡äº†</p>
<p>å½“ç„¶ï¼ŒLR å‹åŒ…å«äº†ä¸‰ç§æƒ…å†µï¼Œè¿™é‡Œæ˜¯<code>RRR</code>èŠ‚ç‚¹çš„å¹³è¡¡å› å­ä¸º<code>-1</code>ï¼Œè¿˜æœ‰<code>0 1</code>è¿™ä¸¤ç§ï¼Œä½†æ˜¯æœ¬è´¨ä¸Šéƒ½æ˜¯é€šè¿‡å·¦æ—‹<code>RL</code>èŠ‚ç‚¹ï¼Œå˜æˆ<code>LL</code>å‹ï¼Œç„¶åå³æ—‹<code>R</code>æœ€ç»ˆå¹³è¡¡</p>
<p>è‡³äº<code>RR,RL</code>å‹ï¼Œå’Œ<code>LL,LR</code>æ˜¯<strong>å¯¹ç§°</strong>æ“ä½œï¼Œè¿™é‡Œä¸å†èµ˜è¿°</p>
<h3 id="ä»£ç å®ç°"><a href="#ä»£ç å®ç°" class="headerlink" title="ä»£ç å®ç°"></a>ä»£ç å®ç°</h3><p>æ‡’å¾—å†™â€¦ä»¥åè¡¥</p>
<p><code>AVL</code>ä¸æ™®é€š<code>BST</code>æœ‰åŒºåˆ«çš„æ“ä½œåœ¨äº<strong>æ’å…¥å’Œåˆ é™¤</strong>æ—¶ï¼Œéœ€è¦å¯¹å¯èƒ½å—å½±å“çš„èŠ‚ç‚¹å¹³è¡¡ï¼Œå¯èƒ½å—å½±å“çš„èŠ‚ç‚¹ï¼Œå®é™…ä¸Šå°±æ˜¯æ“ä½œèŠ‚ç‚¹çš„æ‰€æœ‰ç¥–å…ˆèŠ‚ç‚¹ï¼Œå› ä¸ºè¿™äº›èŠ‚ç‚¹çš„å¹³è¡¡å› å­ä¼šå‘ç”Ÿå˜åŒ–(å­æ ‘é«˜åº¦å˜äº†)</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>å®é™…ä¸Šï¼Œ<code>AVL</code>å°±æ˜¯ä¸€æ£µç‰¹æ®Šçš„<code>BST</code>ï¼Œåªæ˜¯å¯¹é«˜åº¦è¿›è¡Œäº†é™åˆ¶ï¼Œé‚£ä¹ˆï¼Œ<code>AVL</code>çš„åº”ç”¨åœºæ™¯åœ¨ä»€ä¹ˆåœ°æ–¹æï¼Ÿ</p>
<p>ä¼ ç»Ÿçš„<code>BST</code>å¾ˆå®¹æ˜“é€€åŒ–æˆä¸€æ¡é“¾ï¼Œè¿™æ—¶çš„æŸ¥æ‰¾å¤æ‚åº¦å°±å˜æˆäº†<code>O(n)</code>ï¼Œè€Œ<code>AVL</code>é€šè¿‡å¹³è¡¡ï¼Œä¿è¯æ ‘æ•´ä½“ç»“æ„ç›¸å¯¹å¯¹ç§°ï¼ŒæŸ¥æ‰¾å¤æ‚åº¦æ€»æ˜¯<code>O(logn)</code></p>
<p>ä¸è¿‡ç”±äºå¹³è¡¡æ“ä½œå¾ˆè€—æ€§èƒ½ï¼Œæ‰€ä»¥åªé€‚åˆå°‘é‡å¢åˆ èŠ‚ç‚¹ï¼Œå¤§é‡æŸ¥è¯¢çš„åœºæ™¯</p>
<h2 id="B-tree"><a href="#B-tree" class="headerlink" title="B tree"></a>B tree</h2><p>B ä½ å¦ˆ</p>
<p><a href="#Part-7-Introduction-to-the-B-Tree">Part 7</a></p>
<h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><h2 id="Part-1-Introduction-and-Setting-up-the-REPL"><a href="#Part-1-Introduction-and-Setting-up-the-REPL" class="headerlink" title="Part 1-Introduction and Setting up the REPL"></a>Part 1-Introduction and Setting up the REPL</h2><p>ä½œä¸ºä¸€ä¸ªç½‘ç»œå¼€å‘è€…ï¼Œæˆ‘æ¯å¤©éƒ½åœ¨å·¥ä½œä¸­ä½¿ç”¨å…³è”æ€§æ•°æ®åº“ï¼Œä½†æ˜¯å®ƒä»¬å¯¹äºæˆ‘æ¥è¯´æ˜¯ä¸€ä¸ªé»‘ç›’å­.æˆ‘æœ‰ä¸€äº›ç–‘æƒ‘:</p>
<ul>
<li>æ•°æ®å­˜å‚¨å½¢å¼æ˜¯ä»€ä¹ˆï¼Ÿ(å†…å­˜å’Œç£ç›˜)</li>
<li>æ•°æ®ä»€ä¹ˆæ—¶å€™ä»å†…å­˜ä¸­ç§»åŠ¨åˆ°ç£ç›˜ï¼Ÿ</li>
<li>ä¸ºä»€ä¹ˆæ¯ä¸ªè¡¨åªèƒ½æœ‰ä¸€ä¸ªä¸» keyï¼Ÿ</li>
<li>å›æ»šäº‹åŠ¡æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿ</li>
<li>ç´¢å¼•æ˜¯å¦‚ä½•æ ¼å¼åŒ–çš„ï¼Ÿ</li>
<li>å…¨è¡¨æ‰«æä½•æ—¶ä»¥åŠå¦‚ä½•å‘ç”Ÿï¼Ÿ</li>
<li>å³å°†æ‰§è¡Œçš„è¯­å¥ä»¥ä»€ä¹ˆæ ¼å¼å‚¨å­˜ï¼Ÿ</li>
</ul>
<p>æ¢å¥è¯è¯´å°±æ˜¯ï¼Œæ•°æ®åº“æ˜¯å¦‚ä½• <strong>å·¥ä½œ</strong> çš„ï¼Ÿ</p>
<p>ä¸ºäº†æŠŠäº‹æƒ…å¼„æ¸…æ¥šï¼Œæˆ‘æ­£åœ¨ä»å¤´å¼€å§‹å†™ä¸€ä¸ªæ•°æ®åº“.å®ƒä»¥ sqlite ä¸ºæ¨¡æ¿ï¼Œå› ä¸ºå®ƒè¢«è®¾è®¡ä¸ºå°ä½“ç§¯ï¼ŒåŠŸèƒ½æ¯” MySql æˆ– PostgreSQL å°‘ï¼Œæ‰€ä»¥æˆ‘æ›´æœ‰å¸Œæœ›ç†è§£å®ƒ.æ•´ä¸ªæ•°æ®åº“è¢«å­˜å‚¨åœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­!</p>
<h3 id="Sqlite"><a href="#Sqlite" class="headerlink" title="Sqlite"></a>Sqlite</h3><p>åœ¨ Sqlite ç½‘ç«™ä¸Šæœ‰è®¸å¤š <a target="_blank" rel="noopener" href="https://www.sqlite.org/arch.html">å…³äº sqilite çš„å†…éƒ¨ç»“æ„çš„æ–‡ç« </a>ï¼Œæ­¤å¤–æˆ‘æœ‰ä¸€ä»½èµ„æ–™<a target="_blank" rel="noopener" href="https://play.google.com/store/books/details?id=9Z6IQQnX1JEC">SQLite Database System:Design and Implementation</a>.</p>
<p>sqlite ç»“æ„(<a target="_blank" rel="noopener" href="https://www.sqlite.org/zipvfs/doc/trunk/www/howitworks.wiki">howitworks.wiki</a>)</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/arch1.gif" alt="img"></p>
<p>ä¸€æ¬¡æŸ¥è¯¢é€šè¿‡ä¸€ç³»åˆ—ç»„ä»¶æ¥æ£€ç´¢æˆ–ä¿®æ”¹æ•°æ®.<strong>å‰ç«¯</strong> åŒ…æ‹¬:</p>
<ul>
<li>tokenizer</li>
<li>parser</li>
<li>code generator</li>
</ul>
<p>å‰ç«¯çš„è¾“å…¥æ˜¯ä¸€ä¸ª SQL æŸ¥è¯¢ï¼Œè¾“å‡ºæ˜¯ sqlite è™šæ‹Ÿå­—èŠ‚ç (æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªå¯è¢«æ•°æ®åº“æ‰§è¡Œçš„ç¼–è¯‘ç¨‹åº).</p>
<p><strong>åç«¯</strong> åŒ…æ‹¬:</p>
<ul>
<li>virtual machine</li>
<li>B-tree</li>
<li>pager</li>
<li>os interface</li>
</ul>
<p><strong>è™šæ‹Ÿæœº</strong> å°†å‰ç«¯ç”Ÿæˆçš„å­—èŠ‚ç å½“ä½œæŒ‡ä»¤.å®ƒå¯ä»¥åœ¨ä¸€ä¸ªæˆ–å¤šä¸ªè¡¨æ ¼æˆ–ç´¢å¼•ä¸Šæ‰§è¡Œæ“ä½œï¼Œæ¯ä¸ªè¡¨æˆ–ç´¢å¼•éƒ½è¢«å­˜å‚¨åœ¨ä¸€ä¸ªå«åš<code>B-tree</code>çš„æ•°æ®ç»“æ„ä¸­.è™šæ‹Ÿæœºæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ª switch è¯­å¥ï¼Œæ¡ä»¶æ˜¯å­—èŠ‚ç æŒ‡ä»¤.</p>
<p>æ¯ä¸ª<code>B-tree</code>åŒ…æ‹¬è®¸å¤šèŠ‚ç‚¹.æ¯ä¸ªèŠ‚ç‚¹çš„é•¿åº¦ä¸ºä¸€é¡µ.<code>B-tree</code>å¯ä»¥ä»ç£ç›˜ä¸­è¯»å–ä¸€é¡µæˆ–è€…é€šè¿‡å‘<code>pager</code>å‘å‡ºæŒ‡ä»¤ç„¶åå°†ä¸€é¡µå­˜å‚¨åˆ°ç£ç›˜ä¸Š.</p>
<p><strong>pager</strong> æ¥æ”¶å‘½ä»¤ä»¥è¯»å–æˆ–å†™å…¥æ•°æ®é¡µ.å®ƒè´Ÿè´£åœ¨åˆé€‚çš„ä½ç½®è¯»å–&#x2F;å†™å…¥æ•°æ®ï¼Œè¿˜å°†æœ€è¿‘è·å–çš„å‡ é¡µçš„ç¼“å­˜ä¿å­˜åœ¨å†…å­˜ä¸­ï¼Œå¹¶ä¸”å†³å®šé‚£äº›é¡µä½•æ—¶è¢«å†™å›ç£ç›˜.</p>
<p><strong>os interface(ç³»ç»Ÿæ¥å£)</strong> å±‚æ ¹æ® sqlite è¢«ç¼–è¯‘çš„å¹³å°è€Œæœ‰æ‰€åŒºåˆ«.åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä¸æ‰“ç®—æ”¯æŒå¤šä¸ªæ“ä½œç³»ç»Ÿ.</p>
<p><a target="_blank" rel="noopener" href="https://en.wiktionary.org/wiki/a_journey_of_a_thousand_miles_begins_with_a_single_step">åƒé‡Œä¹‹è¡Œï¼Œå§‹äºè¶³ä¸‹</a>ï¼Œæ‰€ä»¥è®©æˆ‘ä»¬ä»¥æ›´ç›´æ¥çš„æ–¹å¼å¼€å§‹:<code>the REPL(read-eval-print loop)</code></p>
<h3 id="Making-a-Simple-REPL"><a href="#Making-a-Simple-REPL" class="headerlink" title="Making a Simple REPL"></a>Making a Simple REPL</h3><p>å½“ä»å‘½ä»¤è¡Œæ‰§è¡Œ sqlite æ—¶ï¼Œä¼šè¿›å…¥ä¸€ä¸ªè¯»å–-æ‰§è¡Œ-è¾“å‡ºå¾ªç¯:</p>
<blockquote>
<p>~ sqlite3<br>SQLite version 3.16.0 2016-11-04 19:09:39<br>Enter â€œ.helpâ€ for usage hints.<br>Connected to a transient in-memory database.<br>Use â€œ.open FILENAMEâ€ to reopen on a persistent database.<br>sqlite&gt; create table users (id int, username varchar(255), email varchar(255));<br>sqlite&gt; .tables<br>users<br>sqlite&gt; .exit<br>~</p>
</blockquote>
<p>ä¸ºäº†å®ç°è¿™ä¸ªï¼Œæˆ‘ä»¬çš„ main å‡½æ•°å°†ä¼šæœ‰ä¸€ä¸ªæ— æ­¢å¢ƒçš„å¾ªç¯ï¼Œæ‰“å°æç¤ºï¼Œè·å–ä¸€è¡Œè¾“å…¥ï¼Œç„¶åæ‰§è¡Œè¿™è¡Œè¾“å…¥:</p>
<pre><code class="cpp">int main(int argc, char* argv[]) &#123;
  InputBuffer* input_buffer = new_input_buffer();
  while (true) &#123;
    print_prompt();
    read_input(input_buffer);

    if (strcmp(input_buffer-&gt;buffer, &quot;.exit&quot;) == 0) &#123;
      close_input_buffer(input_buffer);
      exit(EXIT_SUCCESS);
    &#125; else &#123;
      cout&lt;&lt;&quot;Unrecognized command &quot;&lt;&lt;
          &lt;&lt;input_buffer-&gt;buffer&lt;&lt;endl;
    &#125;
  &#125;
&#125;
</code></pre>
<p>æˆ‘ä»¬å°†<code>InputBuffer</code>å®šä¹‰ä¸ºä¸€ä¸ªå°åŒ…è£…å™¨ä»¥ä¾¿å­˜å‚¨å’Œ<code>getline</code>(<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man3/getline.3.html">ref</a>)äº¤äº’æ—¶çš„çŠ¶æ€.</p>
<pre><code class="cpp">typedef struct &#123;
    char* buffer;
    size_t buffer_length;
    ssize_t input_length;
&#125; InputBuffer;
InputBuffer* new_input_buffer()&#123;
    InputBuffer* input_buffer=InputBuffer* malloc(sizeof(InputBuffer));
    input_buffer-&gt;buffer=NULL;
    input_buffer-&gt;buffer_length=0;
    input_buffer-&gt;input_length=0;
    return input_buffer;
&#125;
</code></pre>
<p>ç„¶å,<code>print_prompt()</code>ç»™ç”¨æˆ·æ‰“å°æç¤ºï¼Œåœ¨è¯»å–ä¸€è¡Œè¾“å…¥ä¹‹å‰.</p>
<pre><code class="cpp">void print_prompt()&#123;cout&lt;&lt;&quot;db &gt; &quot;;&#125;
</code></pre>
<p>ä¸ºäº†è¯»å–ä¸€è¡Œè¾“å…¥ï¼Œä½¿ç”¨<a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man3/getline.3.html">getline</a>:</p>
<p><code>ssize_t getline(char **lineptr,size_t *n,FILE *stream);</code></p>
<p><code>lineptr</code>:ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘æˆ‘ä»¬ç”¨æ¥æŒ‡å‘åŒ…å«è¯»å–çš„è¡Œçš„ç¼“å†²åŒºçš„å˜é‡.å¦‚æœåœ¨è°ƒç”¨<code>getline()</code>ä¹‹å‰<code>*lineptr</code>è¢«è®¾ä¸º<code>NULL</code>ï¼Œé‚£ä¹ˆ<code>getline()</code>å°†ä¼šåˆ†é…ä¸€ä¸ªç¼“å†²åŒºç”¨æ¥å­˜å‚¨è¡Œï¼Œè¿™ä¸ªç¼“å†²åŒºåº”è¯¥ç”±ç”¨æˆ·é‡Šæ”¾ï¼Œå³ä½¿<code>getline()</code>è°ƒç”¨å¤±è´¥.</p>
<p><code>n</code>:ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘æˆ‘ä»¬ç”¨æ¥å­˜å‚¨åˆ†é…çš„ç¼“å†²åŒºçš„å¤§å°çš„å˜é‡.</p>
<p><code>stream</code>:ç”¨æ¥è¯»å–çš„è¾“å…¥æµ.æˆ‘ä»¬å°†ä»æ ‡å‡†è¾“å…¥æµä¸­è¯»å–.</p>
<p><code>return value</code>:è¯»å–çš„å­—èŠ‚æ•°ï¼Œå¯èƒ½å°äºç¼“å†²åŒºçš„å¤§å°.</p>
<p>æˆ‘ä»¬è®©<code>getline</code>è¯»å–çš„è¡Œå­˜å‚¨åœ¨<code>input_buffer-&gt;buffer</code>ï¼Œç¼“å†²åŒºå¤§å°æ˜¯<code>input_buffer-&gt;buffer_length</code>ï¼Œè¿”å›å€¼å­˜å‚¨åœ¨<code>input_buffer-&gt;input_length</code></p>
<p><code>buffer</code>çš„åˆå§‹å€¼ä¸ºnullï¼Œæ‰€ä»¥<code>getline</code>ä¼šåˆ†é…è¶³å¤Ÿçš„ç©ºé—´æ¥ä¿å­˜è¾“å…¥è¡Œï¼Œç„¶åè®©<code>buffer</code>æŒ‡å‘è¯¥ç©ºé—´.</p>
<pre><code class="cpp">void read_input(InputBuffer* input_buffer) &#123;
  ssize_t bytes_read =
      getline(&amp;(input_buffer-&gt;buffer), &amp;(input_buffer-&gt;buffer_length), stdin);

  if (bytes_read &lt;= 0) &#123;
    printf(&quot;Error reading input\n&quot;);
    exit(EXIT_FAILURE);	//define EXIT_FAILURE 1
  &#125;

  // å¿½ç•¥æ¢è¡Œç¬¦
  input_buffer-&gt;input_length = bytes_read - 1;
  input_buffer-&gt;buffer[bytes_read - 1] = 0;	//cè¯­è¨€å­—ç¬¦ä¸²ç»“æŸæ ‡å¿—ä¸º&#39;\0&#39;,æ•°å€¼ä¸º0
&#125;
</code></pre>
<p>ç°åœ¨æ˜¯æ—¶å€™å®šä¹‰ä¸€ä¸ªå‡½æ•°ç”¨æ¥é‡Šæ”¾åˆ†é…ç»™<code>InputBuffer *</code>å®ä¾‹ä»¥åŠæˆå‘˜å˜é‡<code>buffer</code>çš„ç©ºé—´äº†(è°ƒç”¨<code>read_input</code>çš„æ—¶å€™<code>getline</code>ç»™<code>input_buffer-&gt;buffer</code>åˆ†é…äº†å†…å­˜).</p>
<pre><code class="cpp">void close_input_buffer(InputBuffer* input_buffer)&#123;
    free(input_buffer-&gt;buffer);	//æ˜¾ç„¶,æ˜¯ç”¨å †åˆ†é…çš„ç©ºé—´
    free(input_buffer);
&#125;
</code></pre>
<p>æœ€åï¼Œè§£æç„¶åæ‰§è¡Œå‘½ä»¤.ç›®å‰åªæœ‰ä¸€ä¸ªå‘½ä»¤å¯ä»¥è¢«è¯†åˆ«:<code>.exit</code>ï¼Œç”¨æ¥ç»ˆæ­¢ç¨‹åºï¼Œå¦‚æœä¸æ˜¯<code>.exit</code>å°±æ‰“å°é”™è¯¯æ¶ˆæ¯ç„¶åç»§ç»­å¾ªç¯.</p>
<pre><code class="cpp">if (strcmp(input_buffer-&gt;buffer, &quot;.exit&quot;) == 0) &#123;
  close_input_buffer(input_buffer);
  exit(EXIT_SUCCESS);
&#125; else &#123;
  printf(&quot;Unrecognized command &#39;%s&#39;.\n&quot;, input_buffer-&gt;buffer);
&#125;
</code></pre>
<p>ç°åœ¨å°è¯•è¿è¡Œå®ƒå§~</p>
<blockquote>
<p>~ .&#x2F;db<br>db &gt; .tables<br>Unrecognized command â€˜.tablesâ€™.<br>db &gt; .exit<br>~</p>
</blockquote>
<p>å¥½äº†ï¼Œæˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªæœ‰ç”¨çš„REPL.åœ¨ä¸‹ä¸€éƒ¨åˆ†ï¼Œå°†è¦å¼€å‘æˆ‘ä»¬çš„å‘½ä»¤è¯­è¨€.</p>
<p>é¡ºä¾¿ï¼Œè¿™æ˜¯è¿™éƒ¨åˆ†çš„å…¨éƒ¨ä»£ç :</p>
<pre><code class="cpp">#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct &#123;
  char* buffer;
  size_t buffer_length;
  ssize_t input_length;
&#125; InputBuffer;

InputBuffer* new_input_buffer() &#123;
  InputBuffer* input_buffer = malloc(sizeof(InputBuffer));
  input_buffer-&gt;buffer = NULL;
  input_buffer-&gt;buffer_length = 0;
  input_buffer-&gt;input_length = 0;

  return input_buffer;
&#125;

void print_prompt() &#123; printf(&quot;db &gt; &quot;); &#125;

void read_input(InputBuffer* input_buffer) &#123;
  ssize_t bytes_read =
      getline(&amp;(input_buffer-&gt;buffer), &amp;(input_buffer-&gt;buffer_length), stdin);

  if (bytes_read &lt;= 0) &#123;
    printf(&quot;Error reading input\n&quot;);
    exit(EXIT_FAILURE);
  &#125;

  // Ignore trailing newline
  input_buffer-&gt;input_length = bytes_read - 1;
  input_buffer-&gt;buffer[bytes_read - 1] = 0;
&#125;

void close_input_buffer(InputBuffer* input_buffer) &#123;
    free(input_buffer-&gt;buffer);
    free(input_buffer);
&#125;

int main(int argc, char* argv[]) &#123;
  InputBuffer* input_buffer = new_input_buffer();
  while (true) &#123;
    print_prompt();
    read_input(input_buffer);

    if (strcmp(input_buffer-&gt;buffer, &quot;.exit&quot;) == 0) &#123;
      close_input_buffer(input_buffer);
      exit(EXIT_SUCCESS);
    &#125; else &#123;
      printf(&quot;Unrecognized command &#39;%s&#39;.\n&quot;, input_buffer-&gt;buffer);
    &#125;
  &#125;
&#125;
</code></pre>
<h2 id="Part-2-Worldâ€™s-Simplest-SQL-Compiler-and-Virtual-Machine"><a href="#Part-2-Worldâ€™s-Simplest-SQL-Compiler-and-Virtual-Machine" class="headerlink" title="Part 2 - Worldâ€™s Simplest SQL Compiler and Virtual Machine"></a>Part 2 - Worldâ€™s Simplest SQL Compiler and Virtual Machine</h2><p>æˆ‘ä»¬æ­£åœ¨å…‹éš†ä¸€ä»½sqlite.sqliteçš„<strong>å‰ç«¯</strong>æ˜¯ä¸€ä¸ªSQLç¼–è¯‘å™¨ï¼Œç”¨æ¥è§£æè¾“å…¥çš„å­—ç¬¦ä¸²ç„¶åè¾“å‡ºä¸€ç§å«åš<code>bytecode</code>(å­—èŠ‚ç )çš„å†…éƒ¨è¡¨ç¤º.</p>
<p>bytecodeè¢«ä¼ å…¥è™šæ‹Ÿæœº,ç„¶åç”±è™šæ‹Ÿæœºæ‰§è¡Œ.</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/arch2.gif" alt="img"></p>
<p>å°†äº‹æƒ…åˆ†æˆè¿™æ ·çš„ä¸¤æ­¥æœ‰2ä¸ªå¥½å¤„:</p>
<ul>
<li>å‡å°‘æ¯ä¸€éƒ¨åˆ†çš„å¤æ‚æ€§(e.g. è™šæ‹Ÿæœºä¸å…³å¿ƒè¯­æ³•é”™è¯¯)</li>
<li>Allows compiling common queries once and caching the bytecode for improved performance.</li>
</ul>
<p>è€ƒè™‘åˆ°è¿™ä¸€ç‚¹ï¼Œè®©æˆ‘ä»¬é‡æ„mainå‡½æ•°å¹¶ä¸”åœ¨è¿‡ç¨‹ä¸­æ”¯æŒä¸¤ä¸ªæ–°çš„å…³é”®è¯:</p>
<pre><code class="cpp">int main(int argc, char* argv[]) &#123;
   InputBuffer* input_buffer = new_input_buffer();
   while (true) &#123;
     print_prompt();
     read_input(input_buffer);

-    if (strcmp(input_buffer-&gt;buffer, &quot;.exit&quot;) == 0) &#123;
-      exit(EXIT_SUCCESS);
-    &#125; else &#123;
-      printf(&quot;Unrecognized command &#39;%s&#39;.\n&quot;, input_buffer-&gt;buffer);
+    if (input_buffer-&gt;buffer[0] == &#39;.&#39;) &#123;
+      switch (do_meta_command(input_buffer)) &#123;
+        case (META_COMMAND_SUCCESS):
+          continue;
+        case (META_COMMAND_UNRECOGNIZED_COMMAND):
+          cout&lt;&lt;&quot;Unrecognized command: &quot;&lt;&lt;input_buffer-&gt;buffer&lt;&lt;endl;
+          continue;
+      &#125;
     &#125;
+
+    Statement statement;
+    switch (prepare_statement(input_buffer, &amp;statement)) &#123;
+      case (PREPARE_SUCCESS):
+        break;
+      case (PREPARE_UNRECOGNIZED_STATEMENT):
+        cout&lt;&lt;&quot;Unrecognized keyword at start of: &quot;&lt;&lt;input_buffer-&gt;buffer&lt;&lt;endl;
+        continue;
+    &#125;
+
+    execute_statement(&amp;statement);
+    cout&lt;&lt;&quot;Executed.&quot;&lt;&lt;endl;
   &#125;
 &#125;
</code></pre>
<p>éSQLè¯­å¥åƒæ˜¯<code>.exit</code>è¢«ç§°ä½œ <strong>å…ƒå‘½ä»¤</strong>.å…ƒå‘½ä»¤ä»¥<code>.</code>å¼€å§‹,å› æ­¤æˆ‘ä»¬æ£€æŸ¥å¹¶åœ¨å•ç‹¬çš„å‡½æ•°ä¸­å¤„ç†å…ƒå‘½ä»¤.</p>
<p>ç„¶åï¼ŒåŠ ä¸€æ­¥ç”¨æ¥æŠŠè¾“å…¥è¡Œè½¬æ¢ä¸ºè¯­å¥çš„å†…éƒ¨è¡¨ç¤º.This is our hacky version of the sqlite front-end.</p>
<p>æœ€åï¼ŒæŠŠå‡†å¤‡å¥½çš„è¯­å¥ä¼ é€’ç»™<code>execute_statement</code>.è¿™ä¸ªå‡½æ•°æœ€ç»ˆä¼šæˆä¸ºæˆ‘ä»¬çš„è™šæ‹Ÿæœº.</p>
<p>æ³¨æ„ä¸¤ä¸ªæ–°å‡½æ•°è¿”å›çš„æ˜¯è¡¨ç¤ºæˆåŠŸæˆ–å¤±è´¥çš„æšä¸¾å˜é‡:</p>
<blockquote>
<pre><code class="cpp">typedef enum &#123;
  META_COMMAND_SUCCESS,
  META_COMMAND_UNRECOGNIZED_COMMAND
&#125; MetaCommandResult;

typedef enum &#123; PREPARE_SUCCESS, PREPARE_UNRECOGNIZED_STATEMENT &#125; PrepareResult;
</code></pre>
</blockquote>
<p>â€œUnrecognized statementâ€?è¿™æœ‰ç‚¹åƒä¸€ä¸ª exception.æˆ‘ä¸å¤ªå–œæ¬¢ä½¿ç”¨exception(è€Œä¸”Cç”šè‡³éƒ½ä¸æ”¯æŒ)ï¼Œæ‰€ä»¥æˆ‘åœ¨ä»»ä½•å¯è¡Œçš„åœ°æ–¹éƒ½æ˜¯ç”¨<code>enum result code</code>.å¦‚æœswitchè¯­å¥æ²¡æœ‰å¤„ç†å…¶ä¸­ä¸€ä¸ªæšä¸¾æˆå‘˜ï¼ŒCç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ›´æœ‰ä¿¡å¿ƒåœ°å¤„ç†å‡½æ•°çš„æ¯ä¸ªç»“æœ.é¢„è®¡æœªæ¥ä¼šæ·»åŠ æ›´å¤š<code>result code</code>.</p>
<p>do_meta_commandåªæ˜¯ç°æœ‰åŠŸèƒ½çš„ä¸€ä¸ªè£…é¥°å™¨ï¼Œç”¨æ¥ç»™æ›´å¤šå‘½ä»¤é¢„ç•™ç©ºé—´.</p>
<pre><code class="cpp">MetaCommandResult do_meta_command(InputBuffer* input_buffer) &#123;
  if (strcmp(input_buffer-&gt;buffer, &quot;.exit&quot;) == 0) &#123;
    exit(EXIT_SUCCESS);
  &#125; else &#123;
    return META_COMMAND_UNRECOGNIZED_COMMAND;
  &#125;
&#125;
</code></pre>
<p>ç›®å‰çš„<code>prepared statement</code>åªåŒ…å«ä¸€ä¸ªæœ‰ä¸¤ä¸ªæˆå‘˜çš„æšä¸¾å˜é‡ï¼Œå› ä¸ºæˆ‘ä»¬å…è®¸statementsæœ‰å‚æ•°ï¼Œå®ƒå°†åŒ…å«æ›´å¤šæ•°æ®.</p>
<pre><code class="cpp">typedef enum &#123; STATEMENT_INSERT, STATEMENT_SELECT &#125; StatementType;

typedef struct &#123;
  StatementType type;
&#125; Statement;
</code></pre>
<p>prepare_statement(æˆ‘ä»¬çš„â€SQLç¼–è¯‘å™¨â€)ç°åœ¨è¿˜ä¸èƒ½ç†è§£SQLè¯­å¥.å®é™…ä¸Šå®ƒåªèƒ½ç†è§£ä¸¤ä¸ªè¯:</p>
<pre><code class="cpp">PrepareResult prepare_statement(InputBuffer* input_buffer,
                                Statement* statement) &#123;
  if (strncmp(input_buffer-&gt;buffer, &quot;insert&quot;, 6) == 0) &#123;
    statement-&gt;type = STATEMENT_INSERT;
    return PREPARE_SUCCESS;
  &#125;
  if (strcmp(input_buffer-&gt;buffer, &quot;select&quot;) == 0) &#123;
    statement-&gt;type = STATEMENT_SELECT;
    return PREPARE_SUCCESS;
  &#125;

  return PREPARE_UNRECOGNIZED_STATEMENT;
&#125;
</code></pre>
<p>æ³¨æ„æˆ‘ä»¬ä½¿ç”¨çš„æ˜¯<code>strncmp</code>æ¥æ¯”è¾ƒå­—ç¬¦ä¸²å› ä¸º<code>insert</code>å•è¯åé¢è·Ÿç€æ•°æ®.(e.g. <code>insert 1 cstack foo@bar.com</code>)</p>
<p>æœ€å,<code>execute_statement</code>åŒ…å«ä¸€äº›stubs:</p>
<pre><code class="cpp">void execute_statement(Statement* statement) &#123;
  switch (statement-&gt;type) &#123;
    case (STATEMENT_INSERT):
      printf(&quot;This is where we would do an insert.\n&quot;);
      break;
    case (STATEMENT_SELECT):
      printf(&quot;This is where we would do a select.\n&quot;);
      break;
  &#125;
&#125;
</code></pre>
<p>æ³¨æ„å‡½æ•°ä¸è¿”å›ä»»ä½•é”™è¯¯ç ,å› ä¸ºç›®å‰è¿˜ä¸ä¼šå‡ºç°é”™è¯¯.</p>
<p>é‡æ„ä¹‹åï¼Œç°åœ¨å¯ä»¥è¯†åˆ«ä¸¤ä¸ªæ–°å…³é”®å­—äº†!</p>
<blockquote>
<p>~ .&#x2F;db<br>db &gt; insert foo bar<br>This is where we would do an insert.<br>Executed.<br>db &gt; delete foo<br>Unrecognized keyword at start of â€˜delete fooâ€™.<br>db &gt; select<br>This is where we would do a select.<br>Executed.<br>db &gt; .tables<br>Unrecognized command â€˜.tablesâ€™<br>db &gt; .exit<br>~</p>
</blockquote>
<p>æˆ‘ä»¬æ•°æ®åº“ç¨‹åºçš„éª¨æ¶æ­£åœ¨é€æ­¥æ„å»ºâ€¦å¦‚æœå®ƒèƒ½å¤Ÿå­˜å‚¨æ•°æ®é‚£ä¸æ˜¯æ›´å¥½å—?åœ¨ä¸‹ä¸€ç« ï¼Œæˆ‘ä»¬å°†ä¼šå®ç°<code>insert</code>å’Œ<code>select</code>,åˆ›å»ºä¸–ç•Œä¸Šæœ€ç³Ÿç³•~çš„æ•°æ®å­˜å‚¨.é¡ºä¾¿ï¼Œè¿™é‡Œæœ‰æœ¬ç« çš„æ‰€æœ‰æ”¹åŠ¨:</p>
<pre><code class="cpp">@@ -10,6 +10,23 @@ struct InputBuffer_t &#123;
 &#125; InputBuffer;
 
+typedef enum &#123;
+  META_COMMAND_SUCCESS,
+  META_COMMAND_UNRECOGNIZED_COMMAND
+&#125; MetaCommandResult;
+
+typedef enum &#123; PREPARE_SUCCESS, PREPARE_UNRECOGNIZED_STATEMENT &#125; PrepareResult;
+
+typedef enum &#123; STATEMENT_INSERT, STATEMENT_SELECT &#125; StatementType;
+
+typedef struct &#123;
+  StatementType type;
+&#125; Statement;
+
 InputBuffer* new_input_buffer() &#123;
   InputBuffer* input_buffer = malloc(sizeof(InputBuffer));
   input_buffer-&gt;buffer = NULL;
@@ -40,17 +57,67 @@ void close_input_buffer(InputBuffer* input_buffer) &#123;
     free(input_buffer);
 &#125;
 
+MetaCommandResult do_meta_command(InputBuffer* input_buffer) &#123;
+  if (strcmp(input_buffer-&gt;buffer, &quot;.exit&quot;) == 0) &#123;
+    close_input_buffer(input_buffer);
+    exit(EXIT_SUCCESS);
+  &#125; else &#123;
+    return META_COMMAND_UNRECOGNIZED_COMMAND;
+  &#125;
+&#125;
+
+PrepareResult prepare_statement(InputBuffer* input_buffer,
+                                Statement* statement) &#123;
+  if (strncmp(input_buffer-&gt;buffer, &quot;insert&quot;, 6) == 0) &#123;
+    statement-&gt;type = STATEMENT_INSERT;
+    return PREPARE_SUCCESS;
+  &#125;
+  if (strcmp(input_buffer-&gt;buffer, &quot;select&quot;) == 0) &#123;
+    statement-&gt;type = STATEMENT_SELECT;
+    return PREPARE_SUCCESS;
+  &#125;
+
+  return PREPARE_UNRECOGNIZED_STATEMENT;
+&#125;
+
+void execute_statement(Statement* statement) &#123;
+  switch (statement-&gt;type) &#123;
+    case (STATEMENT_INSERT):
+      printf(&quot;This is where we would do an insert.\n&quot;);
+      break;
+    case (STATEMENT_SELECT):
+      printf(&quot;This is where we would do a select.\n&quot;);
+      break;
+  &#125;
+&#125;
+
 int main(int argc, char* argv[]) &#123;
   InputBuffer* input_buffer = new_input_buffer();
   while (true) &#123;
     print_prompt();
     read_input(input_buffer);
 
-    if (strcmp(input_buffer-&gt;buffer, &quot;.exit&quot;) == 0) &#123;
-      close_input_buffer(input_buffer);
-      exit(EXIT_SUCCESS);
-    &#125; else &#123;
-      printf(&quot;Unrecognized command &#39;%s&#39;.\n&quot;, input_buffer-&gt;buffer);
+    if (input_buffer-&gt;buffer[0] == &#39;.&#39;) &#123;
+      switch (do_meta_command(input_buffer)) &#123;
+        case (META_COMMAND_SUCCESS):
+          continue;
+        case (META_COMMAND_UNRECOGNIZED_COMMAND):
+          printf(&quot;Unrecognized command &#39;%s&#39;\n&quot;, input_buffer-&gt;buffer);
+          continue;
+      &#125;
     &#125;
+
+    Statement statement;
+    switch (prepare_statement(input_buffer, &amp;statement)) &#123;
+      case (PREPARE_SUCCESS):
+        break;
+      case (PREPARE_UNRECOGNIZED_STATEMENT):
+        printf(&quot;Unrecognized keyword at start of &#39;%s&#39;.\n&quot;,
+               input_buffer-&gt;buffer);
+        continue;
+    &#125;
+
+    execute_statement(&amp;statement);
+    printf(&quot;Executed.\n&quot;);
   &#125;
 &#125;
</code></pre>
<h2 id="Part3-An-In-Memory-Append-Only-Single-Table-Database"><a href="#Part3-An-In-Memory-Append-Only-Single-Table-Database" class="headerlink" title="Part3 - An In-Memory,Append-Only,Single-Table Database"></a>Part3 - An In-Memory,Append-Only,Single-Table Database</h2><p>æˆ‘ä»¬å…ˆå®ç°æœ€åŸºç¡€çš„åŠŸèƒ½ï¼Œå¹¶ç»™æ•°æ®åº“æ·»åŠ ä¸€äº›é™åˆ¶.ç›®å‰æ¥è¯´ï¼Œæ•°æ®åº“å°†:</p>
<ul>
<li>æ”¯æŒä¸¤ç§æ“ä½œ: æ’å…¥ä¸€è¡Œç„¶åæ‰“å°æ‰€æœ‰è¡Œ.</li>
<li>åªä¿å­˜åœ¨å†…å­˜ä¸­(è€Œä¸æ˜¯ç£ç›˜)</li>
<li>æ”¯æŒå•ä¸ªï¼Œç¡¬ç¼–ç çš„è¡¨</li>
</ul>
<p>æˆ‘ä»¬çš„ç¡¬ç¼–ç è¡¨å°†ä¼šå­˜å‚¨ç”¨æˆ·ï¼Œçœ‹èµ·æ¥åƒè¿™æ ·:</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-21/4c36e008a593cad02a5f4052452488ab.png" alt="image-20220421000123610"></p>
<p>è¿™æ˜¯ä¸€ä¸ªç®€å•çš„æ¨¡æ¿ï¼Œä½†æ˜¯æ”¯æŒå¤šç§æ•°æ®ç±»å‹å’Œé•¿åº¦å¯å˜çš„å­—ç¬¦ä¸².</p>
<p><code>insert</code>è¯­å¥çœ‹èµ·æ¥åƒè¿™æ ·:</p>
<p><code>insert 1 cstack foo@bar.com</code></p>
<p>è¿™æ„å‘³ç€æˆ‘ä»¬éœ€è¦æ‰©å±•<code>prepare_statement</code>å‡½æ•°ä»¥è§£æå‚æ•°</p>
<pre><code class="cpp">   if (strncmp(input_buffer-&gt;buffer, &quot;insert&quot;, 6) == 0) &#123;
     statement-&gt;type = STATEMENT_INSERT;
+    int args_assigned = sscanf(
+        input_buffer-&gt;buffer, &quot;insert %d %s %s&quot;, &amp;(statement-&gt;row_to_insert.id),
+        statement-&gt;row_to_insert.username, statement-&gt;row_to_insert.email);
+    if (args_assigned &lt; 3) &#123;
+      return PREPARE_SYNTAX_ERROR;
+    &#125;
     return PREPARE_SUCCESS;
   &#125;
   if (strcmp(input_buffer-&gt;buffer, &quot;select&quot;) == 0) &#123;
</code></pre>
<p>æˆ‘ä»¬æŠŠè§£æå¾—åˆ°çš„å‚æ•°æ”¾è¿›statementå¯¹è±¡çš„æ–°æˆå‘˜Rowä¸­.</p>
<pre><code class="cpp">+#define COLUMN_USERNAME_SIZE 32
+#define COLUMN_EMAIL_SIZE 255
+typedef struct &#123;
+  uint32_t id;
+  char username[COLUMN_USERNAME_SIZE];
+  char email[COLUMN_EMAIL_SIZE];
+&#125; Row;
+
 typedef struct &#123;
   StatementType type;
+  Row row_to_insert;  // only used by insert statement
 &#125; Statement;
</code></pre>
<p>ç°åœ¨æˆ‘ä»¬éœ€è¦æŠŠæ•°æ®æ‹·è´åˆ°è¡¨ç¤ºè¡¨çš„æ•°æ®ç»“æ„ä¸­.SQLiteä½¿ç”¨<code>B-tree</code>ä»¥å®ç°å¿«é€ŸæŸ¥æ‰¾ï¼Œæ’å…¥å’Œåˆ é™¤.æˆ‘ä»¬ä¸€å¼€å§‹å…ˆç”¨ç®€å•ç‚¹çš„æ•°æ®ç»“æ„.ç±»ä¼¼ä¸€æ£µ<code>B-tree</code>ï¼Œå®ƒå°†è¡Œå­˜è¿›é¡µä¸­ï¼Œä½†æ˜¯é¡µå¹¶ä¸ä»¥æ ‘çš„å½¢å¼ç»„ç»‡ï¼Œè€Œæ˜¯ä»¥åˆ—è¡¨çš„å½¢å¼.</p>
<p>è¿™æ˜¯æˆ‘çš„æƒ³æ³•:</p>
<ul>
<li>å°†è¡Œå­˜å‚¨åœ¨å«åšé¡µçš„å†…å­˜å—</li>
<li>æ¯ä¸€é¡µå­˜å‚¨å°½å¯èƒ½å¤šçš„è¡Œ</li>
<li>æ¯ä¸€é¡µä¸­è¡Œè¢«åºåˆ—åŒ–æˆç´§å‡‘çš„è¡¨ç°å½¢å¼</li>
<li>é¡µåªåœ¨éœ€è¦çš„æ—¶å€™åˆ†é…</li>
<li>ç»´æŠ¤ä¸€ä¸ªå®šé•¿æ•°ç»„ï¼Œæ•°ç»„æ•°æ®æ˜¯æŒ‡å‘é¡µçš„æŒ‡é’ˆ</li>
</ul>
<p>é¦–å…ˆæˆ‘ä»¬å®šä¹‰è¡Œçš„ç´§å‡‘çš„è¡¨ç°å½¢å¼:</p>
<pre><code class="cpp">+#define size_of_attribute(Struct, Attribute) sizeof(((Struct*)0)-&gt;Attribute)
+
+const uint32_t ID_SIZE = size_of_attribute(Row, id);
+const uint32_t USERNAME_SIZE = size_of_attribute(Row, username);
+const uint32_t EMAIL_SIZE = size_of_attribute(Row, email);
+const uint32_t ID_OFFSET = 0;
+const uint32_t USERNAME_OFFSET = ID_OFFSET + ID_SIZE;
+const uint32_t EMAIL_OFFSET = USERNAME_OFFSET + USERNAME_SIZE;
+const uint32_t ROW_SIZE = ID_SIZE + USERNAME_SIZE + EMAIL_SIZE;
</code></pre>
<blockquote>
<p>è¯‘è€…æ³¨:</p>
<p>å¯¹äºé‚£ä¸ªå¥‡å½¢æ€ªçŠ¶çš„å®	<code>#define size_of_attribute(Struct,Attribute)</code></p>
<p>ä½œç”¨æ˜¯è®¡ç®—ç»“æ„ä½“æˆå‘˜å˜é‡çš„å¤§å°</p>
<p>ä¸¾ä¸ªä¾‹å­ï¼Œå®å±•å¼€åä¼šæ˜¯è¿™æ ·:</p>
<p><code>sizeof(((Row*)0)-&gt;email)</code></p>
<p>0è¢«å¼ºåˆ¶è½¬åŒ–ä¸ºRowæŒ‡é’ˆï¼Œç„¶å0å°±å¯ä»¥è®¿é—®æˆå‘˜å˜é‡.</p>
<p>è¿™ä¸ªæ“ä½œä¸ä¼šåˆ›å»ºç»“æ„ä½“å®ä½“ï¼Œå› ä¸ºæ²¡æœ‰ç”¨<code>malloc</code>å¼€è¾Ÿç©ºé—´ï¼Œæ‰€ä»¥0å®é™…ä¸Šæ˜¯ä¸€ä¸ªé‡æŒ‡é’ˆï¼Œä½†æ˜¯<code>sizeof</code>ä¸åœ¨ä¹æ˜¯å¦é‡æŒ‡é’ˆï¼Œå®ƒåªéœ€è¦<strong>æŒ‡é’ˆæŒ‡å‘çš„å˜é‡ç±»å‹</strong>å°±å¯ä»¥åˆ¤æ–­å‡ºå¤§å°.(sizeofåœ¨ç¼–è¯‘æ—¶è¿è¡Œ)</p>
</blockquote>
<p>è¿™æ„å‘³ç€ä¸€ä¸ªåºåˆ—åŒ–çš„è¡Œçš„å¸ƒå±€çœ‹èµ·æ¥åƒè¿™æ ·:</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-21/a918324620a1ce8041b3e17ef971f96e.png" alt="image-20220421235558542"></p>
<p>We also need code to convert to and from the compact representation.</p>
<pre><code class="cpp">+void serialize_row(Row* source, void* destination) &#123;
+  memcpy(destination + ID_OFFSET, &amp;(source-&gt;id), ID_SIZE);
+  memcpy(destination + USERNAME_OFFSET, &amp;(source-&gt;username), USERNAME_SIZE);
+  memcpy(destination + EMAIL_OFFSET, &amp;(source-&gt;email), EMAIL_SIZE);
+&#125;
+
+void deserialize_row(void* source, Row* destination) &#123;
+  memcpy(&amp;(destination-&gt;id), source + ID_OFFSET, ID_SIZE);
+  memcpy(&amp;(destination-&gt;username), source + USERNAME_OFFSET, USERNAME_SIZE);
+  memcpy(&amp;(destination-&gt;email), source + EMAIL_OFFSET, EMAIL_SIZE);
+&#125;
</code></pre>
<p>æ¥ä¸‹æ¥ï¼Œå®šä¹‰Tableç»“æ„ä½“,æŒ‡å‘å­˜å‚¨ç€è¡Œçš„é¡µï¼Œä»¥åŠè¿½è¸ªæ€»è¡Œæ•°:</p>
<pre><code class="cpp">+const uint32_t PAGE_SIZE = 4096;
+#define TABLE_MAX_PAGES 100
+const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;
+const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;
+
+typedef struct &#123;
+  uint32_t num_rows;
+  void* pages[TABLE_MAX_PAGES];
+&#125; Table;
</code></pre>
<p>æ¯é¡µå¤§å°ä¸º4KB,å› ä¸ºè¿™å’Œå¤§å¤šæ•°è®¡ç®—æœºæ¶æ„çš„è™šæ‹Ÿå†…å­˜ç³»ç»Ÿä½¿ç”¨çš„é¡µä¸€è‡´.ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬æ•°æ®åº“çš„é¡µå¤§å°å’Œæ“ä½œç³»ç»Ÿä½¿ç”¨çš„é¡µå¤§å°ç›¸åŒ.æ“ä½œç³»ç»Ÿå°†ä¼šä»¥å®Œæ•´çš„å•å…ƒå°†é¡µç§»å…¥å’Œç§»å‡ºå†…å­˜ï¼Œè€Œä¸æ˜¯æ‹†æ•£å®ƒä»¬.</p>
<p>æˆ‘æŠŠæœ€å¤§åˆ†é…çš„é¡µçš„æ•°é‡è®¾ç½®ä¸ºä¸€ä¸ªéšæ„çš„æ•°å­—-100.å½“æˆ‘ä»¬åˆ‡æ¢åˆ°<code>B-Tree</code>ç»“æ„åï¼Œæˆ‘ä»¬æ•°æ®åº“çš„æœ€å¤§å¤§å°å°†ä»…å—é™äºä¸€ä¸ªæ–‡ä»¶çš„æœ€å¤§å¤§å°.(å°½ç®¡æˆ‘ä»¬ä»ä¼šé™åˆ¶åœ¨å†…å­˜ä¸­çš„é¡µçš„æ•°é‡)</p>
<p>è¡Œä¸åº”è¯¥ç©¿è¿‡é¡µçš„è¾¹ç•Œ.å› ä¸ºé¡µåœ¨å†…å­˜ä¸­çš„ä½ç½®å¾ˆå¯èƒ½ä¸æ˜¯å½¼æ­¤ç›¸é‚»çš„ï¼Œè¿™ä¸ªå‡è®¾è®©å†™å…¥&#x2F;è¯»å–è¡Œæ›´å®¹æ˜“äº›.(æ³¨: ç®€å•è§£é‡Šä¸€ä¸‹ï¼Œå¦‚æœæ¯é¡µè¡Œæ•°ä¸æ˜¯å‘ä¸‹å–æ•´ï¼Œå¯èƒ½ä¼šå‡ºç°ä¸€è¡Œè¢«åˆ†å‰²åˆ°äº†é€»è¾‘ä¸Šç›¸è¿çš„ä¸¤é¡µä¸Šï¼Œä½†ç”±äºé¡µçš„ç©ºé—´æ˜¯<code>malloc</code>å‡½æ•°åˆ†é…çš„ï¼Œå› æ­¤ç‰©ç†åœ°å€ä¸ä¸€å®šç›¸è¿ï¼Œéœ€è¦é¢å¤–å¤„ç†è¿™ç§æƒ…å†µ.)</p>
<p>è¯´åˆ°è¡Œçš„è¯»å†™ï¼Œä¸‹é¢æ˜¯æˆ‘ä»¬å¦‚ä½•ç¡®å®šåœ¨å†…å­˜çš„ä»€ä¹ˆä½ç½®è¯»å–&#x2F;å†™å…¥å…·ä½“è¡Œ:</p>
<pre><code class="cpp">+void* row_slot(Table* table, uint32_t row_num) &#123;
+  uint32_t page_num = row_num / ROWS_PER_PAGE;
+  void* page = table-&gt;pages[page_num];
+  if (page == NULL) &#123;
+    // Allocate memory only when we try to access page
+    page = table-&gt;pages[page_num] = malloc(PAGE_SIZE);
+  &#125;
+  uint32_t row_offset = row_num % ROWS_PER_PAGE;
+  uint32_t byte_offset = row_offset * ROW_SIZE;
+  return page + byte_offset;
+&#125;
</code></pre>
<p>ç„¶åæ˜¯å®ç°<code>execute_statement</code>å‡½æ•°,å¯ä»¥ä»tableç»“æ„ä½“è¯»å–&#x2F;å†™å…¥æ•°æ®.</p>
<pre><code class="cpp">-void execute_statement(Statement* statement) &#123;
+ExecuteResult execute_insert(Statement* statement, Table* table) &#123;
+  if (table-&gt;num_rows &gt;= TABLE_MAX_ROWS) &#123;
+    return EXECUTE_TABLE_FULL;
+  &#125;
+
+  Row* row_to_insert = &amp;(statement-&gt;row_to_insert);
+
+  serialize_row(row_to_insert, row_slot(table, table-&gt;num_rows));
+  table-&gt;num_rows += 1;
+
+  return EXECUTE_SUCCESS;
+&#125;
+
+ExecuteResult execute_select(Statement* statement, Table* table) &#123;
+  Row row;
+  for (uint32_t i = 0; i &lt; table-&gt;num_rows; i++) &#123;
+    deserialize_row(row_slot(table, i), &amp;row);
+    print_row(&amp;row);
+  &#125;
+  return EXECUTE_SUCCESS;
+&#125;
+
+ExecuteResult execute_statement(Statement* statement, Table* table) &#123;
   switch (statement-&gt;type) &#123;
     case (STATEMENT_INSERT):
-      printf(&quot;This is where we would do an insert.\n&quot;);
-      break;
+      return execute_insert(statement, table);
     case (STATEMENT_SELECT):
-      printf(&quot;This is where we would do a select.\n&quot;);
-      break;
+      return execute_select(statement, table);
   &#125;
 &#125;
</code></pre>
<blockquote>
<p>æ³¨: åŸä½œè€…å¥½åƒæ¼äº†<code>enum ExecuteResult</code>è€Œ<code>print_row()</code></p>
<p>è¡¥ä¸Š(æˆ‘è‡ªå·±çš„å®ç°)</p>
<pre><code class="cpp">typedef enum&#123;
    EXECUTE_SUCCESS,
    EXECUTE_TABLE_FULL
&#125; ExecuteResult;
void print_row(Row* row)&#123;
    cout&lt;&lt;&quot;ID: &quot;&lt;&lt;row-&gt;id&lt;&lt;endl
    &lt;&lt;&quot;username: &quot;&lt;&lt;row-&gt;username&lt;&lt;endl
    &lt;&lt;&quot;emal: &quot;&lt;&lt;row-&gt;email&lt;&lt;endl;
&#125;
</code></pre>
</blockquote>
<p>æœ€åï¼Œæˆ‘ä»¬éœ€è¦åˆå§‹åŒ–åˆ—è¡¨ï¼Œåˆ›å»ºå„è‡ªçš„å†…å­˜é‡Šæ”¾å‡½æ•°ä»¥åŠå¤„ç†ä¸€äº›é”™è¯¯æƒ…å†µ:</p>
<pre><code class="cpp">+ Table* new_table() &#123;
+  Table* table = (Table*)malloc(sizeof(Table));
+  table-&gt;num_rows = 0;
+  for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) &#123;
+     table-&gt;pages[i] = NULL;
+  &#125;
+  return table;
+&#125;
+
+void free_table(Table* table) &#123;
+    for (int i = 0; table-&gt;pages[i]; i++) &#123;
+	free(table-&gt;pages[i]);
+    &#125;
+    free(table);
+&#125;

 int main(int argc, char* argv[]) &#123;
+  Table* table = new_table();
   InputBuffer* input_buffer = new_input_buffer();
   while (true) &#123;
     print_prompt();
@@ -105,13 +203,22 @@ int main(int argc, char* argv[]) &#123;
     switch (prepare_statement(input_buffer, &amp;statement)) &#123;
       case (PREPARE_SUCCESS):
         break;
+      case (PREPARE_SYNTAX_ERROR):
+        printf(&quot;Syntax error. Could not parse statement.\n&quot;);
+        continue;
       case (PREPARE_UNRECOGNIZED_STATEMENT):
         printf(&quot;Unrecognized keyword at start of &#39;%s&#39;.\n&quot;,
                input_buffer-&gt;buffer);
         continue;
     &#125;

-    execute_statement(&amp;statement);
-    printf(&quot;Executed.\n&quot;);
+    switch (execute_statement(&amp;statement, table)) &#123;
+      case (EXECUTE_SUCCESS):
+        printf(&quot;Executed.\n&quot;);
+        break;
+      case (EXECUTE_TABLE_FULL):
+        printf(&quot;Error: Table full.\n&quot;);
+        break;
+    &#125;
   &#125;
 &#125;
</code></pre>
<blockquote>
<p>æ³¨:</p>
<p>å¯¹äºswitchä¸­çš„<code>continue &amp; break</code></p>
<p>ç®€å•æ¥è¯´ï¼Œ<code>break</code>åªé€€å‡º<code>switch</code>è¯­å¥æœ¬èº«</p>
<p>å¦‚æœ<code>switch</code>æ˜¯åœ¨å¾ªç¯ä½“ä¸­ï¼Œé‚£ä¹ˆ<code>continue</code>ä¼šè·³è¿‡<strong>æœ¬æ¬¡å¾ªç¯</strong>(å³ä¸æ‰§è¡Œswitchåé¢çš„è¯­å¥).</p>
</blockquote>
<p>åšå®Œè¿™äº›åæˆ‘ä»¬å°±å¯ä»¥å°†æ•°æ®ä¿å­˜åˆ°æ•°æ®åº“é‡Œè¾£!</p>
<pre><code>~ ./db
db &gt; insert 1 cstack foo@bar.com
Executed.
db &gt; insert 2 bob bob@example.com
Executed.
db &gt; select
(1, cstack, foo@bar.com)
(2, bob, bob@example.com)
Executed.
db &gt; insert foo bar 1
Syntax error. Could not parse statement.
db &gt; .exit
~
</code></pre>
<p>ç°åœ¨æ˜¯å†™ä¸€äº›æµ‹è¯•çš„æœ€å¥½æ—¶æœºå–”ï¼Œç†ç”±å¦‚ä¸‹:</p>
<ul>
<li>Weâ€™re planning to dramatically change the data structure storing our table, and tests would catch regressions.</li>
<li>æœ‰ä¸€äº›è¾¹é™…æƒ…å†µæˆ‘ä»¬è¿˜æ²¡æœ‰æ‰‹åŠ¨æµ‹è¯•(e.g. è¡¨è¢«å¡«æ»¡äº†)</li>
</ul>
<p>æˆ‘ä»¬å°†åœ¨ä¸‹ä¸€ç« è§£å†³è¿™äº›é—®é¢˜.è¿™é‡Œæœ‰æœ¬ç« ä»£ç çš„å…¨éƒ¨æ”¹åŠ¨:</p>
<pre><code class="cpp">@@ -2,6 +2,7 @@
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
+#include &lt;stdint.h&gt;

 typedef struct &#123;
   char* buffer;
@@ -10,6 +11,105 @@ typedef struct &#123;
 &#125; InputBuffer;

+typedef enum &#123; EXECUTE_SUCCESS, EXECUTE_TABLE_FULL &#125; ExecuteResult;
+
+typedef enum &#123;
+  META_COMMAND_SUCCESS,
+  META_COMMAND_UNRECOGNIZED_COMMAND
+&#125; MetaCommandResult;
+
+typedef enum &#123;
+  PREPARE_SUCCESS,
+  PREPARE_SYNTAX_ERROR,
+  PREPARE_UNRECOGNIZED_STATEMENT
+ &#125; PrepareResult;
+
+typedef enum &#123; STATEMENT_INSERT, STATEMENT_SELECT &#125; StatementType;
+
+#define COLUMN_USERNAME_SIZE 32
+#define COLUMN_EMAIL_SIZE 255
+typedef struct &#123;
+  uint32_t id;
+  char username[COLUMN_USERNAME_SIZE];
+  char email[COLUMN_EMAIL_SIZE];
+&#125; Row;
+
+typedef struct &#123;
+  StatementType type;
+  Row row_to_insert; //only used by insert statement
+&#125; Statement;
+
+#define size_of_attribute(Struct, Attribute) sizeof(((Struct*)0)-&gt;Attribute)
+
+const uint32_t ID_SIZE = size_of_attribute(Row, id);
+const uint32_t USERNAME_SIZE = size_of_attribute(Row, username);
+const uint32_t EMAIL_SIZE = size_of_attribute(Row, email);
+const uint32_t ID_OFFSET = 0;
+const uint32_t USERNAME_OFFSET = ID_OFFSET + ID_SIZE;
+const uint32_t EMAIL_OFFSET = USERNAME_OFFSET + USERNAME_SIZE;
+const uint32_t ROW_SIZE = ID_SIZE + USERNAME_SIZE + EMAIL_SIZE;
+
+const uint32_t PAGE_SIZE = 4096;
+#define TABLE_MAX_PAGES 100
+const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;
+const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;
+
+typedef struct &#123;
+  uint32_t num_rows;
+  void* pages[TABLE_MAX_PAGES];
+&#125; Table;
+
+void print_row(Row* row) &#123;
+  printf(&quot;(%d, %s, %s)\n&quot;, row-&gt;id, row-&gt;username, row-&gt;email);
+&#125;
+
+void serialize_row(Row* source, void* destination) &#123;
+  memcpy(destination + ID_OFFSET, &amp;(source-&gt;id), ID_SIZE);
+  memcpy(destination + USERNAME_OFFSET, &amp;(source-&gt;username), USERNAME_SIZE);
+  memcpy(destination + EMAIL_OFFSET, &amp;(source-&gt;email), EMAIL_SIZE);
+&#125;
+
+void deserialize_row(void *source, Row* destination) &#123;
+  memcpy(&amp;(destination-&gt;id), source + ID_OFFSET, ID_SIZE);
+  memcpy(&amp;(destination-&gt;username), source + USERNAME_OFFSET, USERNAME_SIZE);
+  memcpy(&amp;(destination-&gt;email), source + EMAIL_OFFSET, EMAIL_SIZE);
+&#125;
+
+void* row_slot(Table* table, uint32_t row_num) &#123;
+  uint32_t page_num = row_num / ROWS_PER_PAGE;
+  void *page = table-&gt;pages[page_num];
+  if (page == NULL) &#123;
+     // Allocate memory only when we try to access page
+     page = table-&gt;pages[page_num] = malloc(PAGE_SIZE);
+  &#125;
+  uint32_t row_offset = row_num % ROWS_PER_PAGE;
+  uint32_t byte_offset = row_offset * ROW_SIZE;
+  return page + byte_offset;
+&#125;
+
+Table* new_table() &#123;
+  Table* table = (Table*)malloc(sizeof(Table));
+  table-&gt;num_rows = 0;
+  for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) &#123;
+     table-&gt;pages[i] = NULL;
+  &#125;
+  return table;
+&#125;
+
+void free_table(Table* table) &#123;
+  for (int i = 0; table-&gt;pages[i]; i++) &#123;
+     free(table-&gt;pages[i]);
+  &#125;
+  free(table);
+&#125;
+
 InputBuffer* new_input_buffer() &#123;
   InputBuffer* input_buffer = (InputBuffer*)malloc(sizeof(InputBuffer));
   input_buffer-&gt;buffer = NULL;
@@ -40,17 +140,105 @@ void close_input_buffer(InputBuffer* input_buffer) &#123;
     free(input_buffer);
 &#125;

+MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table *table) &#123;
+  if (strcmp(input_buffer-&gt;buffer, &quot;.exit&quot;) == 0) &#123;
+    close_input_buffer(input_buffer);
+    free_table(table);
+    exit(EXIT_SUCCESS);
+  &#125; else &#123;
+    return META_COMMAND_UNRECOGNIZED_COMMAND;
+  &#125;
+&#125;
+
+PrepareResult prepare_statement(InputBuffer* input_buffer,
+                                Statement* statement) &#123;
+  if (strncmp(input_buffer-&gt;buffer, &quot;insert&quot;, 6) == 0) &#123;
+    statement-&gt;type = STATEMENT_INSERT;
+    int args_assigned = sscanf(
+	input_buffer-&gt;buffer, &quot;insert %d %s %s&quot;, &amp;(statement-&gt;row_to_insert.id),
+	statement-&gt;row_to_insert.username, statement-&gt;row_to_insert.email
+	);
+    if (args_assigned &lt; 3) &#123;
+	return PREPARE_SYNTAX_ERROR;
+    &#125;
+    return PREPARE_SUCCESS;
+  &#125;
+  if (strcmp(input_buffer-&gt;buffer, &quot;select&quot;) == 0) &#123;
+    statement-&gt;type = STATEMENT_SELECT;
+    return PREPARE_SUCCESS;
+  &#125;
+
+  return PREPARE_UNRECOGNIZED_STATEMENT;
+&#125;
+
+ExecuteResult execute_insert(Statement* statement, Table* table) &#123;
+  if (table-&gt;num_rows &gt;= TABLE_MAX_ROWS) &#123;
+     return EXECUTE_TABLE_FULL;
+  &#125;
+
+  Row* row_to_insert = &amp;(statement-&gt;row_to_insert);
+
+  serialize_row(row_to_insert, row_slot(table, table-&gt;num_rows));
+  table-&gt;num_rows += 1;
+
+  return EXECUTE_SUCCESS;
+&#125;
+
+ExecuteResult execute_select(Statement* statement, Table* table) &#123;
+  Row row;
+  for (uint32_t i = 0; i &lt; table-&gt;num_rows; i++) &#123;
+     deserialize_row(row_slot(table, i), &amp;row);
+     print_row(&amp;row);
+  &#125;
+  return EXECUTE_SUCCESS;
+&#125;
+
+ExecuteResult execute_statement(Statement* statement, Table *table) &#123;
+  switch (statement-&gt;type) &#123;
+    case (STATEMENT_INSERT):
+       	return execute_insert(statement, table);
+    case (STATEMENT_SELECT):
+	return execute_select(statement, table);
+  &#125;
+&#125;
+
 int main(int argc, char* argv[]) &#123;
+  Table* table = new_table();
   InputBuffer* input_buffer = new_input_buffer();
   while (true) &#123;
     print_prompt();
     read_input(input_buffer);

-    if (strcmp(input_buffer-&gt;buffer, &quot;.exit&quot;) == 0) &#123;
-      close_input_buffer(input_buffer);
-      exit(EXIT_SUCCESS);
-    &#125; else &#123;
-      printf(&quot;Unrecognized command &#39;%s&#39;.\n&quot;, input_buffer-&gt;buffer);
+    if (input_buffer-&gt;buffer[0] == &#39;.&#39;) &#123;
+      switch (do_meta_command(input_buffer, table)) &#123;
+        case (META_COMMAND_SUCCESS):
+          continue;
+        case (META_COMMAND_UNRECOGNIZED_COMMAND):
+          printf(&quot;Unrecognized command &#39;%s&#39;\n&quot;, input_buffer-&gt;buffer);
+          continue;
+      &#125;
+    &#125;
+
+    Statement statement;
+    switch (prepare_statement(input_buffer, &amp;statement)) &#123;
+      case (PREPARE_SUCCESS):
+        break;
+      case (PREPARE_SYNTAX_ERROR):
+	printf(&quot;Syntax error. Could not parse statement.\n&quot;);
+	continue;
+      case (PREPARE_UNRECOGNIZED_STATEMENT):
+        printf(&quot;Unrecognized keyword at start of &#39;%s&#39;.\n&quot;,
+               input_buffer-&gt;buffer);
+        continue;
+    &#125;
+
+    switch (execute_statement(&amp;statement, table)) &#123;
+	case (EXECUTE_SUCCESS):
+	    printf(&quot;Executed.\n&quot;);
+	    break;
+	case (EXECUTE_TABLE_FULL):
+	    printf(&quot;Error: Table full.\n&quot;);
+	    break;
     &#125;
   &#125;
 &#125;
</code></pre>
<h2 id="Part-4-Our-First-Tests-and-Bugs"><a href="#Part-4-Our-First-Tests-and-Bugs" class="headerlink" title="Part 4 - Our First Tests (and Bugs)"></a>Part 4 - Our First Tests (and Bugs)</h2><p>æˆ‘ä»¬å·²ç»å¯ä»¥å‘æ•°æ®åº“ä¸­æ’å…¥è¡Œç„¶åæ‰“å°æ‰€æœ‰è¡Œäº†.è®©æˆ‘ä»¬æµ‹è¯•ä¸€ä¸‹ç›®å‰å®ç°çš„åŠŸèƒ½.</p>
<p>æˆ‘å°†ä¼šä½¿ç”¨<a target="_blank" rel="noopener" href="http://rspec.info/">rspec</a>æ¥æµ‹è¯•å› ä¸ºæˆ‘æ¯”è¾ƒç†Ÿæ‚‰å®ƒ,å¹¶ä¸”å®ƒçš„è¯­æ³•ç›¸å½“å‹å¥½.</p>
<p>æˆ‘å°†å®šä¹‰ä¸€ä¸ªè¾…åŠ©å·¥å…·æ¥ç»™æ•°æ®åº“å‘é€å‘½ä»¤ç„¶åæ–­è¨€è¾“å‡º:</p>
<pre><code>describe &#39;database&#39; do
  def run_script(commands)
    raw_output = nil
    IO.popen(&quot;./db&quot;, &quot;r+&quot;) do |pipe|
      commands.each do |command|
        pipe.puts command
      end

      pipe.close_write

      # Read entire output
      raw_output = pipe.gets(nil)
    end
    raw_output.split(&quot;\n&quot;)
  end

  it &#39;inserts and retrieves a row&#39; do
    result = run_script([
      &quot;insert 1 user1 person1@example.com&quot;,
      &quot;select&quot;,
      &quot;.exit&quot;,
    ])
    expect(result).to match_array([
      &quot;db &gt; Executed.&quot;,
      &quot;db &gt; (1, user1, person1@example.com)&quot;,
      &quot;Executed.&quot;,
      &quot;db &gt; &quot;,
    ])
  end
end
</code></pre>
<p>æµ‹è¯•ç»“æœ:</p>
<pre><code>rspec test.rb

Finished in 0.00871 seconds (files took 0.09506 seconds to load)
1 example, 0 failures
</code></pre>
<p>æ˜¯æ—¶å€™æµ‹è¯•æ’å…¥å¤§é‡è¡Œäº†:</p>
<pre><code>it &#39;prints error message when table is full&#39; do
  script = (1..1401).map do |i|
    &quot;insert #&#123;i&#125; user#&#123;i&#125; person#&#123;i&#125;@example.com&quot;
  end
  script &lt;&lt; &quot;.exit&quot;
  result = run_script(script)
  expect(result[-2]).to eq(&#39;db &gt; Error: Table full.&#39;)
end
</code></pre>
<p>é‡æ–°æµ‹è¯•â€¦</p>
<pre><code>Finished in 0.01553 seconds (files took 0.08156 seconds to load)
2 examples, 0 failures
</code></pre>
<p>æµ‹è¯•æˆåŠŸ!æ•°æ®åº“ç›®å‰å¯ä»¥ä¿å­˜1400è¡Œå› ä¸ºæˆ‘ä»¬è®¾ç½®äº†æœ€å¤§é¡µæ•°ä¸º100,æ¯é¡µå¯ä»¥å­˜å‚¨14è¡Œ.</p>
<p>æ£€æŸ¥ä¸€ä¸‹ç›®å‰çš„ä»£ç ,å¯ä»¥å‘ç°æˆ‘ä»¬æ²¡æœ‰ä»”ç»†å¤„ç†æ–‡æœ¬å­—æ®µ,ç”¨è¿™ä¸ªä¾‹å­æµ‹è¯•:</p>
<pre><code>it &#39;allows inserting strings that are the maximum length&#39; do
  long_username = &quot;a&quot;*32
  long_email = &quot;a&quot;*255
  script = [
    &quot;insert 1 #&#123;long_username&#125; #&#123;long_email&#125;&quot;,
    &quot;select&quot;,
    &quot;.exit&quot;,
  ]
  result = run_script(script)
  expect(result).to match_array([
    &quot;db &gt; Executed.&quot;,
    &quot;db &gt; (1, #&#123;long_username&#125;, #&#123;long_email&#125;)&quot;,
    &quot;Executed.&quot;,
    &quot;db &gt; &quot;,
  ])
end
</code></pre>
<p>Faliures:</p>
<pre><code>  1) database allows inserting strings that are the maximum length
     Failure/Error: raw_output.split(&quot;\n&quot;)

     ArgumentError:
       invalid byte sequence in UTF-8
     # ./spec/main_spec.rb:14:in `split&#39;
     # ./spec/main_spec.rb:14:in `run_script&#39;
     # ./spec/main_spec.rb:48:in `block (2 levels) in &lt;top (required)&gt;&#39;
</code></pre>
<p>å¦‚æœæˆ‘ä»¬æ‰‹åŠ¨æµ‹è¯•ï¼Œæ‰“å°å‡ºæ¥çš„ç»“æœä¼šæœ‰ä¸€äº›å¥‡æ€ªçš„å­—ç¬¦:</p>
<pre><code>db &gt; insert 1 aaaaa... aaaaa...
Executed.
db &gt; select
(1, aaaaa...aaa\, aaaaa...aaa\)
Executed.
db &gt;
</code></pre>
<p>å‘ç”Ÿäº†ä»€ä¹ˆ?å¦‚æœæŸ¥çœ‹Rowçš„å®šä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ç»™usernameåˆ†é…äº†32å­—èŠ‚ï¼Œemail 255å­—èŠ‚.ä½†æ˜¯<a target="_blank" rel="noopener" href="http://www.cprogramming.com/tutorial/c/lesson9.html">C strings</a>åº”è¯¥ä»¥nullå­—ç¬¦(<code>&#39;\0&#39;</code>)ç»“å°¾,è€Œæˆ‘ä»¬å¹¶æ²¡æœ‰ç»™è¿™ä¸€ä½åˆ†é…ç©ºé—´.è§£å†³åŠæ³•æ˜¯é¢å¤–åˆ†é…ä¸€ä¸ªå­—èŠ‚:</p>
<pre><code class="cpp"> const uint32_t COLUMN_EMAIL_SIZE = 255;
 typedef struct &#123;
   uint32_t id;
-  char username[COLUMN_USERNAME_SIZE];
-  char email[COLUMN_EMAIL_SIZE];
+  char username[COLUMN_USERNAME_SIZE + 1];
+  char email[COLUMN_EMAIL_SIZE + 1];
 &#125; Row;
</code></pre>
<p>ç„¶åé—®é¢˜è¢«ä¿®å¤äº†:</p>
<pre><code>Finished in 0.0188 seconds (files took 0.08516 seconds to load)
3 examples, 0 failures
</code></pre>
<p>æˆ‘ä»¬ä¸åº”è¯¥å…è®¸æ’å…¥çš„usernameæˆ–emailè¶…è¿‡æœ€å¤§é•¿åº¦,è¿™ç§æƒ…å†µä¸‹ç»“æœåº”è¯¥åƒè¿™æ ·:</p>
<pre><code>it &#39;prints error message if strings are too long&#39; do
  long_username = &quot;a&quot;*33
  long_email = &quot;a&quot;*256
  script = [
    &quot;insert 1 #&#123;long_username&#125; #&#123;long_email&#125;&quot;,
    &quot;select&quot;,
    &quot;.exit&quot;,
  ]
  result = run_script(script)
  expect(result).to match_array([
    &quot;db &gt; String is too long.&quot;,
    &quot;db &gt; Executed.&quot;,
    &quot;db &gt; &quot;,
  ])
end
</code></pre>
<p>ä¸ºäº†å®ç°è¿™ä¸ªæˆ‘ä»¬éœ€è¦ä¿®æ”¹è§£æå™¨.æé†’ä¸€ä¸‹ï¼Œæˆ‘ä»¬è§£æè¾“å…¥ç”¨çš„æ˜¯<a target="_blank" rel="noopener" href="https://linux.die.net/man/3/scanf">scanf()</a>:</p>
<pre><code class="cpp">if (strncmp(input_buffer-&gt;buffer, &quot;insert&quot;, 6) == 0) &#123;
  statement-&gt;type = STATEMENT_INSERT;
  int args_assigned = sscanf(
      input_buffer-&gt;buffer, &quot;insert %d %s %s&quot;, &amp;(statement-&gt;row_to_insert.id),
      statement-&gt;row_to_insert.username, statement-&gt;row_to_insert.email);
//sscanfåªæ˜¯å°†è¾“å…¥ä»stdinå˜æˆstring
  if (args_assigned &lt; 3) &#123;
    return PREPARE_SYNTAX_ERROR;
  &#125;
  return PREPARE_SUCCESS;
&#125;
</code></pre>
<p>ä½†æ˜¯<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/2430303/disadvantages-of-scanf">scanfæœ‰ä¸€äº›ç¼ºç‚¹</a>.å¦‚æœè¯»å–çš„é•¿åº¦å¤§äºç›®æ ‡ç¼“å†²åŒºçš„é•¿åº¦ï¼Œä¼šé€ æˆç¼“å†²åŒºç§»é™¤å¹¶å°†å¤šä½™çš„æ•°æ®å†™å…¥é¢„æœŸä¹‹å¤–çš„åœ°æ–¹.æˆ‘ä»¬å¸Œæœ›åœ¨å°†æ•°æ®copyåˆ°Rowç»“æ„ä½“å†…ä¹‹å‰å…ˆæ£€æŸ¥æ¯ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦.ä¸ºäº†å®ç°è¿™ä¸ªåŠŸèƒ½ï¼Œæˆ‘ä»¬éœ€è¦ç”¨ç©ºæ ¼å°†è¾“å…¥åˆ†å‰²æˆå‡ ä¸ªéƒ¨åˆ†.</p>
<blockquote>
<p>è¯‘è€…æ³¨: äº‹å®ä¸Šï¼Œä¸å®Œå…¨æ­£ç¡®.</p>
<p>å¯ä»¥ç”¨æ ¼å¼å­—ç¬¦ä¸²é™åˆ¶é•¿åº¦	scanf(â€œ%<code>wid</code>sâ€,s1)</p>
<p>ä¾‹å¦‚é™åˆ¶å­—ç¬¦ä¸²é•¿åº¦ä¸º100	<code>scanf(&quot;%100s&quot;,s1)</code></p>
<p>é‡åˆ°<code>blank</code>æˆ–è€…è¯»å–100ä¸ªå­—ç¬¦å°±ä¼šç»“æŸ.ä¸è¿‡éœ€è¦è‡ªå·±ç¡®ä¿s1æœ‰é¢å¤–ç©ºé—´ä¿å­˜<code>\0</code>å­—ç¬¦</p>
<p><code>blank</code>: æŒ‡ ç©ºæ ¼(space),åˆ¶è¡¨ç¬¦(Tab),å›è½¦ç¬¦(â€˜\nâ€™).</p>
<p>scanfè¿˜æœ‰å¾ˆå¤šç‰¹æ€§ï¼Œæ¯”å¦‚ä¼šå¿½ç•¥å¼€å¤´çš„æ‰€æœ‰ç©ºç™½ç¬¦ï¼Œ%cè¿”å›é”®ç›˜ç¼“å†²åŒºçš„ç¬¬ä¸€ä¸ªå­—ç¬¦(åŒ…æ‹¬å›è½¦)â€¦</p>
<p>æ„Ÿå…´è¶£<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/io/c/fscanf">è‡ªè¡ŒæŸ¥é˜…</a></p>
</blockquote>
<p>ä½¿ç”¨<a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/cstring/strtok/">strtok()</a>æ¥å®ç°è¿™ä¸ªåŠŸèƒ½:</p>
<pre><code class="cpp">+PrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement) &#123;
+  statement-&gt;type = STATEMENT_INSERT;
+
+  char* keyword = strtok(input_buffer-&gt;buffer, &quot; &quot;);
+  char* id_string = strtok(NULL, &quot; &quot;);
+  char* username = strtok(NULL, &quot; &quot;);
+  char* email = strtok(NULL, &quot; &quot;);
+
+  if (id_string == NULL || username == NULL || email == NULL) &#123;
+    return PREPARE_SYNTAX_ERROR;
+  &#125;
+
+  int id = atoi(id_string);
+  if (strlen(username) &gt; COLUMN_USERNAME_SIZE) &#123;
+    return PREPARE_STRING_TOO_LONG;
+  &#125;
+  if (strlen(email) &gt; COLUMN_EMAIL_SIZE) &#123;
+    return PREPARE_STRING_TOO_LONG;
+  &#125;
+
+  statement-&gt;row_to_insert.id = id;
+  strcpy(statement-&gt;row_to_insert.username, username);
+  strcpy(statement-&gt;row_to_insert.email, email);
+
+  return PREPARE_SUCCESS;
+&#125;
+
 PrepareResult prepare_statement(InputBuffer* input_buffer,
                                 Statement* statement) &#123;
   if (strncmp(input_buffer-&gt;buffer, &quot;insert&quot;, 6) == 0) &#123;
+    return prepare_insert(input_buffer, statement);
-    statement-&gt;type = STATEMENT_INSERT;
-    int args_assigned = sscanf(
-        input_buffer-&gt;buffer, &quot;insert %d %s %s&quot;, &amp;(statement-&gt;row_to_insert.id),
-        statement-&gt;row_to_insert.username, statement-&gt;row_to_insert.email);
-    if (args_assigned &lt; 3) &#123;
-      return PREPARE_SYNTAX_ERROR;
-    &#125;
-    return PREPARE_SUCCESS;
   &#125;
</code></pre>
<p><code>strtok</code>åœ¨é‡åˆ°åˆ†å‰²å­—ç¬¦(æˆ‘ä»¬çš„ä¾‹å­ä¸­æ˜¯ç©ºæ ¼)æ—¶å°±æ’å…¥NULLå­—ç¬¦ï¼Œä»è€Œå°†è¾“å…¥ç¼“å†²åˆ†å‰²æˆäº†å­å­—ç¬¦ä¸².è¿”å›å€¼ä¸ºæŒ‡å‘å­ä¸²å¼€å¤´çš„æŒ‡é’ˆ.</p>
<blockquote>
<p>æ³¨: ç®€è¦è¯´æ˜ä¸€ä¸‹<code>strtok</code>çš„åŸç†.</p>
<p><code>strtok</code>ç»´æŠ¤ä¸€ä¸ªé™æ€å±€éƒ¨æŒ‡é’ˆå˜é‡<code>next</code>ï¼Œéåˆ†å‰²å­—ç¬¦ä¸åˆ†å‰²å­—ç¬¦ä¹‹é—´çš„å­ä¸²å«åš<code>token</code>ï¼Œå¦‚æœ<code>strtok</code>åœ¨è¾“å…¥æµä¸­æ‰¾åˆ°<code>token</code>ï¼Œè¿”å›æŒ‡å‘<code>token</code>å¼€å¤´çš„æŒ‡é’ˆï¼Œç„¶å<code>next</code>æŒ‡å‘<code>token</code>ä¹‹åçš„åˆ†å‰²å­—ç¬¦çš„åä¸€ä¸ªå­—èŠ‚.</p>
<p>å¦‚æœ<code>strtok(const char* str,const char* delimiter)</code>çš„ç¬¬ä¸€ä¸ªå‚æ•°<code>str</code>ä¸ºNULL,é‚£ä¹ˆç›¸å½“äºæŠŠ<code>next</code>èµ‹å€¼ç»™<code>str</code>(å³ä»ä¸Šä¸€æ¬¡è°ƒç”¨æ—¶çš„tokenä¹‹åå¼€å§‹)</p>
</blockquote>
<p>ç„¶åç”¨<a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/cstring/strlen/">strlen()</a>åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦è¶…å‡ºé•¿åº¦é™åˆ¶.</p>
<p>æˆ‘ä»¬å¯ä»¥åƒå¤„ç†å…¶å®ƒé”™è¯¯ç ä¸€æ ·å¤„ç†<code>PREPARE_STRING_TOO_LONG</code>:</p>
<pre><code class="cpp"> enum PrepareResult_t &#123;
   PREPARE_SUCCESS,
+  PREPARE_STRING_TOO_LONG,
   PREPARE_SYNTAX_ERROR,
   PREPARE_UNRECOGNIZED_STATEMENT
 &#125;;

 switch (prepare_statement(input_buffer, &amp;statement)) &#123;
   case (PREPARE_SUCCESS):
     break;
+  case (PREPARE_STRING_TOO_LONG):
+    printf(&quot;String is too long.\n&quot;);
+    continue;
   case (PREPARE_SYNTAX_ERROR):
     printf(&quot;Syntax error. Could not parse statement.\n&quot;);
     continue;
</code></pre>
<p>åšå®Œè¿™äº›å°±å¯ä»¥é€šè¿‡æµ‹è¯•è¾£~</p>
<pre><code>Finished in 0.02284 seconds (files took 0.116 seconds to load)
4 examples, 0 failures
</code></pre>
<p>è¿›è¡Œåˆ°ç°åœ¨ï¼Œæˆ‘ä»¬ä¸å¦¨å¤„ç†æ›´å¤šé”™è¯¯æƒ…å†µ:</p>
<pre><code>it &#39;prints an error message if id is negative&#39; do
  script = [
    &quot;insert -1 cstack foo@bar.com&quot;,
    &quot;select&quot;,
    &quot;.exit&quot;,
  ]
  result = run_script(script)
  expect(result).to match_array([
    &quot;db &gt; ID must be positive.&quot;,
    &quot;db &gt; Executed.&quot;,
    &quot;db &gt; &quot;,
  ])
end
</code></pre>
<pre><code class="cpp"> enum PrepareResult_t &#123;
   PREPARE_SUCCESS,
+  PREPARE_NEGATIVE_ID,
   PREPARE_STRING_TOO_LONG,
   PREPARE_SYNTAX_ERROR,
   PREPARE_UNRECOGNIZED_STATEMENT
@@ -148,9 +147,6 @@ PrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement) &#123;
   &#125;

   int id = atoi(id_string);
+  if (id &lt; 0) &#123;
+    return PREPARE_NEGATIVE_ID;
+  &#125;
   if (strlen(username) &gt; COLUMN_USERNAME_SIZE) &#123;
     return PREPARE_STRING_TOO_LONG;
   &#125;
@@ -230,9 +226,6 @@ int main(int argc, char* argv[]) &#123;
     switch (prepare_statement(input_buffer, &amp;statement)) &#123;
       case (PREPARE_SUCCESS):
         break;
+      case (PREPARE_NEGATIVE_ID):
+        printf(&quot;ID must be positive.\n&quot;);
+        continue;
       case (PREPARE_STRING_TOO_LONG):
         printf(&quot;String is too long.\n&quot;);
         continue;
</code></pre>
<p>å¥½äº†ï¼Œç›®å‰æ¥è¯´æµ‹è¯•å·²ç»è¶³å¤Ÿäº†.ä¸‹ä¸€ç« æ˜¯éå¸¸é‡è¦çš„åŠŸèƒ½:ä¿å­˜!æˆ‘ä»¬å°†ä¼šæŠŠæ•°æ®åº“ä¿å­˜åˆ°æ–‡ä»¶ä¸­ç„¶åè¯»å–åˆ°å†…å­˜ä¸­.</p>
<p>è¿™ä¼šå¾ˆæ£’çš„.</p>
<p>è¿™é‡Œæ˜¯è¿™ç« èŠ‚ä»£ç çš„å…¨éƒ¨æ”¹åŠ¨:</p>
<pre><code class="cpp">@@ -22,6 +22,8 @@

 enum PrepareResult_t &#123;
   PREPARE_SUCCESS,
+  PREPARE_NEGATIVE_ID,
+  PREPARE_STRING_TOO_LONG,
   PREPARE_SYNTAX_ERROR,
   PREPARE_UNRECOGNIZED_STATEMENT
  &#125;;
@@ -34,8 +36,8 @@
 #define COLUMN_EMAIL_SIZE 255
 typedef struct &#123;
   uint32_t id;
-  char username[COLUMN_USERNAME_SIZE];
-  char email[COLUMN_EMAIL_SIZE];
+  char username[COLUMN_USERNAME_SIZE + 1];
+  char email[COLUMN_EMAIL_SIZE + 1];
 &#125; Row;

@@ -150,18 +152,40 @@ MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table *table) &#123;
   &#125;
 &#125;

-PrepareResult prepare_statement(InputBuffer* input_buffer,
-                                Statement* statement) &#123;
-  if (strncmp(input_buffer-&gt;buffer, &quot;insert&quot;, 6) == 0) &#123;
+PrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement) &#123;
   statement-&gt;type = STATEMENT_INSERT;
-  int args_assigned = sscanf(
-     input_buffer-&gt;buffer, &quot;insert %d %s %s&quot;, &amp;(statement-&gt;row_to_insert.id),
-     statement-&gt;row_to_insert.username, statement-&gt;row_to_insert.email
-     );
-  if (args_assigned &lt; 3) &#123;
+
+  char* keyword = strtok(input_buffer-&gt;buffer, &quot; &quot;);
+  char* id_string = strtok(NULL, &quot; &quot;);
+  char* username = strtok(NULL, &quot; &quot;);
+  char* email = strtok(NULL, &quot; &quot;);
+
+  if (id_string == NULL || username == NULL || email == NULL) &#123;
      return PREPARE_SYNTAX_ERROR;
   &#125;
+
+  int id = atoi(id_string);
+  if (id &lt; 0) &#123;
+     return PREPARE_NEGATIVE_ID;
+  &#125;
+  if (strlen(username) &gt; COLUMN_USERNAME_SIZE) &#123;
+     return PREPARE_STRING_TOO_LONG;
+  &#125;
+  if (strlen(email) &gt; COLUMN_EMAIL_SIZE) &#123;
+     return PREPARE_STRING_TOO_LONG;
+  &#125;
+
+  statement-&gt;row_to_insert.id = id;
+  strcpy(statement-&gt;row_to_insert.username, username);
+  strcpy(statement-&gt;row_to_insert.email, email);
+
   return PREPARE_SUCCESS;
+
+&#125;
+PrepareResult prepare_statement(InputBuffer* input_buffer,
+                                Statement* statement) &#123;
+  if (strncmp(input_buffer-&gt;buffer, &quot;insert&quot;, 6) == 0) &#123;
+      return prepare_insert(input_buffer, statement);
   &#125;
   if (strcmp(input_buffer-&gt;buffer, &quot;select&quot;) == 0) &#123;
     statement-&gt;type = STATEMENT_SELECT;
@@ -223,6 +247,12 @@ int main(int argc, char* argv[]) &#123;
     switch (prepare_statement(input_buffer, &amp;statement)) &#123;
       case (PREPARE_SUCCESS):
         break;
+      case (PREPARE_NEGATIVE_ID):
+	printf(&quot;ID must be positive.\n&quot;);
+	continue;
+      case (PREPARE_STRING_TOO_LONG):
+	printf(&quot;String is too long.\n&quot;);
+	continue;
       case (PREPARE_SYNTAX_ERROR):
     printf(&quot;Syntax error. Could not parse statement.\n&quot;);
     continue;
</code></pre>
<p>ç„¶åè¿™æ˜¯æµ‹è¯•:</p>
<pre><code class="rust">+describe &#39;database&#39; do
+  def run_script(commands)
+    raw_output = nil
+    IO.popen(&quot;./db&quot;, &quot;r+&quot;) do |pipe|
+      commands.each do |command|
+        pipe.puts command
+      end
+
+      pipe.close_write
+
+      # Read entire output
+      raw_output = pipe.gets(nil)
+    end
+    raw_output.split(&quot;\n&quot;)
+  end
+
+  it &#39;inserts and retrieves a row&#39; do
+    result = run_script([
+      &quot;insert 1 user1 person1@example.com&quot;,
+      &quot;select&quot;,
+      &quot;.exit&quot;,
+    ])
+    expect(result).to match_array([
+      &quot;db &gt; Executed.&quot;,
+      &quot;db &gt; (1, user1, person1@example.com)&quot;,
+      &quot;Executed.&quot;,
+      &quot;db &gt; &quot;,
+    ])
+  end
+
+  it &#39;prints error message when table is full&#39; do
+    script = (1..1401).map do |i|
+      &quot;insert #&#123;i&#125; user#&#123;i&#125; person#&#123;i&#125;@example.com&quot;
+    end
+    script &lt;&lt; &quot;.exit&quot;
+    result = run_script(script)
+    expect(result[-2]).to eq(&#39;db &gt; Error: Table full.&#39;)
+  end
+
+  it &#39;allows inserting strings that are the maximum length&#39; do
+    long_username = &quot;a&quot;*32
+    long_email = &quot;a&quot;*255
+    script = [
+      &quot;insert 1 #&#123;long_username&#125; #&#123;long_email&#125;&quot;,
+      &quot;select&quot;,
+      &quot;.exit&quot;,
+    ]
+    result = run_script(script)
+    expect(result).to match_array([
+      &quot;db &gt; Executed.&quot;,
+      &quot;db &gt; (1, #&#123;long_username&#125;, #&#123;long_email&#125;)&quot;,
+      &quot;Executed.&quot;,
+      &quot;db &gt; &quot;,
+    ])
+  end
+
+  it &#39;prints error message if strings are too long&#39; do
+    long_username = &quot;a&quot;*33
+    long_email = &quot;a&quot;*256
+    script = [
+      &quot;insert 1 #&#123;long_username&#125; #&#123;long_email&#125;&quot;,
+      &quot;select&quot;,
+      &quot;.exit&quot;,
+    ]
+    result = run_script(script)
+    expect(result).to match_array([
+      &quot;db &gt; String is too long.&quot;,
+      &quot;db &gt; Executed.&quot;,
+      &quot;db &gt; &quot;,
+    ])
+  end
+
+  it &#39;prints an error message if id is negative&#39; do
+    script = [
+      &quot;insert -1 cstack foo@bar.com&quot;,
+      &quot;select&quot;,
+      &quot;.exit&quot;,
+    ]
+    result = run_script(script)
+    expect(result).to match_array([
+      &quot;db &gt; ID must be positive.&quot;,
+      &quot;db &gt; Executed.&quot;,
+      &quot;db &gt; &quot;,
+    ])
+  end
+end
</code></pre>
<h2 id="Part-5-Persistence-to-Disk"><a href="#Part-5-Persistence-to-Disk" class="headerlink" title="Part 5 - Persistence to Disk"></a>Part 5 - Persistence to Disk</h2><p>ç›®å‰æ•°æ®åº“å…è®¸æ’å…¥è®°å½•å¹¶ä¸”è¯»å–ï¼Œä½†ä»…é™ç¨‹åºè¿è¡ŒæœŸé—´.å¦‚æœå…³é—­ç¨‹åºç„¶åé‡æ–°æ‰“å¼€ï¼Œæ‰€æœ‰çš„è®°å½•éƒ½æ¶ˆå¤±äº†.æˆ‘ä»¬æœŸæœ›çš„æ•°æ®åº“è¡¨ç°åº”è¯¥æ˜¯è¿™æ ·:</p>
<pre><code class="rust">it &#39;keeps data after closing connection&#39; do
  result1 = run_script([
    &quot;insert 1 user1 person1@example.com&quot;,
    &quot;.exit&quot;,
  ])
  expect(result1).to match_array([
    &quot;db &gt; Executed.&quot;,
    &quot;db &gt; &quot;,
  ])
  result2 = run_script([
    &quot;select&quot;,
    &quot;.exit&quot;,
  ])
  expect(result2).to match_array([
    &quot;db &gt; (1, user1, person1@example.com)&quot;,
    &quot;Executed.&quot;,
    &quot;db &gt; &quot;,
  ])
end
</code></pre>
<p>å’Œsqliteä¸€æ ·ï¼Œæˆ‘ä»¬é€šè¿‡å°†æ•´ä¸ªæ•°æ®åº“ä¿å­˜åˆ°æ–‡ä»¶ä¸­æ¥æ°¸ä¹…å­˜å‚¨è®°å½•.</p>
<p>æˆ‘ä»¬ç›®å‰å·²ç»å¯ä»¥å°†è¡Œåºåˆ—åŒ–å­˜å‚¨è¿›é¡µå°ºå¯¸çš„å†…å­˜å—.ä¸ºäº†å®ç°æ°¸ä¹…å­˜å‚¨ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°æŠŠå†…å­˜å—å†™å…¥æ–‡ä»¶ï¼Œç„¶ååœ¨ä¸‹ä¸€æ¬¡è¿è¡Œç¨‹åºæ—¶æŠŠæ•°æ®è¯»å–åˆ°å†…å­˜ä¸­.</p>
<p>ä¸ºäº†è®©äº‹æƒ…æ›´ç®€å•ä¸€ç‚¹ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªå«åš<code>pager</code>çš„æŠ½è±¡å±‚.æˆ‘ä»¬å‘pageræŸ¥è¯¢page X,ç„¶åpagerè¿”å›ä¸€ä¸ªå†…å­˜å—,pageré¦–å…ˆåœ¨ç¼“å­˜ä¸­æŸ¥æ‰¾ï¼Œå¦‚æœç¼“å­˜ä¸­æ²¡æœ‰è¿™ä¸€é¡µï¼Œå°±å°†æ•°æ®ä»ç£ç›˜è¯»å–åˆ°å†…å­˜(é€šè¿‡è¯»å–æ•°æ®åº“æ–‡ä»¶).</p>
<p>SQLiteæ¶æ„å…·ä½“åˆ°æˆ‘ä»¬çš„æ•°æ®åº“ç¨‹åº</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/arch-part5.gif" alt="img"></p>
<p>Pagerè´Ÿè´£pageç¼“å­˜å’Œæ•°æ®åº“æ–‡ä»¶,Tableå¯¹è±¡é€šè¿‡pagerè¯·æ±‚pages:</p>
<pre><code class="cpp">+typedef struct &#123;
+  int file_descriptor;
+  uint32_t file_length;
+  void* pages[TABLE_MAX_PAGES];
+&#125; Pager;
+
 typedef struct &#123;
-  void* pages[TABLE_MAX_PAGES];
+  Pager* pager;
   uint32_t num_rows;
 &#125; Table;
</code></pre>
<p>æˆ‘å°†<code>new_table()</code>å‡½æ•°é‡å‘½åä¸º<code>db_open()</code>å› ä¸ºå®ƒç°åœ¨è´Ÿè´£æ‰“å¼€æ•°æ®åº“ï¼Œå¼€æ•°æ®åº“ï¼Œæ„å‘³ç€:</p>
<ul>
<li>æ‰“å¼€æ•°æ®åº“æ–‡ä»¶</li>
<li>åˆå§‹åŒ–pager</li>
<li>åˆå§‹åŒ–table</li>
</ul>
<pre><code class="cpp">-Table* new_table() &#123;
+Table* db_open(const char* filename) &#123;
+  Pager* pager = pager_open(filename);

/*
è¯‘è€…æ³¨: åŸæ–‡ä¸º uint32_t num_rows = pager-&gt;file_length / ROW_SIZE;
ä½†è¿™é‡Œéœ€è¦è€ƒè™‘pageçš„å¤§å°ä¸ä¸ºrowçš„æ•´æ•°å€çš„æƒ…å†µ,æ‰€ä»¥ä¸èƒ½ç›´æ¥ç”¨ æ–‡ä»¶å¤§å°/è¡Œå¤§å° æ¥æ±‚è¡Œæ•°,
å› ä¸ºæ¯é¡µä¸­å¯èƒ½è¿˜æœ‰ä¸€äº›ç©ºé—´æ˜¯æ— æ•ˆçš„(pageåªèƒ½æ”¾æ•´æ•°ä¸ªrow)
*/
+  uint32_t num_rows=pager-&gt;file_length/PAGE_SIZE*ROWS_PER_PAGE;   //æ•´é¡µçš„æ‰€æœ‰è¡Œ

+  uint32_t extra_bytes=pager-&gt;file_length%PAGE_SIZE;
+  if (extra_bytes&gt;0)&#123;    //æ®‹ç¼ºé¡µçš„é¢å¤–è¡Œ
+    uint32_t addtional_rows=extra_bytes/ROW_SIZE;
+    num_rows+=addtional_rows;
+  &#125;
+
   Table* table = malloc(sizeof(Table));
-  table-&gt;num_rows = 0;
+  table-&gt;pager = pager;
+  table-&gt;num_rows = num_rows;

   return table;
 &#125;
</code></pre>
<p><code>db_open()</code>å‡½æ•°è°ƒç”¨äº†<code>pager_open()</code>ï¼Œ<code>pager_open</code>æ‰“å¼€ä¸€ä¸ªæ•°æ®åº“æ–‡ä»¶å¹¶è¿½è¸ªæ•°æ®åº“å¤§å°.å®ƒè¿˜ä¼šå°†pageç¼“å­˜åˆå§‹åŒ–ä¸ºNULL.</p>
<pre><code class="cpp">+Pager* pager_open(const char* filename) &#123;
+  int fd = open(filename,
+                O_RDWR |      // Read/Write mode
+                    O_CREAT,  // Create file if it does not exist
+                S_IWUSR |     // User write permission
+                    S_IRUSR   // User read permission
+                );
+
+  if (fd == -1) &#123;
+    printf(&quot;Unable to open file\n&quot;);
+    exit(EXIT_FAILURE);
+  &#125;
+
+  off_t file_length = lseek(fd, 0, SEEK_END);
+
+  Pager* pager = malloc(sizeof(Pager));
+  pager-&gt;file_descriptor = fd;
+  pager-&gt;file_length = file_length;
+
+  for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) &#123;
+    pager-&gt;pages[i] = NULL;
+  &#125;
+
+  return pager;
+&#125;
</code></pre>
<p>å› ä¸ºæœ‰äº†æ–°çš„pagerå±‚ï¼Œæ‰€ä»¥æˆ‘ä»¬æŠŠè·å–pageçš„é€»è¾‘æ”¾å…¥pagerè‡ªå·±çš„æ–¹æ³•ä¸­:</p>
<pre><code class="cpp"> void* row_slot(Table* table, uint32_t row_num) &#123;
   uint32_t page_num = row_num / ROWS_PER_PAGE;
-  void* page = table-&gt;pages[page_num];
-  if (page == NULL) &#123;
-    // Allocate memory only when we try to access page
-    page = table-&gt;pages[page_num] = malloc(PAGE_SIZE);
-  &#125;
+  void* page = get_page(table-&gt;pager, page_num);
   uint32_t row_offset = row_num % ROWS_PER_PAGE;
   uint32_t byte_offset = row_offset * ROW_SIZE;
   return page + byte_offset;
 &#125;
</code></pre>
<p><code>get_page()</code>å‡½æ•°åŒ…å«å¤„ç†ç¼“å­˜æœªå‘½ä¸­çš„é€»è¾‘.æˆ‘ä»¬å‡è®¾pagesæ˜¯ä¸€ä¸ªæ¥ç€ä¸€ä¸ªçš„ä¿å­˜åœ¨æ•°æ®åº“æ–‡ä»¶ä¸­çš„: Page 0 çš„åç§»ä¸º0ï¼ŒPage 1 çš„åç§»ä¸º4096(pageå¤§å°ä¸º4096),page 2 çš„åç§»ä¸º8192,etc.å¦‚æœè¢«è¯·æ±‚çš„pageè¶…å‡ºäº†æ–‡ä»¶çš„è¾¹ç•Œï¼Œæˆ‘ä»¬çŸ¥é“å®ƒåº”è¯¥æ˜¯ç©ºç™½çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦åˆ†é…ä¸€äº›å†…å­˜ç©ºé—´ç„¶åè¿”å›å®ƒ.ç¨åæˆ‘ä»¬å°†ç¼“å­˜å†™å…¥ç£ç›˜æ—¶pageä¼šè¢«è¿½åŠ åˆ°æ–‡ä»¶ä¸­.</p>
<pre><code class="cpp">+void* get_page(Pager* pager, uint32_t page_num) &#123;
+  if (page_num &gt;= TABLE_MAX_PAGES) &#123;
    //è¯‘è€…æ³¨: åŸæ–‡ä¸º page_num &gt; TABLE_MAX_PAGES,ä½†page_numä¸ºä¸‹æ ‡ï¼Œå› æ­¤è¾¹ç•Œæ¡ä»¶ä¸ºTABLE_MAX_PAGES-1
+    printf(&quot;Tried to fetch page number out of bounds. %d &gt; %d\n&quot;, page_num,
+           TABLE_MAX_PAGES);
+    exit(EXIT_FAILURE);
+  &#125;
+
+  if (pager-&gt;pages[page_num] == NULL) &#123;
+    // Cache miss. Allocate memory and load from file.
+    void* page = malloc(PAGE_SIZE);
+    uint32_t num_pages = pager-&gt;file_length / PAGE_SIZE;
+
+    // We might save a partial page at the end of the file
+    if (pager-&gt;file_length % PAGE_SIZE) &#123;
+      num_pages += 1;
+    &#125;
+
+    if (page_num &lt;= num_pages-1) &#123;
     //è¯‘è€…æ³¨: åŸæ–‡ä¸º page_num&lt;=num_pages	åŒæ ·ï¼Œå› ä¸ºpage_numä¸ºä¸‹æ ‡è€Œnum_pagesä¸ºé¡µæ•°ï¼Œæ‰€ä»¥è¾¹ç•Œä¸ºnum_pages-1
+      lseek(pager-&gt;file_descriptor, page_num * PAGE_SIZE, SEEK_SET);
+      ssize_t bytes_read = read(pager-&gt;file_descriptor, page, PAGE_SIZE);
+      if (bytes_read == -1) &#123;
+        printf(&quot;Error reading file: %d\n&quot;, errno);
+        exit(EXIT_FAILURE);
+      &#125;
+    &#125;
+
+    pager-&gt;pages[page_num] = page;
+  &#125;
+
+  return pager-&gt;pages[page_num];
+&#125;
</code></pre>
<p>ç›®å‰æ¥è¯´ï¼Œç­‰åˆ°ç”¨æˆ·å…³é—­æ•°æ®åº“è¿æ¥åï¼Œæˆ‘ä»¬æ‰æŠŠç¼“å­˜å†™å…¥ç£ç›˜.å½“ç”¨æˆ·é€€å‡ºæ—¶ï¼Œæˆ‘ä»¬è°ƒç”¨ä¸€ä¸ªæ–°çš„å‡½æ•°<code>db_close</code>,å®ƒå°†</p>
<ul>
<li>å°†é¡µç¼“å­˜å†™å…¥ç£ç›˜</li>
<li>å…³é—­æ•°æ®åº“æ–‡ä»¶</li>
<li>é‡Šæ”¾Pagerå’ŒTableçš„å†…å­˜</li>
</ul>
<pre><code class="cpp">+void db_close(Table* table) &#123;
+  Pager* pager = table-&gt;pager;
+  uint32_t num_full_pages = table-&gt;num_rows / ROWS_PER_PAGE;
+
+  for (uint32_t i = 0; i &lt; num_full_pages; i++) &#123;
+    if (pager-&gt;pages[i] == NULL) &#123;
+      continue;
+    &#125;
+    pager_flush(pager, i, PAGE_SIZE);
+    free(pager-&gt;pages[i]);
+    pager-&gt;pages[i] = NULL;
+  &#125;
+
+  // There may be a partial page to write to the end of the file
+  // This should not be needed after we switch to a B-tree
+  uint32_t num_additional_rows = table-&gt;num_rows % ROWS_PER_PAGE;
+  if (num_additional_rows &gt; 0) &#123;
+    uint32_t page_num = num_full_pages;
+    if (pager-&gt;pages[page_num] != NULL) &#123;
+      pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);
+      free(pager-&gt;pages[page_num]);
+      pager-&gt;pages[page_num] = NULL;
+    &#125;
+  &#125;
+
+  int result = close(pager-&gt;file_descriptor);
+  if (result == -1) &#123;
+    printf(&quot;Error closing db file.\n&quot;);
+    exit(EXIT_FAILURE);
+  &#125;
+  for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) &#123;
+    void* page = pager-&gt;pages[i];
+    if (page) &#123;
+      free(page);
+      pager-&gt;pages[i] = NULL;
+    &#125;
+  &#125;
+  free(pager);
+  free(table);
+&#125;
+
-MetaCommandResult do_meta_command(InputBuffer* input_buffer) &#123;
+MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table* table) &#123;
   if (strcmp(input_buffer-&gt;buffer, &quot;.exit&quot;) == 0) &#123;
+    db_close(table);
     exit(EXIT_SUCCESS);
   &#125; else &#123;
     return META_COMMAND_UNRECOGNIZED_COMMAND;
</code></pre>
<p>åœ¨æˆ‘ä»¬ç›®å‰çš„è®¾è®¡ä¸­ï¼Œæ–‡ä»¶çš„é•¿åº¦å–å†³äºæ•°æ®åº“ä¸­çš„è¡Œæ•°ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦é¢å¤–åœ¨æœ«å°¾å†™å…¥ä¸€é¡µ(å¦‚æœè¡Œæ•°ä¸æ˜¯<code>rows_per_page</code>çš„æ•´æ•°å€).è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆ<code>pager_flush()</code>å‡½æ•°æœ‰ä¸¤ä¸ªå‚æ•° - pageä¸‹æ ‡å’Œå¤§å°.è¿™ä¸æ˜¯æœ€å¥½çš„è®¾è®¡ï¼Œä¸è¿‡å½“æˆ‘ä»¬å®ç°B-treeçš„æ—¶å€™å°±ä¸éœ€è¦è¿™ä¸ªäº†.</p>
<pre><code class="cpp">+void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) &#123;
+  if (pager-&gt;pages[page_num] == NULL) &#123;
+    printf(&quot;Tried to flush null page\n&quot;);
+    exit(EXIT_FAILURE);
+  &#125;
+
+  off_t offset = lseek(pager-&gt;file_descriptor, page_num * PAGE_SIZE, SEEK_SET);
+
+  if (offset == -1) &#123;
+    printf(&quot;Error seeking: %d\n&quot;, errno);
+    exit(EXIT_FAILURE);
+  &#125;
+
+  ssize_t bytes_written =
+      write(pager-&gt;file_descriptor, pager-&gt;pages[page_num], size);
+
+  if (bytes_written == -1) &#123;
+    printf(&quot;Error writing: %d\n&quot;, errno);
+    exit(EXIT_FAILURE);
+  &#125;
+&#125;
</code></pre>
<p>æœ€åï¼Œæˆ‘ä»¬éœ€è¦æ¥å—å‘½ä»¤è¡Œå‚æ•°ä¼ é€’çš„æ–‡ä»¶å.ä¸è¦å¿˜äº†è¿˜è¦ç»™<code>do_meta_command</code>å‡½æ•°åŠ ä¸€ä¸ªé¢å¤–çš„å‚æ•°.</p>
<pre><code class="cpp"> int main(int argc, char* argv[]) &#123;
-  Table* table = new_table();
+  if (argc &lt; 2) &#123;
+    printf(&quot;Must supply a database filename.\n&quot;);
+    exit(EXIT_FAILURE);
+  &#125;
+
+  char* filename = argv[1];
+  Table* table = db_open(filename);
+
   InputBuffer* input_buffer = new_input_buffer();
   while (true) &#123;
     print_prompt();
     read_input(input_buffer);

     if (input_buffer-&gt;buffer[0] == &#39;.&#39;) &#123;
-      switch (do_meta_command(input_buffer)) &#123;
+      switch (do_meta_command(input_buffer, table)) &#123;
</code></pre>
<p>åšå®Œè¿™äº›ä¿®æ”¹ï¼Œæˆ‘ä»¬å°±å¯ä»¥å…³é—­å’Œé‡æ–°æ‰“å¼€æ•°æ®åº“è¾£ï¼Œå¹¶ä¸”æˆ‘ä»¬çš„è®°å½•è¿˜åœ¨.</p>
<pre><code>~ ./db mydb.db
db &gt; insert 1 cstack foo@bar.com
Executed.
db &gt; insert 2 voltorb volty@example.com
Executed.
db &gt; .exit
~
~ ./db mydb.db
db &gt; select
(1, cstack, foo@bar.com)
(2, voltorb, volty@example.com)
Executed.
db &gt; .exit
~
</code></pre>
<p>For extra fun,è®©æˆ‘ä»¬æ‰“å¼€mydb.dbçœ‹çœ‹æ•°æ®æ˜¯å¦‚ä½•è¢«å­˜å‚¨çš„.æˆ‘å°†ä¼šä½¿ç”¨vimä»¥16è¿›åˆ¶æ¨¡å¼æŸ¥çœ‹æ–‡ä»¶çš„å†…å­˜å¸ƒå±€:</p>
<p>æ–‡ä»¶æ ¼å¼</p>
<p><img src="https://cstack.github.io/db_tutorial/assets/images/file-format.png" alt="img: Current File Format"></img></p>
<p>å¼€å¤´4ä¸ªå­—èŠ‚æ˜¯ç¬¬ä¸€è¡Œçš„id(4ä¸ªå­—èŠ‚å› ä¸ºidæ˜¯<code>uint32_t</code>),å®ƒæ˜¯ä»¥<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%AD%97%E8%8A%82%E5%BA%8F">å°ç«¯æ ¼å¼</a>å­˜å‚¨çš„,æ‰€ä»¥æœ€ä½ä½å­—èŠ‚ä¸º<code>0x01</code>,å…¶ä»–3ä¸ºéƒ½ä¸º0x00.æˆ‘ä»¬ä½¿ç”¨<code>memcpy</code>å°†Rowç»“æ„ä½“ä¸­çš„æ•°æ®æ‹·è´åˆ°pageç¼“å­˜,æ‰€ä»¥è¿™ä¹Ÿæ„å‘³ç€å†…å­˜ä¸­çš„ç»“æ„ä½“å˜é‡ä¹Ÿæ˜¯ä»¥å°ç«¯åºå­˜å‚¨çš„.å¤§ç«¯åºè¿˜æ˜¯å°ç«¯åºæ˜¯ç”±æœºå™¨å†³å®šçš„(ä¾‹å¦‚intelå°±æ˜¯å°ç«¯),å¦‚æœæˆ‘ä»¬åœ¨è‡ªå·±çš„æœºå™¨ä¸Šå†™å…¥æ•°æ®åº“æ–‡ä»¶ï¼Œç„¶ååœ¨å¦ä¸€ä¸ªå¤§ç«¯åºçš„æœºå™¨ä¸Šè¯»å–ï¼Œå°±éœ€è¦å®Œå–„<code>serialize_row()</code>å’Œ<code>deserialize_row()</code>å‡½æ•°ï¼Œä¸€ç›´ç”¨åŒä¸€ç§é¡ºåºå­˜å‚¨å’Œå†™å…¥å­—èŠ‚.</p>
<p>åé¢çš„33å­—èŠ‚å­˜å‚¨<code>username</code>å­—ç¬¦ä¸²ï¼Œä»¥<code>nullå­—ç¬¦</code>ä¸ºç»“å°¾.æ˜¾ç„¶â€cstackâ€çš„ASCIIç çš„16è¿›åˆ¶æ ¼å¼ä¸º <code>63 73 74 61 63 6b</code>,ç´§æ¥ç€æ˜¯ä¸€ä¸ªnullå­—ç¬¦(0x00).å‰©ä½™çš„33å­—èŠ‚æœªè¢«ä½¿ç”¨.</p>
<p>usernameåé¢çš„256å­—èŠ‚ç”¨åŒæ ·çš„æ–¹å¼å­˜å‚¨<code>email</code>ï¼Œåœ¨nullå­—ç¬¦ä¹‹åå¯ä»¥çœ‹åˆ°ä¸€äº›éšæœºçš„junkï¼Œè¿™ç©æ„çš„æ¥æºå¾ˆå¯èƒ½æ˜¯Rowç»“æ„ä½“æœªåˆå§‹åŒ–çš„å†…å­˜.æˆ‘ä»¬å°†æ•´æ•´256å­—èŠ‚çš„emailç¼“å­˜æ‹·è´å…¥æ–‡ä»¶,å½“æŠŠå†…å­˜åˆ†é…ç»™ç»“æ„ä½“æ—¶ï¼Œå†…å­˜ä¸­çš„å†…å®¹è¿˜åœ¨é‚£å„¿.ä½†æ˜¯å› ä¸ºæˆ‘ä»¬ç”¨äº†nullå­—ç¬¦æ ‡è¯†å­—ç¬¦ä¸²æœ«å°¾ï¼Œæ‰€ä»¥ä¸ä¼šæœ‰ä»€ä¹ˆå½±å“.</p>
<p><strong>æ³¨æ„</strong>: å¦‚æœæˆ‘ä»¬æƒ³è¦ç¡®ä¿æ‰€æœ‰å­—èŠ‚éƒ½ä¼šè¢«åˆå§‹åŒ–ï¼Œä½¿ç”¨<code>strncpy</code>å°†usernameå’Œemailæ‹·è´è¿›å†…å­˜(è€Œä¸æ˜¯<code>memcpy</code>)å°±å¯ä»¥ï¼Œå°±åƒè¿™æ ·:</p>
<pre><code class="cpp"> void serialize_row(Row* source, void* destination) &#123;
     memcpy(destination + ID_OFFSET, &amp;(source-&gt;id), ID_SIZE);
-    memcpy(destination + USERNAME_OFFSET, &amp;(source-&gt;username), USERNAME_SIZE);
-    memcpy(destination + EMAIL_OFFSET, &amp;(source-&gt;email), EMAIL_SIZE);
+    strncpy(destination + USERNAME_OFFSET, source-&gt;username, USERNAME_SIZE);
+    strncpy(destination + EMAIL_OFFSET, source-&gt;email, EMAIL_SIZE);
 &#125;
</code></pre>
<blockquote>
<p>æ³¨: æˆ‘æƒ³ä½ ä»¬åº”è¯¥æ‡’å¾—æŸ¥cpp ref,æˆ‘å¸®ä½ ä»¬æŸ¥å§</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-25/fa4eebcdd18b319009753543f40ddc66.png" alt="image-20220425213839123"></p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-25/24f372655fb1925fefb8d72ff920b7d0.png" alt="image-20220425213633941"></p>
<p>å¤§è‡´æ„æ€å°±æ˜¯ï¼Œå¦‚æœsrc(åŒ…æ‹¬nullå­—ç¬¦)å…¨éƒ½æ‹·è´è¿›äº†dest,è¿˜æ˜¯æ²¡èƒ½è¾¾åˆ°<code>count</code>ä¸ªå­—èŠ‚ï¼Œé‚£ä¹ˆdestå‰©ä½™çš„éƒ¨åˆ†éƒ½å¡«å……nullå­—ç¬¦,ç›´åˆ°è¾¾åˆ°count.</p>
</blockquote>
<h3 id="Conclusion-1"><a href="#Conclusion-1" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>å¥½!æˆ‘ä»¬å·²ç»å®Œæˆäº†æŒä¹…ä¿å­˜ï¼Œä½†è¿˜æœ‰äº›åœ°æ–¹å¯ä»¥æ”¹å–„.ä¾‹å¦‚å¦‚æœä¸ç”¨<code>.exit</code>è€Œæ˜¯ç›´æ¥ç»ˆæ­¢ç¨‹åºï¼Œä¿®æ”¹çš„æ•°æ®å°±ä¼šä¸¢å¤±.æ­¤å¤–ï¼Œæˆ‘ä»¬æŠŠæ‰€æœ‰çš„pageéƒ½å†™å›äº†ç£ç›˜ï¼Œå³ä½¿æ˜¯ä»ç£ç›˜è¯»å–åˆ°å†…å­˜åä¸€ç›´æ²¡æ”¹å˜çš„é‚£äº›page,è¿™äº›é—®é¢˜æˆ‘ä»¬ä¹‹åéƒ½å¯ä»¥è§£å†³.</p>
<p>ä¸‹ä¸€ç« æˆ‘ä»¬ä¼šä»‹ç»cursors,è¿™ä¼šè®©å®ç°B-treeæ›´å®¹æ˜“ä¸€äº›.</p>
<p>Until then!</p>
<h3 id="Complete-Diff"><a href="#Complete-Diff" class="headerlink" title="Complete Diff"></a>Complete Diff</h3><pre><code class="cpp">+#include &lt;errno.h&gt;
+#include &lt;fcntl.h&gt;
 #include &lt;stdbool.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 #include &lt;stdint.h&gt;
+#include &lt;unistd.h&gt;

 struct InputBuffer_t &#123;
   char* buffer;
@@ -62,9 +65,16 @@ const uint32_t PAGE_SIZE = 4096;
 const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;
 const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;

+typedef struct &#123;
+  int file_descriptor;
+  uint32_t file_length;
+  void* pages[TABLE_MAX_PAGES];
+&#125; Pager;
+
 typedef struct &#123;
   uint32_t num_rows;
-  void* pages[TABLE_MAX_PAGES];
+  Pager* pager;
 &#125; Table;

@@ -84,32 +94,81 @@ void deserialize_row(void *source, Row* destination) &#123;
   memcpy(&amp;(destination-&gt;email), source + EMAIL_OFFSET, EMAIL_SIZE);
 &#125;

+void* get_page(Pager* pager, uint32_t page_num) &#123;
+  if (page_num &gt; TABLE_MAX_PAGES) &#123;
+     printf(&quot;Tried to fetch page number out of bounds. %d &gt; %d\n&quot;, page_num,
+     	TABLE_MAX_PAGES);
+     exit(EXIT_FAILURE);
+  &#125;
+
+  if (pager-&gt;pages[page_num] == NULL) &#123;
+     // Cache miss. Allocate memory and load from file.
+     void* page = malloc(PAGE_SIZE);
+     uint32_t num_pages = pager-&gt;file_length / PAGE_SIZE;
+
+     // We might save a partial page at the end of the file
+     if (pager-&gt;file_length % PAGE_SIZE) &#123;
+         num_pages += 1;
+     &#125;
+
+     if (page_num &lt;= num_pages) &#123;
+         lseek(pager-&gt;file_descriptor, page_num * PAGE_SIZE, SEEK_SET);
+         ssize_t bytes_read = read(pager-&gt;file_descriptor, page, PAGE_SIZE);
+         if (bytes_read == -1) &#123;
+     	printf(&quot;Error reading file: %d\n&quot;, errno);
+     	exit(EXIT_FAILURE);
+         &#125;
+     &#125;
+
+     pager-&gt;pages[page_num] = page;
+  &#125;
+
+  return pager-&gt;pages[page_num];
+&#125;
+
 void* row_slot(Table* table, uint32_t row_num) &#123;
   uint32_t page_num = row_num / ROWS_PER_PAGE;
-  void *page = table-&gt;pages[page_num];
-  if (page == NULL) &#123;
-     // Allocate memory only when we try to access page
-     page = table-&gt;pages[page_num] = malloc(PAGE_SIZE);
-  &#125;
+  void *page = get_page(table-&gt;pager, page_num);
   uint32_t row_offset = row_num % ROWS_PER_PAGE;
   uint32_t byte_offset = row_offset * ROW_SIZE;
   return page + byte_offset;
 &#125;

-Table* new_table() &#123;
-  Table* table = malloc(sizeof(Table));
-  table-&gt;num_rows = 0;
+Pager* pager_open(const char* filename) &#123;
+  int fd = open(filename,
+     	  O_RDWR | 	// Read/Write mode
+     	      O_CREAT,	// Create file if it does not exist
+     	  S_IWUSR |	// User write permission
+     	      S_IRUSR	// User read permission
+     	  );
+
+  if (fd == -1) &#123;
+     printf(&quot;Unable to open file\n&quot;);
+     exit(EXIT_FAILURE);
+  &#125;
+
+  off_t file_length = lseek(fd, 0, SEEK_END);
+
+  Pager* pager = malloc(sizeof(Pager));
+  pager-&gt;file_descriptor = fd;
+  pager-&gt;file_length = file_length;
+
   for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) &#123;
-     table-&gt;pages[i] = NULL;
+     pager-&gt;pages[i] = NULL;
   &#125;
-  return table;
+
+  return pager;
 &#125;

-void free_table(Table* table) &#123;
-  for (int i = 0; table-&gt;pages[i]; i++) &#123;
-     free(table-&gt;pages[i]);
-  &#125;
-  free(table);
+Table* db_open(const char* filename) &#123;
+  Pager* pager = pager_open(filename);
+  uint32_t num_rows = pager-&gt;file_length / ROW_SIZE;
+
+  Table* table = malloc(sizeof(Table));
+  table-&gt;pager = pager;
+  table-&gt;num_rows = num_rows;
+
+  return table;
 &#125;

 InputBuffer* new_input_buffer() &#123;
@@ -142,10 +201,76 @@ void close_input_buffer(InputBuffer* input_buffer) &#123;
   free(input_buffer);
 &#125;

+void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) &#123;
+  if (pager-&gt;pages[page_num] == NULL) &#123;
+     printf(&quot;Tried to flush null page\n&quot;);
+     exit(EXIT_FAILURE);
+  &#125;
+
+  off_t offset = lseek(pager-&gt;file_descriptor, page_num * PAGE_SIZE,
+     		 SEEK_SET);
+
+  if (offset == -1) &#123;
+     printf(&quot;Error seeking: %d\n&quot;, errno);
+     exit(EXIT_FAILURE);
+  &#125;
+
+  ssize_t bytes_written = write(
+     pager-&gt;file_descriptor, pager-&gt;pages[page_num], size
+     );
+
+  if (bytes_written == -1) &#123;
+     printf(&quot;Error writing: %d\n&quot;, errno);
+     exit(EXIT_FAILURE);
+  &#125;
+&#125;
+
+void db_close(Table* table) &#123;
+  Pager* pager = table-&gt;pager;
+  uint32_t num_full_pages = table-&gt;num_rows / ROWS_PER_PAGE;
+
+  for (uint32_t i = 0; i &lt; num_full_pages; i++) &#123;
+     if (pager-&gt;pages[i] == NULL) &#123;
+         continue;
+     &#125;
+     pager_flush(pager, i, PAGE_SIZE);
+     free(pager-&gt;pages[i]);
+     pager-&gt;pages[i] = NULL;
+  &#125;
+
+  // There may be a partial page to write to the end of the file
+  // This should not be needed after we switch to a B-tree
+  uint32_t num_additional_rows = table-&gt;num_rows % ROWS_PER_PAGE;
+  if (num_additional_rows &gt; 0) &#123;
+     uint32_t page_num = num_full_pages;
+     if (pager-&gt;pages[page_num] != NULL) &#123;
+         pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);
+         free(pager-&gt;pages[page_num]);
+         pager-&gt;pages[page_num] = NULL;
+     &#125;
+  &#125;
+
+  int result = close(pager-&gt;file_descriptor);
+  if (result == -1) &#123;
+     printf(&quot;Error closing db file.\n&quot;);
+     exit(EXIT_FAILURE);
+  &#125;
+  for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) &#123;
+     void* page = pager-&gt;pages[i];
+     if (page) &#123;
+         free(page);
+         pager-&gt;pages[i] = NULL;
+     &#125;
+  &#125;
+
+  free(pager);
+  free(table);
+&#125;
+
 MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table *table) &#123;
   if (strcmp(input_buffer-&gt;buffer, &quot;.exit&quot;) == 0) &#123;
     close_input_buffer(input_buffer);
-    free_table(table);
+    db_close(table);
     exit(EXIT_SUCCESS);
   &#125; else &#123;
     return META_COMMAND_UNRECOGNIZED_COMMAND;
@@ -182,6 +308,7 @@ PrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement) &#123;
     return PREPARE_SUCCESS;

 &#125;
+
 PrepareResult prepare_statement(InputBuffer* input_buffer,
                                 Statement* statement) &#123;
   if (strncmp(input_buffer-&gt;buffer, &quot;insert&quot;, 6) == 0) &#123;
@@ -227,7 +354,14 @@ ExecuteResult execute_statement(Statement* statement, Table *table) &#123;
 &#125;

 int main(int argc, char* argv[]) &#123;
-  Table* table = new_table();
+  if (argc &lt; 2) &#123;
+      printf(&quot;Must supply a database filename.\n&quot;);
+      exit(EXIT_FAILURE);
+  &#125;
+
+  char* filename = argv[1];
+  Table* table = db_open(filename);
+
   InputBuffer* input_buffer = new_input_buffer();
   while (true) &#123;
     print_prompt();
</code></pre>
<p>ç„¶åè¿™æ˜¯æµ‹è¯•éƒ¨åˆ†çš„æ”¹åŠ¨:</p>
<blockquote>
<p>å‘ƒ..åŸä½œè€…æœ‰ç‚¹ä¸å¤ªç»†å¿ƒ</p>
<p>å®é™…ä¸Šè‡ªä»part4æŠŠemailå’Œusernameçš„å¤§å°éƒ½åŠ äº†1å­—èŠ‚åï¼Œæœ€å¤§å­˜å‚¨çš„è¡Œæ•°ä¸º1300</p>
<p>4096&#x2F;(4+33+256&#x3D;293)&#x3D;13.9 ä¹Ÿå°±æ˜¯æ¯é¡µåªèƒ½å­˜å‚¨13è¡Œ,æœ€å¤š100é¡µ</p>
</blockquote>
<pre><code class="rust">And the diff to our tests:

 describe &#39;database&#39; do
+  before do
+    `rm -rf test.db`
+  end
+
   def run_script(commands)
     raw_output = nil
-    IO.popen(&quot;./db&quot;, &quot;r+&quot;) do |pipe|
+    IO.popen(&quot;./db test.db&quot;, &quot;r+&quot;) do |pipe|
       commands.each do |command|
         pipe.puts command
       end
@@ -28,6 +32,27 @@ describe &#39;database&#39; do
     ])
   end

+  it &#39;keeps data after closing connection&#39; do
+    result1 = run_script([
+      &quot;insert 1 user1 person1@example.com&quot;,
+      &quot;.exit&quot;,
+    ])
+    expect(result1).to match_array([
+      &quot;db &gt; Executed.&quot;,
+      &quot;db &gt; &quot;,
+    ])
+
+    result2 = run_script([
+      &quot;select&quot;,
+      &quot;.exit&quot;,
+    ])
+    expect(result2).to match_array([
+      &quot;db &gt; (1, user1, person1@example.com)&quot;,
+      &quot;Executed.&quot;,
+      &quot;db &gt; &quot;,
+    ])
+  end
+
   it &#39;prints error message when table is full&#39; do
     script = (1..1401).map do |i|
       &quot;insert #&#123;i&#125; user#&#123;i&#125; person#&#123;i&#125;@example.com&quot;
</code></pre>
<h2 id="Part-6-The-Cursor-Abstraction"><a href="#Part-6-The-Cursor-Abstraction" class="headerlink" title="Part 6 - The Cursor Abstraction"></a>Part 6 - The Cursor Abstraction</h2><p>è¿™ä¸€ç« åº”è¯¥æ¯”ä¸Šä¸€ç« çŸ­ä¸€ç‚¹.æˆ‘ä»¬åªéœ€è¦é‡æ„ä¸€ç‚¹ç‚¹ä»£ç ,ä»¥æ­¤æ¥è®©å®ç°B-Treeæ›´å®¹æ˜“ä¸€ç‚¹.</p>
<p>æˆ‘ä»¬éœ€è¦æ·»åŠ ä¸€ä¸ªè¡¨ç¤º<code>Cursor</code>å¯¹è±¡ï¼Œå®ƒç”¨æ¥è¡¨ç¤ºåœ¨tableä¸­çš„ä½ç½®.</p>
<p>ä½ å¯èƒ½æƒ³ç”¨cursorsåšçš„äº‹:</p>
<ul>
<li>åœ¨tableçš„å¼€å¤´åˆ›å»ºä¸€ä¸ªcursor</li>
<li>åœ¨tableçš„æœ«å°¾åˆ›å»ºä¸€ä¸ªcursor</li>
<li>è·å–cursoræŒ‡å‘çš„row</li>
<li>å°†cursorç§»åŠ¨åˆ°ä¸‹ä¸€è¡Œ</li>
</ul>
<p>è¿™äº›æ˜¯æˆ‘ä»¬å°†è¦å®æ–½çš„è¡Œä¸º.ç¨åï¼Œæˆ‘ä»¬è¿˜ä¼š:</p>
<ul>
<li>åˆ é™¤cursoræŒ‡å‘çš„row</li>
<li>ä¿®æ”¹cursoræŒ‡å‘çš„row</li>
<li>ç”¨ç»™å®šçš„IDåœ¨tableä¸­æœç´¢,ç„¶åç”¨è¯¥IDåˆ›å»ºä¸€ä¸ªæŒ‡å‘é‚£ä¸€è¡Œçš„cursor</li>
</ul>
<p>å…ˆè¯´è¿™ä¹ˆå¤šï¼Œè¿™é‡Œæ˜¯<code>Cursor</code>çš„å®šä¹‰:</p>
<pre><code class="cpp">+typedef struct &#123;
+  Table* table;
+  uint32_t row_num;
+  bool end_of_table;  // Indicates a position one past the last element
+&#125; Cursor;
</code></pre>
<p>åŸºäºæˆ‘ä»¬ç›®å‰çš„tableç»“æ„ä½“ï¼Œtableä¸­çš„ä½ç½®å¯ä»¥ç”¨row numberæ ‡è¯†.</p>
<p>cursorè¿˜å…·æœ‰å¯¹å…¶æ‰€å½’å±çš„tableçš„å¼•ç”¨(æ‰€ä»¥æˆ‘ä»¬çš„cursorå‡½æ•°åªéœ€è¦cursorä¸€ä¸ªå‚æ•°).</p>
<p>æœ€åï¼Œå®ƒè¿˜æœ‰ä¸€ä¸ªå¸ƒå°”å˜é‡<code>end_of_table</code>ï¼Œè¿™è¢«ç”¨æ¥è¡¨ç¤ºtableçš„æœ«å°¾çš„åä¸€ä¸ªä½ç½®(ä¹Ÿå°±æ˜¯æˆ‘ä»¬æƒ³è¦æ’å…¥æ–°ä¸€è¡Œçš„ä½ç½®).</p>
<p>å‡½æ•°<code>table_start()</code>å’Œ<code>table_end()</code>åˆ›å»ºæ–°çš„cursors:</p>
<pre><code class="cpp">+Cursor* table_start(Table* table) &#123;
+  Cursor* cursor = malloc(sizeof(Cursor));
+  cursor-&gt;table = table;
+  cursor-&gt;row_num = 0;
+  cursor-&gt;end_of_table = (table-&gt;num_rows == 0);
+
+  return cursor;
+&#125;
+
+Cursor* table_end(Table* table) &#123;
+  Cursor* cursor = malloc(sizeof(Cursor));
+  cursor-&gt;table = table;
+  cursor-&gt;row_num = table-&gt;num_rows;
+  cursor-&gt;end_of_table = true;
+
+  return cursor;
+&#125;
</code></pre>
<p>å‡½æ•°<code>row_slot()</code>ä¼šå˜æˆ<code>cursor_value()</code>ï¼Œè¯¥å‡½æ•°ä¼šé€šè¿‡cursoræè¿°çš„ä½ç½®è¿”å›ä¸€ä¸ªæŒ‡å‘è¯¥è¡Œä½ç½®çš„æŒ‡é’ˆ:</p>
<pre><code class="cpp">-void* row_slot(Table* table, uint32_t row_num) &#123;
+void* cursor_value(Cursor* cursor) &#123;
+  uint32_t row_num = cursor-&gt;row_num;
   uint32_t page_num = row_num / ROWS_PER_PAGE;
-  void* page = get_page(table-&gt;pager, page_num);
+  void* page = get_page(cursor-&gt;table-&gt;pager, page_num);
   uint32_t row_offset = row_num % ROWS_PER_PAGE;
   uint32_t byte_offset = row_offset * ROW_SIZE;
   return page + byte_offset;
 &#125;
</code></pre>
<p>åŸºäºç›®å‰çš„tableç»“æ„ä½“,å°†cursorç§»åŠ¨åˆ°ä¸‹ä¸€è¡Œå’Œå¢åŠ è¡Œå·ä¸€æ ·ç®€å•,è€Œåœ¨B-treeä¸­ä¼šç¨å¤æ‚ä¸€äº›.</p>
<pre><code class="cpp">+void cursor_advance(Cursor* cursor) &#123;
+  cursor-&gt;row_num += 1;
+  if (cursor-&gt;row_num &gt;= cursor-&gt;table-&gt;num_rows) &#123;
+    cursor-&gt;end_of_table = true;
+  &#125;
+&#125;
</code></pre>
<p>æœ€åæˆ‘ä»¬éœ€è¦è®©â€è™šæ‹Ÿæœºâ€çš„å‡½æ•°ä½¿ç”¨cursorè¿™ä¸€æŠ½è±¡æ•°æ®ç»“æ„.å½“æˆ‘ä»¬æ’å…¥ä¸€è¡Œäº‹ï¼Œæˆ‘ä»¬æ‰“å¼€ä¸€ä¸ªæŒ‡å‘tableæœ«å°¾çš„cursor,æ•°æ®å†™å…¥åˆ°cursorå¯¹åº”çš„ä½ç½®ï¼Œç„¶åé‡Šæ”¾cursor.</p>
<pre><code class="cpp">   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);
+  Cursor* cursor = table_end(table);

-  serialize_row(row_to_insert, row_slot(table, table-&gt;num_rows));
+  serialize_row(row_to_insert, cursor_value(cursor));
   table-&gt;num_rows += 1;

+  free(cursor);
+
   return EXECUTE_SUCCESS;
 &#125;
</code></pre>
<p>å½“é€‰ä¸­tableçš„æ‰€æœ‰è¡Œï¼Œæˆ‘ä»¬æ‰“å¼€ä¸€ä¸ªæŒ‡å‘tableå¼€å¤´çš„cursor,æ‰“å°è¿™ä¸€è¡Œï¼Œç„¶åcursorç§»åŠ¨åˆ°ä¸‹ä¸€è¡Œ.ä¸€ç›´é‡å¤åˆ°åˆ°è¾¾tableçš„æœ«å°¾.</p>
<pre><code class="cpp"> ExecuteResult execute_select(Statement* statement, Table* table) &#123;
+  Cursor* cursor = table_start(table);
+
   Row row;
-  for (uint32_t i = 0; i &lt; table-&gt;num_rows; i++) &#123;
-    deserialize_row(row_slot(table, i), &amp;row);
+  while (!(cursor-&gt;end_of_table)) &#123;
+    deserialize_row(cursor_value(cursor), &amp;row);
     print_row(&amp;row);
+    cursor_advance(cursor);
   &#125;
+
+  free(cursor);
+
   return EXECUTE_SUCCESS;
 &#125;
</code></pre>
<p>å¥½äº†ï¼Œåšå®Œè¾£!å’Œæˆ‘è¯´çš„ä¸€æ ·ï¼Œè¿™ä¸ªå°å°çš„é‡æ„åœ¨æˆ‘ä»¬å°†tableç»“æ„ä½“é‡å†™æˆB-treeçš„æ—¶å€™æä¾›å¸®åŠ©.</p>
<p>å‡½æ•°<code>execute_select()</code>å’Œ<code>execute_insert()</code>å¯ä»¥é€šè¿‡cursorå’Œtableå®Œæ•´çš„äº¤äº’ï¼Œè€Œä¸éœ€è¦åœ¨ä¹tableæ˜¯å¦‚ä½•å­˜å‚¨çš„.</p>
<p>è¿™é‡Œæ˜¯æœ¬ç« çš„å…¨éƒ¨æ”¹åŠ¨:</p>
<pre><code class="cpp">@@ -78,6 +78,13 @@ struct &#123;
 &#125; Table;

+typedef struct &#123;
+  Table* table;
+  uint32_t row_num;
+  bool end_of_table; // Indicates a position one past the last element
+&#125; Cursor;
+
 void print_row(Row* row) &#123;
     printf(&quot;(%d, %s, %s)\n&quot;, row-&gt;id, row-&gt;username, row-&gt;email);
 &#125;
@@ -126,12 +133,38 @@ void* get_page(Pager* pager, uint32_t page_num) &#123;
     return pager-&gt;pages[page_num];
 &#125;

-void* row_slot(Table* table, uint32_t row_num) &#123;
-  uint32_t page_num = row_num / ROWS_PER_PAGE;
-  void *page = get_page(table-&gt;pager, page_num);
-  uint32_t row_offset = row_num % ROWS_PER_PAGE;
-  uint32_t byte_offset = row_offset * ROW_SIZE;
-  return page + byte_offset;
+Cursor* table_start(Table* table) &#123;
+  Cursor* cursor = malloc(sizeof(Cursor));
+  cursor-&gt;table = table;
+  cursor-&gt;row_num = 0;
+  cursor-&gt;end_of_table = (table-&gt;num_rows == 0);
+
+  return cursor;
+&#125;
+
+Cursor* table_end(Table* table) &#123;
+  Cursor* cursor = malloc(sizeof(Cursor));
+  cursor-&gt;table = table;
+  cursor-&gt;row_num = table-&gt;num_rows;
+  cursor-&gt;end_of_table = true;
+
+  return cursor;
+&#125;
+
+void* cursor_value(Cursor* cursor) &#123;
+  uint32_t row_num = cursor-&gt;row_num;
+  uint32_t page_num = row_num / ROWS_PER_PAGE;
+  void *page = get_page(cursor-&gt;table-&gt;pager, page_num);
+  uint32_t row_offset = row_num % ROWS_PER_PAGE;
+  uint32_t byte_offset = row_offset * ROW_SIZE;
+  return page + byte_offset;
+&#125;
+
+void cursor_advance(Cursor* cursor) &#123;
+  cursor-&gt;row_num += 1;
+  if (cursor-&gt;row_num &gt;= cursor-&gt;table-&gt;num_rows) &#123;
+    cursor-&gt;end_of_table = true;
+  &#125;
 &#125;

 Pager* pager_open(const char* filename) &#123;
@@ -327,19 +360,28 @@ ExecuteResult execute_insert(Statement* statement, Table* table) &#123;
     &#125;

   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);
+  Cursor* cursor = table_end(table);

-  serialize_row(row_to_insert, row_slot(table, table-&gt;num_rows));
+  serialize_row(row_to_insert, cursor_value(cursor));
   table-&gt;num_rows += 1;

+  free(cursor);
+
   return EXECUTE_SUCCESS;
 &#125;

 ExecuteResult execute_select(Statement* statement, Table* table) &#123;
+  Cursor* cursor = table_start(table);
+
   Row row;
-  for (uint32_t i = 0; i &lt; table-&gt;num_rows; i++) &#123;
-     deserialize_row(row_slot(table, i), &amp;row);
+  while (!(cursor-&gt;end_of_table)) &#123;
+     deserialize_row(cursor_value(cursor), &amp;row);
      print_row(&amp;row);
+     cursor_advance(cursor);
   &#125;
+
+  free(cursor);
+
   return EXECUTE_SUCCESS;
 &#125;
</code></pre>
<h2 id="Part-7-Introduction-to-the-B-Tree"><a href="#Part-7-Introduction-to-the-B-Tree" class="headerlink" title="Part 7 - Introduction to the B-Tree"></a>Part 7 - Introduction to the B-Tree</h2><p>B-Treeæ˜¯SqLiteç”¨æ¥è¡¨ç¤ºtablså’Œç´¢å¼•çš„æ•°æ®ç»“æ„ï¼Œæ‰€ä»¥å®ƒæ˜¯ä¸€ä¸ªå¾ˆæ ¸å¿ƒçš„æ¦‚å¿µ.æœ¬ç« åªä¼šä»‹ç»è¿™ç§æ•°æ®ç»“æ„ï¼Œä¸ä¼šåŒ…å«ä»»ä½•ä»£ç .</p>
<p>ä¸ºæ£®è«æ ‘è¿™ç§æ•°æ®ç»“æ„éå¸¸é€‚åˆæ•°æ®åº“æ?</p>
<ul>
<li>æœç´¢æ•°æ®çš„é€Ÿåº¦éå¸¸å¿«(O(logn)æ—¶é—´å¤æ‚åº¦)</li>
<li>æ’å…¥&#x2F;åˆ é™¤ä½ æ‰¾åˆ°çš„å€¼éå¸¸å¿«(å¹³è¡¡æ“ä½œæ—¶é—´å¤æ‚åº¦ä¸ºO(1))</li>
<li>éå†èŒƒå›´å†…çš„æ•°å€¼å¾ˆå¿«(è€Œä¸åƒhash map)</li>
</ul>
<p>B-Treeå’ŒäºŒå‰æ ‘ä¸åŒ(â€œBâ€å¯èƒ½æ˜¯æ¥è‡ªå‘æ˜è€…çš„åå­—,ä½†ä¹Ÿå¯èƒ½è¡¨ç¤ºâ€å¹³è¡¡â€).è¿™é‡Œæœ‰ä¸€ä¸ªB-Treeçš„ä¾‹å­:</p>
<p>example B-Tree (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/File:B-tree.svg">https://en.wikipedia.org/wiki/File:B-tree.svg</a>)</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/B-tree.png"><img src="https://cstack.github.io/db_tutorial/assets/images/B-tree.png" alt="example B-Tree (https://en.wikipedia.org/wiki/File:B-tree.svg)"></a></p>
<p>ä¸äºŒå‰æ ‘ä¸åŒï¼ŒB-Treeçš„æ¯ä¸€ä¸ªèŠ‚ç‚¹å¯ä»¥æœ‰<strong>ä¸¤ä¸ªä»¥ä¸Š</strong>çš„å­©å­.æ¯ä¸ªèŠ‚ç‚¹<strong>è‡³å¤šæ‹¥æœ‰mä¸ªå­©å­</strong>,<code>m</code>å«åšæ ‘çš„â€é˜¶â€.ä¸ºäº†ä¿æŒæ ‘å°½å¯èƒ½å¹³è¡¡ï¼ŒèŠ‚ç‚¹<strong>è‡³å°‘å¾—æ‹¥æœ‰</strong><code>m/2</code>(<strong>å››èˆäº”å…¥</strong>)ä¸ªå­©å­.</p>
<p>ç‰¹æ®Šæƒ…å†µ:</p>
<ul>
<li>å¶å­èŠ‚ç‚¹æ²¡æœ‰å­©å­</li>
<li>æ ¹èŠ‚ç‚¹çš„å­©å­å¯ä»¥å°‘äº<code>m</code>ä¸ªä½†è‡³å°‘å¾—æ˜¯2ä¸ª</li>
<li>å¦‚æœæ ¹èŠ‚ç‚¹æ˜¯å¶å­èŠ‚ç‚¹(æ ‘åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹),é‚£ä¹ˆå®ƒæœ‰0ä¸ªå­©å­</li>
</ul>
<p>ä¸Šé¢çš„å›¾ç‰‡æ˜¯ä¸€æ£µB-Tree,SQLiteç”¨å®ƒæ¥å­˜å‚¨ç´¢å¼•.è‡³äºå­˜å‚¨tables,Sqliteä½¿ç”¨B-Treeçš„å˜ç§-<code>B+ Tree</code>.</p>
<style>
    #table {
        margin: 0 auto;
        text-align: center;
        border: 1px solid grey;
        border-collapse: collapse;
        line-height: 1.6em;
    }
    #table th,#table td {
        border: 1px solid grey;
        padding: 0.5em;
    }
</style>



<table id="table">
<thead>
<tr>
<th></th>
<th>B-Tree</th>
<th>B+ Tree</th>
</tr>
</thead>
<tbody><tr>
<td>å‘éŸ³</td>
<td>"Bee Tree"</td>
<td>"Bee Plus Tree"</td>
</tr>
<tr>
<td>å­˜å‚¨çš„æ•°æ®</td>
<td>ç´¢å¼• Index</td>
<td>è¡¨æ ¼ Table</td>
</tr>
<tr>
<td>å†…éƒ¨èŠ‚ç‚¹å­˜å‚¨key</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>å†…éƒ¨èŠ‚ç‚¹å­˜å‚¨value</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹</td>
<td>Less</td>
<td>More</td>
</tr>
<tr>
<td>å†…éƒ¨èŠ‚ç‚¹ vs å¶å­èŠ‚ç‚¹</td>
<td>ç»“æ„ç›¸åŒ</td>
<td>ç»“æ„ä¸åŒ</td>
</tr>
</tbody></table>

<p>åœ¨æˆ‘ä»¬å®ç°indexä¹‹å‰ï¼Œæˆ‘åªä¼šä»‹ç»B+Tree,ä½†æˆ‘ä¼šæŠŠå®ƒç§°ä¸º B-Treeæˆ–è€…btree.</p>
<p>æœ‰å­©å­çš„èŠ‚ç‚¹å«åšâ€å†…éƒ¨â€èŠ‚ç‚¹ï¼Œå†…éƒ¨èŠ‚ç‚¹å’Œå¶å­èŠ‚ç‚¹å…·æœ‰ä¸åŒçš„ç»“æ„:</p>
<table id="table">
<thead>
<tr>
<th>ä¸€æ£µ<strong>m</strong>é˜¶æ ‘â€¦</th>
<th>å†…éƒ¨èŠ‚ç‚¹</th>
<th>å¶å­èŠ‚ç‚¹</th>
</tr>
</thead>
<tbody><tr>
<td>å­˜å‚¨</td>
<td>key &amp; æŒ‡å‘å­©å­çš„æŒ‡é’ˆ</td>
<td>key &amp; value</td>
</tr>
<tr>
<td>keyçš„ä¸ªæ•°</td>
<td>è‡³å¤š <strong>m-1</strong></td>
<td>å°½å¯èƒ½å¤š</td>
</tr>
<tr>
<td>æŒ‡é’ˆçš„ä¸ªæ•°</td>
<td>keyçš„ä¸ªæ•°+1</td>
<td>none</td>
</tr>
<tr>
<td>valueçš„ä¸ªæ•°</td>
<td>none</td>
<td>å’Œkeyçš„ä¸ªæ•°ä¸€æ ·</td>
</tr>
<tr>
<td>keyçš„ä½œç”¨</td>
<td>ç”¨äºè·¯ç”±</td>
<td>å’Œvalueé…å¯¹</td>
</tr>
<tr>
<td>å­˜å‚¨value?</td>
<td>no</td>
<td>yes</td>
</tr>
</tbody></table>

<p>è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªä¾‹å­æ¥çœ‹ä¸€æ£µB-treeåœ¨æ’å…¥å…ƒç´ åæ˜¯å¦‚ä½•æˆé•¿çš„,ç®€å•èµ·è§ï¼Œtreeæ˜¯ä¸‰é˜¶çš„,è¿™æ„å‘³ç€:</p>
<ul>
<li>å†…éƒ¨èŠ‚ç‚¹è‡³å¤šæœ‰3ä¸ªå­©å­</li>
<li>å†…éƒ¨èŠ‚ç‚¹è‡³å¤šæœ‰2ä¸ªkey</li>
<li>å†…éƒ¨èŠ‚ç‚¹è‡³å°‘æœ‰2ä¸ªå­©å­</li>
<li>å†…éƒ¨èŠ‚ç‚¹è‡³å°‘æœ‰1ä¸ªkey</li>
</ul>
<p>ä¸€æ£µç©ºB-treeåªæœ‰ä¸€ä¸ªèŠ‚ç‚¹:æ ¹èŠ‚ç‚¹.</p>
<p>æ ¹èŠ‚ç‚¹ä¸€å¼€å§‹æ˜¯ä¸€ä¸ªæ²¡æœ‰é”®å€¼å¯¹çš„å¶å­èŠ‚ç‚¹:</p>
<p>empty btree</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree1.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree1.png" alt="empty btree"></a></p>
<p>å¦‚æœæˆ‘ä»¬æ’å…¥äº†2ä¸ªé”®å€¼å¯¹ï¼Œä»–ä»¬ä¼šæŒ‰é¡ºåºè¢«å­˜å‚¨åœ¨å¶å­èŠ‚ç‚¹.</p>
<p>on-node btree</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree2.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree2.png" alt="one-node btree"></a></p>
<p>è®©æˆ‘ä»¬è§„å®šå¶å­èŠ‚ç‚¹çš„å®¹é‡ä¸º2ä¸ªé”®å€¼å¯¹.å½“æˆ‘ä»¬æ’å…¥å¦ä¸€ä¸ªï¼Œæˆ‘ä»¬å¾—åˆ†è£‚å¶å­èŠ‚ç‚¹ç„¶åå¶å­èŠ‚ç‚¹å¹³åˆ†é”®å€¼å¯¹.æ¯ä¸ªå¶å­èŠ‚ç‚¹éƒ½ä¼šæˆä¸ºä¸€ä¸ªæ–°çš„å†…éƒ¨èŠ‚ç‚¹çš„å­©å­(è¯¥å†…éƒ¨èŠ‚ç‚¹ç°åœ¨å˜æˆäº†æ ¹èŠ‚ç‚¹.)</p>
<p>two-level btree</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree3.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree3.png" alt="two-level btree"></a></p>
<p>å†…éƒ¨èŠ‚ç‚¹ç°åœ¨æ‹¥æœ‰1ä¸ªkeyå’Œ2ä¸ªæŒ‡å‘å­©å­çš„æŒ‡é’ˆ.å¦‚æœæˆ‘ä»¬æƒ³è¦æŸ¥æ‰¾ä¸€ä¸ª&lt;&#x3D;5çš„key,æˆ‘ä»¬ä¼šåœ¨å·¦å­©å­é‡ŒæŸ¥æ‰¾ï¼Œå¦‚æœæƒ³æ‰¾&gt;&#x3D;5çš„key,ä¼šåœ¨å³å­©å­é‡ŒæŸ¥æ‰¾.</p>
<p>ç°åœ¨è®©æˆ‘ä»¬æ’å…¥key â€œ2â€.é¦–å…ˆæˆ‘ä»¬ä¼šæŸ¥æ‰¾å®ƒå¯èƒ½åœ¨é‡Œé¢çš„å¶å­èŠ‚ç‚¹,ç„¶åæˆ‘ä»¬åˆ°è¾¾äº†å·¦è¾¹çš„å¶å­èŠ‚ç‚¹.è¿™ä¸ªèŠ‚ç‚¹æ»¡äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬åˆ†è£‚å®ƒç„¶ååœ¨çˆ¶èŠ‚ç‚¹ä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„å…¥å£.</p>
<p>four-node btree</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree4.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree4.png" alt="four-node btree"></a></p>
<p>è®©æˆ‘ä»¬ç»§ç»­å¢åŠ key 18&amp;21ï¼Œæˆ‘ä»¬ä¸å¾—ä¸å†æ¬¡åˆ†è£‚èŠ‚ç‚¹.ä½†æ˜¯çˆ¶èŠ‚ç‚¹ä¸­æ²¡æœ‰ç©ºé—´å­˜æ”¾å¦ä¸€ä¸ªé”®å€¼å¯¹äº†(keyä¸ªæ•°æœ€å¤šä¸ºm-1&#x3D;2).</p>
<p>no room in internal node</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree5.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree5.png" alt="no room in internal node"></a></p>
<p>è§£å†³æ–¹æ¡ˆæ˜¯åˆ†è£‚æ ¹èŠ‚ç‚¹ä¸ºä¸¤ä¸ªå†…éƒ¨èŠ‚ç‚¹ï¼Œç„¶ååˆ›å»ºä¸€ä¸ªæ–°çš„æ ¹èŠ‚ç‚¹ä½œä¸ºå®ƒä»¬çš„çˆ¶èŠ‚ç‚¹.</p>
<p>three-level btree</p>
<p><a target="_blank" rel="noopener" href="https://cstack.github.io/db_tutorial/assets/images/btree6.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree6.png" alt="three-level btree"></a></p>
<p>æ ‘çš„é«˜åº¦åªæœ‰åœ¨æˆ‘ä»¬åˆ†è£‚æ ¹èŠ‚ç‚¹çš„æ—¶å€™å¢åŠ .æ¯ä¸ªå¶å­èŠ‚ç‚¹éƒ½æœ‰ç›¸åŒçš„æ·±åº¦å’Œæ•°é‡å¤§è‡´ç›¸åŒçš„é”®å€¼å¯¹ï¼Œæ‰€ä»¥æ ‘ä¿æŒäº†å¹³è¡¡ç„¶åå¯ä»¥å¿«é€Ÿæœç´¢.</p>
<p>æˆ‘æš‚ä¸”ä¸ä¼šè®¨è®ºåˆ é™¤treeçš„keyç›´åˆ°æˆ‘ä»¬å®æ–½äº†æ’å…¥æ“ä½œ.</p>
<p>å½“æˆ‘ä»¬å®æ–½äº†è¿™ä¸€æ•°æ®ç»“æ„ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¼šå¯¹åº”ä¸€ä¸ªpage.æ ¹èŠ‚ç‚¹ä¼šåœ¨page 0,æŒ‡å‘å­©å­çš„æŒ‡é’ˆå®é™…ä¸Šæ˜¯è¯¥å­©å­èŠ‚ç‚¹çš„page number.</p>
<p>ä¸‹ä¸€æ¬¡,æˆ‘ä»¬å¼€å§‹å®æ–½ btree!</p>
</br>

</br>

<p><strong>é‰´äºå…¨éƒ¨ç« èŠ‚å†…å®¹å®åœ¨æ˜¯æœ‰ã€å°å¤šï¼Œæ‰€ä»¥ç¬¬7ç« åé¢çš„æ”¾åœ¨äº†å¦ä¸€ä¸ª<a href="https://faceless00.github.io/2022/04/28/yourSql-2/">åœ°æ–¹</a></strong></p>
    </div>
  </div>
</article> 
  </div>
  
<link rel="stylesheet" href="/css/footer.css">



<script src="/js/highlight.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>

<div id="footer"></div>
 
</body>