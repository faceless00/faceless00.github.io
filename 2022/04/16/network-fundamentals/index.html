<!DOCTYPE html>
<html lang=" ">
<head>
  <meta charset="utf-8" />
<link rel="icon" href="/images/rev_sheep.png " />
<title>almostSalted</title>
<meta name="referrer" content="no-referrer" />
<meta name="google-site-verification" content="_CsSd0yrTQQrdEyoybq1kZNTZbIVulPo3zdQnaqAR0Y" />
<link rel="stylesheet" href="/css/highlight/styles/monokai.min.css" />
  
<link rel="stylesheet" href="/css/layout.css">

<meta name="generator" content="Hexo 6.1.0"></head>
<body>
  
<link rel="stylesheet" href="/css/header.css">


<div class="topBar">
  <img class="icon" src="/images/rev_sheep.png " />
  <div class="menu">
     
    <a href="/ ">home</a>
     
    <a href="/archives ">archives</a>
     
    <a href="/categories ">categories</a>
     
    <a href="/aboutme ">aboutme</a>
     
    <a href="/diary ">diary</a>
    
  </div>
</div>
<div class="blank"></div>
  <div class="wrapper">
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div id="post">
  <aside id="navigator">
    <ol class="anchor"><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#Introduction"><span class="anchor-number">1.</span> <span class="anchor-text">Introduction</span></a></li><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#OSI-Model"><span class="anchor-number">2.</span> <span class="anchor-text">OSI Model</span></a></li><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#Ethernet"><span class="anchor-number">3.</span> <span class="anchor-text">Ethernet</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#HUB"><span class="anchor-number">3.1.</span> <span class="anchor-text">HUB</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Switch"><span class="anchor-number">3.2.</span> <span class="anchor-text">Switch</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Swittie"><span class="anchor-number">3.3.</span> <span class="anchor-text">Swittie</span></a></li></ol></li><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#IP"><span class="anchor-number">4.</span> <span class="anchor-text">IP</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Concept"><span class="anchor-number">4.1.</span> <span class="anchor-text">Concept</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#ARP"><span class="anchor-number">4.2.</span> <span class="anchor-text">ARP</span></a></li></ol></li><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#TCP"><span class="anchor-number">5.</span> <span class="anchor-text">TCP</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Connect-Establishment"><span class="anchor-number">5.1.</span> <span class="anchor-text">Connect Establishment</span></a></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Data-Transfer"><span class="anchor-number">5.2.</span> <span class="anchor-text">Data Transfer</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Retransmission"><span class="anchor-number">5.2.1.</span> <span class="anchor-text">Retransmission</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Example"><span class="anchor-number">5.2.2.</span> <span class="anchor-text">Example</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#checksum"><span class="anchor-number">5.2.3.</span> <span class="anchor-text">checksum</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Sweetie"><span class="anchor-number">5.2.4.</span> <span class="anchor-text">Sweetie</span></a></li></ol></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Connect-Termination"><span class="anchor-number">5.3.</span> <span class="anchor-text">Connect Termination</span></a></li></ol></li><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#Life-of-a-Packet"><span class="anchor-number">6.</span> <span class="anchor-text">Life of a Packet</span></a></li><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#TLS"><span class="anchor-number">7.</span> <span class="anchor-text">TLS</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Encryption"><span class="anchor-number">7.1.</span> <span class="anchor-text">Encryption</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#data-signature"><span class="anchor-number">7.1.1.</span> <span class="anchor-text">data signature</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Man-in-the-Middle"><span class="anchor-number">7.1.2.</span> <span class="anchor-text">Man in the Middle</span></a></li></ol></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#Procedure"><span class="anchor-number">7.2.</span> <span class="anchor-text">Procedure</span></a><ol class="anchor-child"><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Handshake"><span class="anchor-number">7.2.1.</span> <span class="anchor-text">Handshake</span></a></li><li class="anchor-item anchor-level-3"><a class="anchor-link" href="#Data-Transfer-1"><span class="anchor-number">7.2.2.</span> <span class="anchor-text">Data Transfer</span></a></li></ol></li><li class="anchor-item anchor-level-2"><a class="anchor-link" href="#SNI"><span class="anchor-number">7.3.</span> <span class="anchor-text">SNI</span></a></li></ol></li></ol>
  </aside>
  <div id="content">
    <div id="postHead">
      <h1>network fundamentals</h1>
      <div class="postDate">
        <img class="dateIcon" src="/images/clockicon.svg" />
        --2022.4.16
      </div>
        
        <div class="postCategory">
            <a href="/categories/original/">original</a>
        </div>
         
    </div>
    <div id="postBody">
      <style>
    .wikitable{
        margin: 0 auto;
        text-align:center;
        border: 1px solid #a2a9b1;
        border-collapse: collapse; 
        line-height: 1.6em;
    }
    .wikitable th{
        border: 1px solid #a2a9b1;
        padding: 0.2em;
    }
    .wikitable td{
        border: 1px solid #a2a9b1;
        padding: 0.2em 0.4em;
    }
</style>

<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>在我翻译文章的时候,总是遭到网络协议的粗暴的性对待,我想是时候了结了!</p>
<p>本篇文章没有必要按顺序看,毕竟我就不是按顺序写的.我先写的是TCP部分🐿🐿</p>
<p><br></br></p>
<h1 id="OSI-Model"><a href="#OSI-Model" class="headerlink" title="OSI Model"></a>OSI Model</h1><p>cloudflare这篇文章写的还行,<a target="_blank" rel="noopener" href="https://www.cloudflare.com/zh-cn/learning/ddos/glossary/open-systems-interconnection-model-osi/">link</a></p>
<p><img src="https://www.cloudflare.com/img/learning/ddos/what-is-a-ddos-attack/osi-model-7-layers.svg" alt="img"></p>
<p>不过其实没必要分那么细,通常来说分为4层就够了:</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-16/c778b922229a4ab74029c487883dd4f5.png" alt="image-20220416200112258"></p>
<p>自下而上的看,首先是<code>DATALINK Layer</code></p>
<blockquote>
<p>简要来讲,作用有2:</p>
<ol>
<li>数据传播的形式是电平,所以需要把高低电平转换为2进制数据</li>
<li>规定数据的传输形式,数据的基本单位是帧(frame),以MAC地址区分不同的设备,有线传输的协议是以太网<code>Ethernet</code>,无线传输的协议是<code>Wi-Fi</code></li>
</ol>
<p>数据链路层只能用于<strong>局域网</strong>内传输.</p>
</blockquote>
<p><code>Network Layer</code>网络层:</p>
<blockquote>
<p>网络层主机的标识符为IP,至于为什么不用MAC地址,是因为MAC地址只是一个唯一的序列,但是IP地址是根据区域划分的</p>
<p>IP地址的格式:<code>123.123.234.234</code>,4段,每段的范围 <code>0-255</code>,因为每段只能占一个字节</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-16/12125dc6ef80cb229b0708ba29f622f2.png" alt="image-20220416203247277"></p>
<p>一个IP地址分为这两部分,网络号用来标识主机位于的子网,主机号是局域网内设备的标识</p>
<p>而数据传输,也叫路由,是将数据从一个区域传输到另一个区域,也就是从一个子网传输到另一个子网</p>
<p>至于为什么要分两部分,举个相似的例子:身份证,身份证前6位是地区编号,网络号也起着相似的作用</p>
<p>计算网络号的方式是 <code>IP &amp; netmask</code>,netmask是子网掩码</p>
</blockquote>
<p><code>transport layout</code> 传输层:</p>
<blockquote>
<p>网络层实现主机与主机之间的通信,但是一个主机可能运行不止一个进程,所以使用端口来区分不同进程的数据包</p>
<p>比如说,你在运行一个QQ,QQ占用的端口是4000,那么地址为<code>192.168.111.1:4000</code>就是发送给QQ的数据包</p>
<p>传输层主要有两个协议,TCP&#x2F;UDP</p>
<p>TCP用于可靠的传输数据,首先在传输方与接收方之间建立连接,把数据拆分为多个数据包,然后按顺序传输数据,如果过程有丢包还要重传</p>
<p>UDP只发送数据包,不管数据包是否到达目的地,LOL用的就是UDP</p>
</blockquote>
<p><code>application layout</code> 应用层</p>
<blockquote>
<p>TCP&#x2F;IP协议簇已经实现了进程与进程之间的可靠通信,而应用层就是在这之上,规定一些具有特定结构的数据的传输协议</p>
<p>对于传输层来说,数据就只是二进制流,但是在应用层,数据被协议赋予了特定的意义,比如说HTTP把数据分为<code>head &amp; body</code>,<code>head</code>用来存储一些额外的信息,比如域名,cookie之类的,而<code>body</code>就是真正需要的数据了</p>
<p><code>HTTP HTTPS SMTP</code>等都是应用层协议</p>
</blockquote>
<p><br></br><br></br></p>
<h1 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a>Ethernet</h1><p>以太网主要用于局域网内传输数据,设备的唯一标识是MAC地址(48bit)</p>
<p>在以太网协议中,数据的格式为帧(frame).</p>
<p><code>Ethernet 2 Frame</code>(以太 II 帧,也称作DIX以太网):</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-21/0a8e062d03d5f4878f8071210b2b8b6b.png" alt="image-20220421212539089"></p>
<p>type段占俩字节,实际上就只有两种:</p>
<ul>
<li><code>0x0080</code>,表示IPV4</li>
<li><code>0x0806</code>,表示这是一个ARP包(ARP协议的讲解在IP中,概括的说是根据IP获得MAC地址)</li>
</ul>
<h2 id="HUB"><a href="#HUB" class="headerlink" title="HUB"></a>HUB</h2><p>最简单的通讯方式是两台主机直接通过线缆连接,当设备多了起来,需要一个中继设备(hub)间接转发数据包,使用同一个hub的主机组成局域网(LAN).</p>
<p><img src="data:image/png;base64,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" alt="img"></p>
<p>主机与hub的端口相连,也就是一个主机对应一个hub的端口,主机间的通讯,是通过一种广播(broadcast)机制</p>
<p>集线器在接收到数据包之后,并不会直接将包传输给符合MAC地址的主机,而是将包发向所有端口,然后主机检查自己的MAC地址是否与包中的一致(数据帧的头部的Destination),如果一直就接收包,不一致就忽略包.</p>
<p>hub的问题有二:</p>
<ul>
<li>多个主机同时需要传输数据时会造成堵塞</li>
<li>半双工,同一时间通信双方数据传输只能有一个方向,不能边读边写</li>
</ul>
<p>为了解决这些问题而出现了交换机.</p>
<h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>参考:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/michael9/p/13199165.html">link</a></p>
<p><img src="https://network.fasionchan.com/zh_CN/latest/_images/3026a7ee9579986199ce1c6971fb02ae.png" alt="img"></p>
<p>交换机是<strong>全双工</strong>的,通俗的讲就是可以边吃边拉,通信端可以一边读取数据,一边发出数据.</p>
<p>交换机内部维护一张MAC地址表,记录<strong>MAC地址与端口</strong>的对应关系.</p>
<p>辣么,在忽略VLAN(virtual LAN)的情况下,传输数据包的规则如下:</p>
<ol>
<li>查询MAC表,是否记录了数据包的<strong>源MAC</strong>地址<ul>
<li>存在,<code>continue</code></li>
<li>不存在,表中插入一条记录:<code>MAC-Port</code></li>
</ul>
</li>
<li>查询MAC表,是否记录了数据包的<strong>目标MAC</strong>地址<ul>
<li>存在,<strong>单播</strong>转发</li>
<li>不存在,执行<strong>泛洪</strong>(相当于<strong>广播</strong>).各个主机接收到数据包检查目的MAC地址,是的话就笑纳,不是的话就婉拒.</li>
</ul>
</li>
</ol>
<blockquote>
<p>有一些点需要注意:</p>
<ul>
<li>交换机只记录数据帧的<strong>源MAC</strong>与<strong>端口</strong>的对应关系,至于为什么不记录目标MAC与端口的对应关系,我暂且蒙在交换机的ass里(可能是没有必要?反正你迟早要发送数据包).</li>
<li>交换机层面有4种帧:广播帧,未知帧,同端帧(源mac和目的mac指向同一端口,实际上就是俩mac相等),异端帧.</li>
<li>广播帧是目的MAC地址全为F的情况,也就是<code>FF:FF:FF:FF:FF:FF</code>,这种情况下交换机会向所有端口转发,主机看到mac地址全为<code>F</code>就直接把帧笑纳了</li>
<li>当出现未知帧,也就是MAC表中找不到对应端口的帧,会进行泄洪,泄洪相当于广播,只不过地址不是全<code>F</code>,主机会比对mac地址决定是否接收该帧</li>
<li>异端帧会进行单播转发</li>
<li>同端帧被丢弃,你可能会想,那我平时怎么访问<code>127.0.0.1</code>的？蒽,我猜测回环地址<code>127.0.0.1</code>是一个虚拟网卡,网卡驱动会特殊处理,不过我毕竟妹写过驱动,所以这是瞎猜.</li>
<li>这里只是对交换机的抽象化的描述,具体的情形要比这复杂的多.请读者自行查阅.</li>
</ul>
</blockquote>
<h2 id="Swittie"><a href="#Swittie" class="headerlink" title="Swittie"></a>Swittie</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91">virtual-LAN</a></p>
<p>简单来说,就是主机通过MAC地址,IP地址,协议之类进行分组.</p>
<p>主要作用捏,就是防止目标mac位置,泛洪造成堵塞.分组之后泛洪只在一个VLAN中进行,不会广播到所有设备,高端一点的说法就是广播隔离(好吧,偷自维基百科).</p>
<p>在之前说过,主机在发现帧的目的MAC与自己不一致,就会丢弃这个包,那有没有不丢弃的方法呢,有的.</p>
<p>有线网卡可以开启混杂(promisc)模式,接收所有数据帧,对应的无线网卡有监听(monitor)模式.</p>
<p>用airmon-ng提醒邻居提高wifi强度(小心真人快打)的时候,就要开启网卡监听模式.</p>
<p><a target="_blank" rel="noopener" href="https://network.fasionchan.com/zh_CN/latest/practices/ethernet-programming-c.html#">这里有一个简易的ethernet协议C语言实现</a></p>
<p><br></br><br></br></p>
<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><p>IP,IP,You mom’s P.</p>
<p><br></br></p>
<h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><p>虽然IP说到底就是一个根据区域划分的唯一标识符,但初接触时还是会遇到一些不太友好的概念.</p>
<p><code>IP</code>,Internet Protocol,位于传输层之下,链路层之上.主要的作用是根据源IP与目的IP实现两台主机之间的数据传输,为此定义了数据结构和寻址方法.</p>
<p>wiki:</p>
<blockquote>
<p>数据在IP互联网中传送时会封装为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%8C%85">数据包</a>.网际协议的独特之处在于:在报文交换网络中主机在传输数据之前,无须与先前未曾通信过的目的主机预先创建好特定的”通路”.互联网协议提供了<strong>不可靠</strong>的数据包传输机制(也称”尽力而为”或”尽最大努力交付”)；也就是说,它<strong>不保证数据能准确的传输</strong>.数据包在到达的时候<strong>可能已经损坏,顺序错乱</strong>(与其它一起传送的报文相比),产生冗余包,或者全部丢失.如果<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6">应用</a>需要保证可靠性,一般需要采取其他的方法,例如利用IP的上层协议控制(TCP).</p>
</blockquote>
<p><code>IP Address</code> 32位整数,每8位为一段,每段范围<code>0-255</code></p>
<p><code>netmask</code> 子网掩码</p>
<blockquote>
<p>是一个和IP地址类似的数据,用来将IP分成网络段和主机段.前面说过,IP地址是根据区域划分的,一片区域有多个主机,这些主机同属于一个<strong>子网</strong>,所以,标识IP地址对应的区域实际上是IP所属的子网.<code>netmask</code>就是用来计算IP所对应的子网的(也就是网段)</p>
<p><code>IP &amp; netmask</code>&#x3D; 网段	按位与运算</p>
<p>比如说 ip&#x3D;174.185.123.111,netmast&#x3D;255.255.255.0</p>
<p>那么网段就是 174.185.123.0</p>
<p>把IP比作身份证是很贴切的,比如身份证的前6位是地区编码,但IP的网段长度不是固定的,所以需要子网掩码.</p>
</blockquote>
<p><code>gate</code></p>
<blockquote>
<p>网关(说实话,我觉得网管更贴切).<strong>网关</strong>其实是用来<strong>路由</strong>的设备的<strong>IP地址</strong>,所谓的路由,抽象的说就是将数据包传输到目的IP的主机上.</p>
<p>那么,用自己的电脑路由不行吗?当然是行的(比如openwrt,笔者的树莓派就用来当路由器),但是有专门用来路由的设备 - router(路由器).</p>
<p>这样,连接到同一路由器的主机发送的数据包都由路由器统一转发,然后路由器又转发到另一个路由器… 最后到达目的地.</p>
</blockquote>
<p><code>dns</code></p>
<blockquote>
<p>Domain Name System,域名解析系统.</p>
<p>因为IP不太好记,就用域名比如<code>www.google.com</code>代替google服务器的IP地址.</p>
<p>实际访问时域名会从DNS服务器查询对应的IP地址.</p>
<p>使用<code>whois</code>命令可以查询域名的一些信息.<img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-19/bf8fd2ef0818d128650b2f9e6645147a.png" alt="image-20220419004642397"></p>
</blockquote>
<p>IP数据包结构体:</p>
<table class="wikitable" style="text-align:center"><table class="wikitable" style="text-align:center">
<tbody><tr>
<th width="4%">位偏移
</th>
<th colspan="4" width="12%">0–3
</th>
<th colspan="4" width="12%">4–7
</th>
<th colspan="6" width="24%">8–13
</th>
<th colspan="2" width="6%">14-15
</th>
<th colspan="3" width="9%">16–18
</th>
<th colspan="13" width="39%">19–31
</th></tr>
<tr>
<th>0
</th>
<td colspan="4">版本
</td>
<td colspan="4">首部长度
</td>
<td colspan="6">区分服务
</td>
<td colspan="2">显式拥塞通告
</td>
<td colspan="16">全长
</td></tr>
<tr>
<th>32
</th>
<td colspan="16">标识符
</td>
<td colspan="3">标志
</td>
<td colspan="13">分片偏移
</td></tr>
<tr>
<th>64
</th>
<td colspan="8"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%AD%98%E6%B4%BB%E6%99%82%E9%96%93" title="存活时间">存活时间</a>
</td>
<td colspan="8"><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%8D%8F%E8%AE%AE" class="mw-disambig" title="协议">协议</a>
</td>
<td colspan="16">首部检验和
</td></tr>
<tr>
<th>96
</th>
<td colspan="32">源IP地址
</td></tr>
<tr>
<th>128
</th>
<td colspan="32">目的IP地址
</td></tr>
<tr>
<th>160
</th>
<td colspan="32" bgcolor="grey">选项(如首部长度&gt;5)
</td></tr>
<tr>
<th>160<br />or<br />192+
</th>
<td colspan="32">&#160;<br />数据<br />&#160;
</td></tr></tbody></table>

<p><br></br></p>
<table class="wikitable">
<caption>特殊IP地址
</caption>
<tbody><tr>
<th>网络号
</th>
<th>主机号
</th>
<th>是否可以作为源地址
</th>
<th>是否可以作为目的地址
</th>
<th>备注/描述
</th></tr>
<tr>
<td>全为0
</td>
<td>全为0
</td>
<td>允许
</td>
<td>禁止
</td>
<td>表示本网主机
</td></tr>
<tr>
<td>全为0
</td>
<td>Host ID
</td>
<td>允许
</td>
<td>禁止
</td>
<td>表示特定主机
</td></tr>
<tr>
<td>全为1
</td>
<td>全为1
</td>
<td>禁止
</td>
<td>允许
</td>
<td>定向广播地址
</td></tr>
<tr>
<td>127
</td>
<td>任意合法的值
</td>
<td>允许
</td>
<td>允许
</td>
<td>迂回地址,用于本地测试
</td></tr>
<tr>
<td>Network ID
</td>
<td>全为1
</td>
<td>禁止
</td>
<td>允许
</td>
<td>直接广播地址
</td></tr></tbody></table>



<p>这里介绍一下直接广播地址,广播地址的<code>IP</code>为网段内的最后一个地址,该数据包会转发给网段内所有主机.</p>
<h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>Address Resolution Protocol,地址解析协议.</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE">wiki</a></p>
<p><code>TCP/IP</code>协议簇根据<code>IP:Port</code>确定主机上的特定进程,只需要知道对方的ip和端口就可以传输数据.</p>
<p>数据包的封装是自上而下的,<code>tcp</code>包到ip层被封装成<code>ip</code>包,然后到<strong>数据链路层</strong>,而<a href="#Ethernet">Ethernet</a>协议需要知道<strong>目标ip的MAC地址</strong>才可以传输数据包(ip包此时作为以太网数据包的数据部分),如果在<code>ARP</code>表中没有ip对应的MAC地址(比如重启或者第一次与该网段通讯),主机会暂存数据包.</p>
<p>于是,需要一种协议来获取ip所对应的MAC地址,没错,就是ARP协议.</p>
<p><code>ARP</code>协议位于IP层之下,目标IP(一般是IP协议,当然也有可能是别的)地址包含在数据部分.通过发送一个ARP包来获得目标IP的MAC地址,数据包的<strong>目标MAC地址为<code>FF:FF:FF:FF:FF:FF</code></strong>,其实是利用了广播机制,(在数据链路层)交换机会将数据包转发给目标IP所在的局域网内所有主机(的网卡),然后拆包传递给上层协议(没错,封装是自上而下的,拆包是自下而上的),在IP层,如果<strong>主机的IP地址与数据包的目标IP相同</strong>,那么会<strong>给源IP回应一个arp包</strong>,这样就得到了MAC地址(只要你不太笨的话,应该就能知道封装数据包的时候会在<a href="#ethernet-frame">以太网数据帧的头部</a>写入源MAC),然后源主机会把MAC缓存在arp表中,之后再传输数据时直接查表就行辣.</p>
<p>ARP协议对应的以太网数据帧:</p>
<ul>
<li>MAC地址全为1(你不能连这个都不理解吧,6个<code>FF</code>实际上是48个1的十六进制格式,笨蛋)</li>
<li><a href="#ethernet-frame">数据帧类型</a>为<code>0x0806</code></li>
</ul>
<table class="wikitable" style="text-align:center;"><tbody><tr>
<th>长度(bit)</th>
<th>48</th>
<th>48</th>
<th>16</th>
<th>16</th>
<th>16</th>
<th>8</th>
<th>8</th>
<th>16</th>
<th>48</th>
<th>32</th>
<th>48</th>
<th>32
</th></tr>
<tr>
<td style="min-height:60px;"><b>数据类型</b></td>
<td style="width:96px;">目标以太网地址</td>
<td style="width:96px;">源以太网地址</td>
<td style="width:32px;">帧类型</td>
<td style="width:32px;">硬件类型</td>
<td style="width:32px;">协议类型</td>
<td style="width:16px;">硬件地址长度</td>
<td style="width:16px;">协议地址长度</td>
<td style="width:32px;">操作码</td>
<td style="width:96px;">源硬件地址</td>
<td style="width:64px;">源协议地址</td>
<td style="width:96px;">目标硬件地址</td>
<td style="width:64px;"><p>目标协议地址</p><b>(IP在这!)</b>
</td></tr>
<tr>
<td><b>组成</b></td>
<td colspan="3">14字节 以太网首部</td>
<td colspan="9">28字节 ARP请求/应答
</td></tr></tbody></table>



<p><br></br><br></br></p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>tcp,全称 <code>Transmission Control Protocol</code>,传输控制协议.</p>
<p>wiki:</p>
<blockquote>
<p>在因特网协议族(Internet protocol suite)中,TCP层是位于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">IP</a>层之上,<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E5%B1%82">应用层</a>之下的中间层.不同主机的应用层之间经常需要可靠的、像<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)">管道</a>一样的连接,但是IP层不提供这样的流机制,而是提供不可靠的包交换.</p>
</blockquote>
<h2 id="Connect-Establishment"><a href="#Connect-Establishment" class="headerlink" title="Connect Establishment"></a>Connect Establishment</h2><p>TCP头部结构:</p>
<table class="wikitable">
<caption>TCP表头
</caption>
<tbody><tr>
<th style="border-bottom:none; border-right:none;">偏移
</th>
<th style="border-left:none;"><a href="/wiki/%E4%BD%8D%E5%85%83%E7%BB%84" class="mw-redirect" title="比特组">字节</a>
</th>
<th colspan="8">0
</th>
<th colspan="8">1
</th>
<th colspan="8">2
</th>
<th colspan="8">3
</th></tr>
<tr>
<th style="border-top: none">字节
</th>
<th><tt><a href="/wiki/%E4%BD%8D%E5%85%83" title="比特">比特</a></tt></th>
<th><tt>&#160;0</tt></th>
<th><tt>&#160;1</tt></th>
<th><tt>&#160;2</tt></th>
<th><tt>&#160;3</tt></th>
<th><tt>&#160;4</tt></th>
<th><tt>&#160;5</tt></th>
<th><tt>&#160;6</tt></th>
<th><tt>&#160;7</tt></th>
<th><tt>&#160;8</tt></th>
<th><tt>&#160;9</tt></th>
<th><tt>10</tt></th>
<th><tt>11</tt></th>
<th><tt>12</tt></th>
<th><tt>13</tt></th>
<th><tt>14</tt></th>
<th><tt>15</tt></th>
<th><tt>16</tt></th>
<th><tt>17</tt></th>
<th><tt>18</tt></th>
<th><tt>19</tt></th>
<th><tt>20</tt></th>
<th><tt>21</tt></th>
<th><tt>22</tt></th>
<th><tt>23</tt></th>
<th><tt>24</tt></th>
<th><tt>25</tt></th>
<th><tt>26</tt></th>
<th><tt>27</tt></th>
<th><tt>28</tt></th>
<th><tt>29</tt></th>
<th><tt>30</tt></th>
<th><tt>31</tt>
</th></tr>
<tr>
<th>0
</th>
<th><tt> 0</tt>
</th>
<td colspan="16">来源连接端口</td>
<td colspan="16">目的连接端口
</td></tr>
<tr>
<th>4
</th>
<th><tt>32</tt>
</th>
<td colspan="32">序列号码
</td></tr>
<tr>
<th>8
</th>
<th><tt>64</tt>
</th>
<td colspan="32">确认号码(当<tt>ACK</tt>设置)
</td></tr>
<tr>
<th>12
</th>
<th><tt>96</tt>
</th>
<td colspan="4">资料偏移(TCP头部长度)</td>
<td colspan="3">保留<br /><tt><b>0 0 0</b></tt></td>
<td><tt>N<br />S</tt></td>
<td><tt>C<br />W<br />R</tt></td>
<td><tt>E<br />C<br />E</tt></td>
<td><tt>U<br />R<br />G</tt></td>
<td><tt>A<br />C<br />K</tt></td>
<td><tt>P<br />S<br />H</tt></td>
<td><tt>R<br />S<br />T</tt></td>
<td><tt>S<br />Y<br />N</tt></td>
<td><tt>F<br />I<br />N</tt></td>
<td colspan="16">窗口大小
</td></tr>
<tr>
<th>16
</th>
<th><tt>128</tt>
</th>
<td colspan="16">Checksum 校验和</td>
<td colspan="16">紧急指针(当<tt>URG</tt>设置)
</td></tr>
<tr>
<th>20<br />...
</th>
<th><tt>160<br />...</tt>
</th>
<td colspan="32" style="background:grey;">选项(如果资料偏移 &gt; 5,需要在结尾添加0.)<br />...
</td></tr></tbody></table>




<p>虽然TCP连接是双向的,数据可以双向传输,不过根据实际情况,不妨把想要建立TCP连接的叫做cli,监听TCP连接的叫做ser</p>
<p>创建连接的过程叫做<code>三次握手</code>,双方一共发送三个数据包.</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6100773-0cf533a29cf7b09e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<ol>
<li>cli想要与ser建立连接,发送一个<code>SYN</code>数据包,数据包中包含一个由cli生成的<code>随机数A</code>,A是序号(请先忽略序号这个概念)</li>
<li>ser接收<code>SYN</code>包,给cli发送<code>SYN/ACK</code>包,包含一个由ser生成的<code>随机数B</code>以及确认号<code>A+1</code></li>
<li>cli接收<code>SYN/ACK</code>包,给ser发送<code>ACK</code>包,包含确认号<code>B+1</code></li>
</ol>
<p>建立连接的过程很可能不稳定,比如网络延迟之类的.如果在步骤2之后ser没有接收到cli发送的ACK包,这时处于一个中间态,既没有成功也没有失败(抄自维基百科),ser会假定之前发送的SYN&#x2F;ACK丢失了,于是重新发送 <code>SYN/ACK</code>包,如果接收到cli发送的<code>ACK</code>,辣么建立连接.</p>
<p>但如果一直没有接收到cli的ACK,ser会在重复发送几次<code>ACK/SYN</code>数据包之后结束此次连接.在Linux中,一般最多重复5次,<strong>每次发送间隔翻倍</strong>,1s,2s,4s,8s,16s,总共浪费的时间为1+2+4+8+16+32(在最后一次发送包之后还要等待32s才确认超时)&#x3D;63s</p>
<p>三次握手的目的是为了防止<strong>已经失效</strong>的建立连接的<code>ACK</code>报文(比如因为网络延迟,在cli接收不到应答之后关闭连接,这时cli已经不想建立连接了)被服务器接收然后建立连接,因为是三步验证,所以ser在接收到失效的ACK报文后发送的用于验证的<code>SYN/ACK</code>给cli,cli不会给ser发送<code>ACK</code>包确认建立连接,而ser在重复发送 <code>SYN/ACK</code>之后<strong>始终不会接收到<code>ACK</code>报文</strong>,然后ser关闭连接,此过程只有63s,不会浪费太多资源</p>
<p>如果只有两次握手,即第三次的cli验证报文不需要发送就可以建立连接,那么假设昨天cli给ser发送了一个<code>SYN</code>数据包但是因为网络滞留了一天,所以今天才被ser接收到,<code>ser</code>随即发送<code>SYN/ACK</code>数据包,并且认为连接已经确定,<strong>但cli忽视<code>SYN/ACK</code>包,也不会发送数据给ser</strong>,但是ser这时候<strong>一直在等待cli发送数据</strong>,这样就会浪费资源,而在三次握手的情况下,此连接会因为cli一直没有响应而在63s后被ser断开.</p>
<blockquote>
<p>举一个简单的例子:</p>
<p>A给B打电话,但是B今天不在家所以一直没接听,所以A给B留了个语音留言(SYN滞留).第二天B接听了A的语音留言,回拨给A,但是此时A不会接B的电话,因为A今天不想与B通话,B在电话无人接听之后又打了几次,最后结束通话.</p>
</blockquote>
<p>那么,cli何以肯定ser发送过来的<code>SYN/ACK</code>无效呢？这就要用到序号<code>SN(sequence number)</code>与确认号<code>ACKN(acknowledge number)</code>了,还记得在过程12生成的随机数A和B吗?简单来说,因为<code>SYN/ACK</code>包的<strong>确认号</strong>是无效的,cli拒绝建立连接.</p>
<h2 id="Data-Transfer"><a href="#Data-Transfer" class="headerlink" title="Data Transfer"></a>Data Transfer</h2><p>序号和确认号的概念对于某些笨蛋来说相当绕,但其实它们两个只是一个相对的概念,相对发送数据的主体.</p>
<p>在tcp层面上,数据被叫做字节流<code>stream</code>,数据是按字节顺序传输的,对于流中的每一个字节,都有一个确定的序号,理解成数组下标就行了,只不过数组的起始下标不是0,而是一个随即数X</p>
<p>序号是发送的字节流的起始字节的编号,确认号是对方发送的字节流的起始字节的编号.TCP接收者在接收到一定数量连续字节流# TLS后才发送确认.</p>
<p>确认号的作用是告诉数据发送方上一个包已经收到,确认号实际上是希望接收的下一个数据包的序号.</p>
<p>序号是32位无符号整形,范围<code>0-65536</code>,在增大到65536后会回绕到0.</p>
<p>TPC使用序号并把数据分组,保证数据即使乱序传输仍能以正确顺序拼接数据块,也无需担心丢包问题(丢了再重传就是了).</p>
<h3 id="Retransmission"><a href="#Retransmission" class="headerlink" title="Retransmission"></a>Retransmission</h3><p>基于重复累计ACK的重传</p>
<blockquote>
<p>wiki:</p>
<p>如果一个包(不妨设它的序号是100,即该包始于第100字节)丢失,接收方就不能确认这个包及其以后的包,因为采用了累计ack.接收方在收到100以后的包时,发出对包含第99字节的包的确认.这种重复确认是包丢失的信号.发送方如果收到3次对同一个包的确认,就重传最后一个未被确认的包.阈值设为3被证实可以减少乱序包导致的无作用的重传(spurious retransmission)现象.<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE#%E9%80%89%E6%8B%A9%E6%80%A7%E7%A1%AE%E8%AE%A4">选择性确认</a>(SACK)的使用能明确反馈哪个包收到了,极大改善了TCP重传必要的包的能力.</p>
</blockquote>
<p>超时重传</p>
<blockquote>
<p>wiki:</p>
<p>发送方使用一个保守估计的时间作为收到数据包的确认的超时上限.如果超过这个上限仍未收到确认包,发送方将重传这个数据包.每当发送方收到确认包后,会重置这个重传定时器.典型地,定时器的值设定为<img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-17/72463a1f9a6b296417943ea10e8c0439.png" alt="image-20220417140717151"></p>
<p>进一步,如果重传定时器被触发,仍然没有收到确认包,定时器的值将被设为前次值的二倍(直到特定阈值).</p>
<blockquote>
<p>细心的你一定发现了,之前说过三次握手过程中一直没有接收到cli的ACK包,ser重新发送SYN&#x2F;ACK的时间间隔将每次翻倍</p>
</blockquote>
<p>这是由于存在一类通过欺骗发送者使其重传多次,进而压垮接收者的攻击,而使用前述的定时器策略可以避免此类<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击</a>方式的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB">拒绝服务攻击</a>.</p>
</blockquote>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>重点是:<strong>数据接收方</strong>每<strong>接收</strong>到一个数据包,就会向<strong>数据发送方</strong>发送一个<code>ACK</code>包表示自己接收到数据包了.但是如果有包丢失,即使接收到后续的包,<code>ACK</code>的确认号始终是丢失的包的序号.</p>
<blockquote>
<p>注意,<code>ACK</code>包长度为0,也就是说ACK不占用序号(毕竟它不被用来传输数据,只是告诉数据发送方接收到了数据包)</p>
</blockquote>
<p>wiki讲的很好,我就不重复造轮子了:</p>
<ol>
<li>发送方首先发送第一个包含<code>序号为1</code>(实际上是一个随机数,这里为了简化设为1)和<code>200字节</code>数据的TCP报文段给接收方.接收方以一个 <strong>没有数据的TCP报文段(也就是<code>ACK</code>包)</strong> 来回复(只含报头),用<code>确认号201</code>来表示已完全收到并请求下一个报文段(而201,也是下一个报文段的序号,上一个数据包的起始序号为1,长度200,序号范围为<code>1-200</code>).</li>
<li>发送方然后发送第二个包含<code>序列号为201,长度为100字节</code>的数据的TCP报文段给接收方.正常情况下,接收方回复ACK包,用<code>确认号301(201+100)</code>来表示已完全收到并请求下一个报文段.发送接收这样继续下去.</li>
<li>然而当这些数据包都是相连的情况下,接收方没有必要每一次都回应.比如,他收到第1到5条TCP报文段,只需回应第五条就行了.如果<code>第3条</code>TCP报文段被丢失了,就算尽管他收到了第4和5条,然而他<code>只能回应第2条</code>(接收第4,5条不会发送ACK包回应,因为数据流断开了),即<code>ACK包的确认号</code>始终是<code>301</code>.</li>
<li>发送方在发送了第3条以后,没能收到回应,因此当时钟(timer)过时(expire)时,他重发第三条.(每次发送者发送一条TCP报文段后,都会再次启动一次时钟:RTT).</li>
<li>这次第三条被成功接收,接收方可以直接确认第5条,因为4,5两条已收到.</li>
</ol>
<h3 id="checksum"><a href="#checksum" class="headerlink" title="checksum"></a>checksum</h3><p>checksum-校验和,可以校验一些简单的数据包传输错误.</p>
<p>校验和计算设计TCP头部和数据段,还有伪头部(96位),伪头部是一个虚拟的数据结构,实际上TCP并不包含这一部分,伪头部包括源IP,目标IP,协议和TCP长度,要包含伪头部的原因是校验的时候可以检查数据包是否被正确路由</p>
<pre><code class="cpp">typedef struct PsuedoHeader&#123;
    uint32_t source;
    uint32_t dest;
    uint8_t reserved;	//保留字节,全部置0
    uint8_t protocol;
    uint16_t length;
    
&#125;;	//一共12字节
</code></pre>
<p>校验和计算:将伪头部,TCP头部和数据部分求和,然后求<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%8F%8D%E7%A0%81">反码</a>(1的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E4%B8%80%E8%A3%9C%E6%95%B8">补码</a>)</p>
<p>校验和会被装入TCP头部,接收方接收到数据报文后会进行校验,校验不需要再重复求一边校验和了,只需要计算<code>PsuedoHeader+TCP_Header+data+checksum</code>,如果所有位都为1,说明数据没问题.</p>
<h3 id="Sweetie"><a href="#Sweetie" class="headerlink" title="Sweetie"></a>Sweetie</h3><p>对于一些需要可靠传输的应用来说,TCP很有用,但是TCP并不适用与所有场合.</p>
<p>举个简单的例子,网络游戏,比如LOL,用的是UDP,虽然UDP只管传不管到没到,但这对LOL来说是可以忍受的,丢包只会让画面有些卡顿</p>
<p>但如果是TCP,首先TCP会将数据流分组,或者说缓存了一定大小的数据包才发送,这表示如果你按了个技能,这个数据太小导致TCP没有发送它而是和后续数据一块发,这显然是不能接受的,因为网络游戏需要即时反馈,不过可以通过<code>TCP_NODELAY</code>设置成直接发送.</p>
<p>但是还有一个问题,TCP丢包后会重发,这表示即使有那么一点点不关键的画面丢失了,TCP仍然会重新发包,然后接受端就得一直等丢失的包重传过来,1s,2s,4s… 作为一个玩家,我显然是不会玩这么猪比的游戏的,我宁愿接受UDP的漂移,也不要TCP的卡顿63s后的流畅画面</p>
<p>这篇文章讲的还行:<a target="_blank" rel="noopener" href="http://foryoung365.github.io/development/2016/09/08/tcpvsudp">link</a></p>
<h2 id="Connect-Termination"><a href="#Connect-Termination" class="headerlink" title="Connect Termination"></a>Connect Termination</h2><p>结束已经建立TCP连接,这个过程叫做4次挥手👋</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6100773-2aa2de2af9a76955.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>因为TCP的连接是双向的,所以任何一端在数据传输完毕后都可以请求关闭TCP连接.</p>
<p>但一端的数据传输完毕另一端不一定结束,因此关闭过程需要保证如果被动关闭的那一端仍有数据要发送,主动关闭的一端仍有接收数据的能力.</p>
<p>在下例中,cli主动请求关闭TCP连接,ser被动关闭</p>
<ol>
<li><p>cli发送<code>FIN</code>报文给ser,序号为<code>X</code>,此时cli停止发送数据,但仍能接收数据,进入<code>FIN_WAIT1</code>状态</p>
</li>
<li><p>ser接收<code>FIN</code>报文,发送<code>ACK</code>报文,序号为<code>Y</code>,确认号为<code>X+1</code>,ser进入<code>CLOSE_WAIT</code>状态,cli在接收<code>ACK</code>报文后进入<code>FIN_WAIT2</code>状态</p>
</li>
<li><p>在<code>CLOSE_WAIT</code>状态期间,ser仍能发送数据,在确认所有数据被cli接收之后,发送<code>FIN/ACK</code>报文,序号为<code>P</code>(在此期间可能发送了一些数据),确认号为<code>X+1</code>,ser进入<code>LAST_ACK</code>状态</p>
</li>
<li><p>cli接收<code>FIN/ACK</code>报文,发送<code>ACK</code>报文,序号为<code>X+1</code>,确认号为<code>P+1</code>,然后cli进入<code>TIME_WAIT</code>状态,该状态会持续<code>2MSL</code>(从发出<code>ACK</code>报文,到cli再接收到ser报文的时间,即一个报文来回一次的时间),如果在此期间cli没有接收到ser的报文,关闭连接.ser接收到<code>ACK</code>报文,关闭连接.</p>
<blockquote>
<p>之所以要等待<code>2MSL</code>时间:如果第4步cli发送的<code>ACK</code>包丢失了,ser会以为cli没接收到第3步的<code>FIN/ACK</code>报文,然后重新发送,cli在<code>2MSL</code>时间内接收到新的<code>FIN/ACK</code>报文,会重复第4步,重新计时.</p>
<p>为什么一定要确保ser接收到<code>ACK</code>报文捏,因为此时ser处于<code>LAST_ACK</code>状态,需要接收到cli的<code>ACK</code>报文之后才结束连接.</p>
</blockquote>
</li>
</ol>
<p>TLDR:</p>
<p>握手首先会释放一端到另一端的连接,然后主动释放的一端等待被动释放的一端传输完所有数据,之后双方互相确认,结束TCP连接.</p>
<blockquote>
<p>A:我说完了	<code>FIN</code>	<code>FIN_WAIT1</code></p>
<p>B:蒽,我知道你说完了 <code>ACK</code> <code>CLOSE_WAIT</code>,但我还没说完</p>
<p>B: . . . . . . (把话说完) <code>CLOSE_WAIT</code></p>
<p>B:蒽,我也说完了	<code>FIN/ACK</code>	<code>LAST_ACK</code></p>
<p>A:蒽,我知道你也说完了,但你个beyond最好是说完了	<code>ACK</code> <code>TIME_WAIT</code></p>
<p>B:挂了</p>
<p>A:等待<code>2MSL</code>	<code>TIME_WAIT</code></p>
<p>A:蒽,这B雀食是说完了,挂了</p>
</blockquote>
<h1 id="Life-of-a-Packet"><a href="#Life-of-a-Packet" class="headerlink" title="Life of a Packet"></a>Life of a Packet</h1><p>现在,必要的前提知识都已经具备,让我们来体验一下一个数据包的一生.</p>
<p>小提示:</p>
<blockquote>
<p>基于<code>Ethernet</code>,可以实现局域网内的数据传输.</p>
<p>基于<code>IP</code>,可以实现不同局域网内的主机间的数据传输.</p>
<p>基于<code>TCP</code>,可以实现不同局域网内的主机间的<strong>端口间的</strong>的<strong>可靠</strong>数据传输.</p>
<p>数据包的封装顺序是从上而下的(上层协议的数据包传递给下层,作为下一层协议的<strong>数据部分</strong>,然后在<strong>头部</strong>写入该层协议的信息,再传递给下一层…),处理是自上而下的,下层的数据被解包,数据部分传递给上一层.</p>
</blockquote>
<p>假设访问google,使用<code>post</code>请求(通常,<code>get</code>请求不会携带数据),首先要获得google.com的IP地址,查询IP使用的是DNS协议,这里不再赘述,通过dig查看IP:</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-19/beeec0bc5cd15c7eccf8bacf670b9756.png" alt="image-20220419132510285"></p>
<p>好辣,现在已经知道目标IP,那么开始传输数据包吧!</p>
<p>数据包将从应用层开始封装,这里使用了HTTP协议.封装而成的数据包长这样:</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-19/abe490a1938576b7c68e842e1178489b.png" alt="image-20220419130918711"></p>
<p>通常,<code>Head</code>包含一些有关请求的信息,而body是数据.</p>
<p>请求头信息:</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-19/cb3e4d2906173702d9e2906d521264ab.png" alt="image-20220419131049354"></p>
<p>然后,数据包被传输到传输层,使用TCP&#x2F;UDP协议,这里使用TCP.</p>
<p>如果未与目标主机建立连接,会首先建立连接,这里假设连接已经建立了,本机端口为10086,目标端口为80.在传输层数据包被封装成TCP包.</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-19/7d0707aa76372c80b4593de1ab178bf9.png" alt="image-20220419132934866"></p>
<p>然后把数据包传递到IP层,前面说已经建立过tcp连接,所以肯定知道MAC了,那么通过查询ARP表是可以获取<code>google.com</code>的某台服务器的<code>MAC</code>地址的,辣么,封装成IP包:</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-19/4c7e00019d39e7e0a613a674d7443bb8.png" alt="image-20220419133341045"></p>
<p>接下来就到数据链路层辣,数据链路层会将数据包封装成两个部分,定长为<code>14b</code>的头部和<code>44-1500b</code>的数据和<code>4b</code>的CRC校验码(校验码就是一种hash,用来检验数据包是否完好无损).因为这是个IP包而不是arp包,所以头部的<code>type=0x0080</code>,值得一提的是,http协议的默认端口就是80🐁🐁</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-21/7038e344471be3938b4ffca62165b957.png" alt="image-20220421212637694"></p>
<p>好,自此数据封装结束,进入物理层,我们假定你有一个路由器并且已经连上网,那么,数据包会通过网卡发送给网关(也就是路由器的IP,不过这里其实是路由器的MAC).</p>
<p>为什么要发送给网关捏?蒽,你的电脑没有路由功能,路由器有.</p>
<p>路由器会检查该数据包是否属于该子网,如果不属于,就要路由,所谓路由,就是计算从一个子网到另一个子网的最佳路径,这里不做赘述,总之,路由器会将数据包转发到下一个路由器,直到到达目的IP的子网内.</p>
<p>数据包是自上而下传输的,在物理层,该子网的交换机(或者路由器)会检查头部的目的<code>MAC</code>地址,然后将该数据包传输到<code>MAC</code>对应的端口.</p>
<p>好了,目标主机已经接收到数据包了,解包过程是自下而上的,和封包相反.</p>
<p>解包会将数据部分传递给上层协议,<code>ethernet-&gt;ip-&gt;tcp-&gt;http</code>,最后获取到<code>http body</code>的数据.</p>
<p>自此,一个数据包已经完成了它的任务,这里只是一个简化的过程,具体的过程要复杂的多,感兴趣的读者可自行了解.</p>
<p><a target="_blank" rel="noopener" href="https://network.fasionchan.com/zh_CN/latest/protocols/experiment-linux-routing.html">这里有一个简易的路由例子</a></p>
<p><br></br></p>
<p><br></br></p>
<h1 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h1><p>推荐一个网站:<a target="_blank" rel="noopener" href="https://tls.ulfheim.net/">link</a></p>
<p>TLS,全称<code>Transport Layer Security</code>,前身为SSL(Secure Socket Layer)</p>
<p>在了解这种技术之前,不妨先思考一下此技术为什么被开发出来？在万维网诞生之初,网络通信是明文的,这意味着使用中间人攻击就可以获取所有通信数据,并且篡改数据.因此,对于一些需要隐私的通信场景，例如网购,需要一种能够加密通信内容并且能够验证内容未被篡改的手段.</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A#%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E5%92%8C%E5%AF%86%E9%92%A5%E5%8D%8F%E5%95%86">wiki</a>:</p>
<blockquote>
<p><strong>传输层安全性协议</strong>(英语：<strong>T</strong>ransport <strong>L</strong>ayer <strong>S</strong>ecurity,缩写：<strong>TLS</strong>)及其前身<strong>安全套接层</strong>(英语：<strong>S</strong>ecure <strong>S</strong>ockets <strong>L</strong>ayer,缩写：<strong>SSL</strong>)是一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE">安全协议</a>,目的是为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF">互联网</a>通信提供安全及数据<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AE%8C%E6%95%B4%E6%80%A7">完整性</a>保障.<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E6%99%AF">网景</a>公司(Netscape)在1994年推出首版<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81%E7%80%8F%E8%A6%BD%E5%99%A8">网页浏览器</a>－<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E7%B6%B2%E6%99%AF%E9%A0%98%E8%88%AA%E5%93%A1">网景导航者</a>时,推出<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTTPS">HTTPS</a>协议,以SSL进行加密,这是SSL的起源.<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IETF">IETF</a>将SSL进行标准化,1999年公布TLS 1.0标准文件(<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2246">RFC 2246</a>).随后又公布TLS 1.1(<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc4346">RFC 4346</a>,2006年)、TLS 1.2(<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5246">RFC 5246</a>,2008年)和TLS 1.3(<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc8446">RFC 8446</a>,2018年).在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%80%8F%E8%A6%BD%E5%99%A8">浏览器</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%83%B5%E4%BB%B6">电子邮件</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E9%80%9A%E8%A8%8A">即时通信</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/VoIP">VoIP</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E7%B5%A1%E5%82%B3%E7%9C%9F">网络传真</a>等应用程序中,广泛使用这个协议.许多网站,如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Google">Google</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Facebook">Facebook</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Wikipedia">Wikipedia</a>等也以这个协议来创建安全连线,发送资料.目前已成为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91">互联网</a>上保密通信的工业标准.</p>
<p>SSL包含记录层(Record Layer)和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a>,记录层协议确定传输层数据的封装格式.传输层安全协议使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/X.509">X.509</a>认证,之后利用非对称加密演算来对通信方做身份认证,之后交换对称密钥作为会谈密钥(<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Session_key">Session key</a>).这个会谈密钥是用来将通信两方交换的资料做加密,保证两个应用间通信的保密性和可靠性,使客户与服务器应用之间的通信不被攻击者窃听.</p>
</blockquote>
<h2 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a>Encryption</h2><p>笼统的讲,加密技术分为两类 - <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86">对称加密</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">非对称加密</a>.</p>
<p>对称加密使用相同的密钥加密和解密数据,但是想直接用于网络通讯是不现实的：通讯双方首先要协商密钥,然后才能加密通讯.但是协商密钥是明文进行的,如果被窃听,那么数据加密就毫无意义了.但是,又必须在加密通信之前协商密钥,一种解决措施是以一个可靠的方式(显然不是明文传输)交换密钥,比如说我写封信给你(🐥🐥).</p>
<p>为了解决如上问题,需要一种能够堂而皇之的交换密钥的加密方法 - 非对称加密.</p>
<p>非对称加密使用两个密钥,公钥和私钥.其中一把密钥加密后的数据能够通过另一把钥匙解密,并且公钥和私钥是不等的.</p>
<p>一般来说使用公钥加密,私钥解密.公钥可以公开,私钥需要自己保存.</p>
<p>在交换了密钥之后,持有公钥的一方使用公钥加密数据,而窃听者因为没有私钥所以无法获取明文,从而保证了通信的安全.</p>
<p>此外,还需要一种方法来验证数据在传输过程中完整且未被篡改👇.</p>
<h3 id="data-signature"><a href="#data-signature" class="headerlink" title="data signature"></a>data signature</h3><img src="https://upload.wikimedia.org/wikipedia/commons/6/66/Digital_Signature_diagram_zh-CN.svg" alt="img" style="background:white;" />

<p>比如foo和bar通信：</p>
<ul>
<li>foo持有公钥,bar持有私钥</li>
<li>foo需要一种方法来验证bar传输过来的数据没有问题</li>
</ul>
<p>那么通信的过程是:</p>
<ol>
<li>bar要传输的数据是d1,用hash函数生成d1的hash值hd1(常见算法:MD5,HMAC,SHA1,SHA256),然后bar使用私钥<strong>加密hd1</strong></li>
<li>foo收到数据d1和数字签名hd1,使用公钥解密hd1,然后和d1的hash值比较,如果相同则数据完好.</li>
</ol>
<p>窃听者是无法篡改数字签名的,就算他用公钥解密了数字签名然后篡改,他也没有私钥对数字签名重新加密,所以数字签名能够很好的保证数据完好.</p>
<p>但其实还有一个问题,就是中间人攻击 <code>Man in the Middle</code>👇👇</p>
<h3 id="Man-in-the-Middle"><a href="#Man-in-the-Middle" class="headerlink" title="Man in the Middle"></a>Man in the Middle</h3><p>还是以foo和bar来举例,现在有一个坏蛋pee想要捣乱.</p>
<ul>
<li>pee有bar的公钥,bar有私钥,<code>现在foo和bar之间还未交换密钥</code></li>
<li>pee能够监听foo和bar之间的通信</li>
</ul>
<p>执行攻击的过程:</p>
<ol>
<li>foo想要bar的公钥,但是通信被pee截取了,于是pee把自己的公钥给了foo</li>
<li>foo使用pee的公钥加密发送给bar的数据,因此数据可以被pee解密,然后pee再用bar的公钥加密后发给bar</li>
<li>bar向foo发送的数据会被pee截取,pee使用bar的公钥解密,修改数据然后用自己的私钥加密发送给foo</li>
<li>foo使用pee的公钥解密,以为数据没问题.</li>
</ol>
<p><code>TLDR:在通信双方交换公钥之前,中间人用自己的公钥掉包原公钥,而通信端没有手段验证公钥的合法性.</code></p>
<p>因此,为了解决中间人攻击的问题,需要一个可靠的被信任的第三方机构提供验证公钥合法性的手段 - 证书.</p>
<blockquote>
<p>颁发证书的机构叫证书机构(我承认这是一句废话),证书机构会给网站颁发证书的过程(当然,一般是要收钱的) - 网站拥有者把自己的个人信息(比如邮箱,网站域名…)和公钥一起提交给证书机构,证书机构用自己的私钥加密的数据就是证书.</p>
</blockquote>
<p>现在,bar给foo发送公钥的时候还会顺带发送自己的证书,foo使用证书机构的公钥解密证书,然后验证自己收到的公钥是否和证书记录的一致,如果一致,那就没问题.</p>
<p>虽然pee可以监听请求,但是他对证书无能为力.首先,他不能篡改证书,毕竟他没有证书机构的私钥对篡改后的数据重新加密,其次他也没有证书证明foo访问的网站的公钥是pee的公钥(毕竟网站不是他的,证书机构不至于如此猪比).所以现在中间人攻击就被解决辣!</p>
<p>总结:证书机构真的是躺着赚钱,个beyond个人证书都得上千,我支持firefox和chrome制裁这些流氓证书机构.</p>
<h2 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h2><p>以上为TLS的基础知识,现在来具体了解TLS(SSL).</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Protocol_details">wiki</a></p>
<p>TLS架构:</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-20/d2d732bfb7e9f59642af3bb227a08809.png" alt="image-20220420173110378"></p>
<p>重要的是握手协议和记录协议:</p>
<p>握手协议用来交换密钥,记录协议用来加密&#x2F;解密数据.</p>
<h3 id="Handshake"><a href="#Handshake" class="headerlink" title="Handshake"></a>Handshake</h3><p>SSL:</p>
<p><img src="https://www.biaodianfu.com/wp-content/uploads/2021/12/ssl-flow.png" alt="img"></p>
<p>一共13个包,第一次建立SSL至少需要9个包.</p>
<p>TLS1.2:</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/d/d3/Full_TLS_1.2_Handshake.svg" alt="img" style="background:white;width:500px;" />

<p>以下内容根据TLS1.2</p>
<ol>
<li><p>协商阶段:</p>
<ul>
<li><p>cli发送<strong>ClientHello</strong>包给ser,数据包包含:最高支持的<strong>TLS版本</strong>,<strong>一个随机数</strong>,客户端支持的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cipher_suite" title="Cipher suite"><strong>密码套件</strong></a>和支持的<strong>压缩方法</strong>.(如果客户端是在恢复之前已建立的TLS会话,会发送一个<strong>session ID</strong>.)如果客户端可以使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation" title="Application-Layer Protocol Negotiation">数据层协议协商(一个TLS扩展)</a>,那么数据包还包含支持的应用层协议列表,比如HTTP.</p>
</li>
<li><p>ser响应一个<strong>ServerHello</strong>包,包含从客户端提供的方法里选择的<strong>TLS版本</strong>,<strong>一个随机数</strong>,<strong>密码套件和压缩方法</strong>.(如果同意恢复,会发送一个<strong>session ID</strong>).TLS是cli和ser共同支持的最高的版本.</p>
</li>
<li><p>ser发送<strong>Certificate</strong>信息(根据选择的密码套件,服务器可能忽略这一步).</p>
</li>
<li><p>ser发送<strong>ServerKeyExchange</strong>信息(同上),之前决定的密码套件所需要交换的数据包含在这一步.(比如DH算法就需要这一步)</p>
</li>
<li><p>ser发送<strong>ServerHelloDone</strong>信息,表示握手协商阶段完成.</p>
</li>
<li><p>cli响应<strong>ClientKeyExchange</strong>信息,包含cli生成的<code>pre master secret(预备主密钥)</code>,预备主密钥使用ser的公钥加密.</p>
</li>
<li><p>cli和ser使用随机数和<code>pre master secret</code>计算出一个共通密钥 - <strong>master secret</strong>(cli和ser计算出来的master secret是相同的).所有其他的密钥(比如对称密钥)都衍生自<code>master secret</code>和cli&amp;ser生成的随机数(随机数使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pseudorandomness" title="Pseudorandomness">pseudorandom</a>函数生成).</p>
</li>
</ul>
</li>
<li><p>cli发送<code>ChangeCipherSpec</code>记录给ser,本质上是告诉ser:现在我发送给你的数据将会被验证和加密</p>
</li>
<li><p>ser发送<code>ChangeCipherSpec</code>给cli:现在我发送给你的数据也会被验证和加密.</p>
</li>
<li><p>应用阶段:这时握手阶段已经结束,应用层协议已经确定.应用层的数据会被加密和验证(使用数字签名以确保信息未被更改).</p>
</li>
</ol>
<blockquote>
<p>由<code>master secret</code>衍生的密钥中:</p>
<ol>
<li><code>sysmmetric key</code>,对称密钥用于加密和解密信息(没错,虽然也可以用非对称加密,但是非对称加密的代价较大,对称加密比较省资源).</li>
<li><code>MAC key</code>,数据验证码密钥,用来生成数字签名MAC(Message Authentication Code)的密钥.</li>
</ol>
</blockquote>
<h3 id="Data-Transfer-1"><a href="#Data-Transfer-1" class="headerlink" title="Data Transfer"></a>Data Transfer</h3><p>简要介绍一下建立TLS连接后的数据传输过程.</p>
<p><img src="https://github.com/faceless00/forimg/raw/main/hexo/22-04-20/e89023214c52ce734768bd022dbf9b01.png" alt="image-20220420190421577"></p>
<p>现在有两个密钥,对称密钥和MAC密钥.</p>
<p>ser首先生成数字签名(MAC),使用MAC key计算出数据的MAC(或者说HMAC,hash mac,本质上是数据的hash值),然后用对称密钥加密数据.然后把数据发送给cli.</p>
<p>cli使用对称密钥解密数据,然后也使用MAC key计算出明文的MAC,然后和发送过来的MAC比较,如果相同则说明数据没问题.</p>
<p>因为中间人没有MAC密钥,所以即使修改了数据也无法生成数据对应的MAC.</p>
<h2 id="SNI"><a href="#SNI" class="headerlink" title="SNI"></a>SNI</h2><p>SNI(Server Name Indication)是TLS的一个扩展协议.</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA#%E7%B6%B2%E5%9D%80%E5%90%8D%E7%A8%B1%E5%B0%8D%E6%87%89(Name-based)">基于域名的虚拟主机</a>(即多个dns指向同一个IP,主机根据请求的域名提供不同的服务)允许多个DNS主机名由同一IP地址上的<strong>单个主机</strong>(通常为Web服务器)托管.为了实现这一点,服务器使用<strong>客户端请求的域名</strong>作为协议的一部分(对于HTTP,名称显示在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5%E5%88%97%E8%A1%A8">请求头头</a>中).但是,当使用HTTPS时,TLS握手发生在服务器看到任何HTTP头之前.因此,服务器不可能使用HTTP主机头中的信息来决定呈现哪个证书,并且因此只有由同一证书覆盖的名称才能由同一IP地址提供.</p>
<p>客户端在SNI扩展中发送要连接的主机名称,作为TLS协商的一部分.这使服务器能够提前选择正确的域名,并向浏览器提供相应TLS证书.从而,具有单个IP地址的服务器可以在获取公共证书不现实的情况下提供一组域名的TLS连接.</p>
<p>SNI在2003年6月的RFC 3546,《传输层安全(TLS)扩展》中加入到<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IETF">IETF</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/RFC">Internet RFCs</a>中.最新版本的标准是RFC 6066.</p>
<p><strong>TLDR: 客户端在和服务器建立TLS连接的时候会在 ClientHello 消息中放入客户端所请求的域名.</strong></p>
<p>由于SNI信息并未加密，审查者可以识别出用户访问的网站域名.现已被部分国家用于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%A1%E6%9F%A5">互联网审查</a>，如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E">防火长城</a>和韩国的KCSC(<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BB%A3%E6%92%AD%E9%80%9A%E4%BF%A1%E5%AF%A9%E8%AD%B0%E5%A7%94%E5%93%A1%E6%9C%83">广播通信审议委员会</a>).有两种方法可以解决这个问题.</p>
<p><code>Encrypted Client Hello</code></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Server_Name_Indication#Encrypted_Client_Hello">wiki</a></p>
<p>TLDR:在客户端和服务端交换公钥之前，使用客户端(浏览器)提前知道的公钥加密数据.</p>
<p>经典依旧 : In August 2020, the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Internet_censorship_in_China">Great Firewall of China</a> started blocking ESNI traffic, while still allowing ECH traffic.</p>
</blockquote>
    </div>
  </div>
</article> 
  </div>
  
<link rel="stylesheet" href="/css/footer.css">



<script src="/js/highlight.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>

<div id="footer"></div>
 
</body>