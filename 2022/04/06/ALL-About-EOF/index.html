<!DOCTYPE html>
<html lang=" ">
<head>
  <meta charset="utf-8" />
<link rel="icon" href="/images/rev_sheep.png " />
<title>almostSalted</title>
<meta name="referrer" content="no-referrer" />

  
<link rel="stylesheet" href="/css/layout.css">

<meta name="generator" content="Hexo 6.1.0"></head>
<body>
  
<link rel="stylesheet" href="/css/header.css">


<div class="topBar">
  <img class="icon" src="/images/rev_sheep.png " />
  <div class="menu">
     
    <a href="/ ">home</a>
     
    <a href="/archives ">archives</a>
     
    <a href="/categories ">categories</a>
     
    <a href="/aboutme ">aboutme</a>
     
    <a href="/diary ">diary</a>
    
  </div>
</div>
<div class="blank"></div>
  <div class="wrapper">
    
<link rel="stylesheet" href="/css/post.css">


<script src="/js/post.js"></script>


<div id="post">
  <aside id="navigator">
    <ol class="anchor"><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#introduction"><span class="anchor-number">1.</span> <span class="anchor-text">introduction</span></a></li><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#The-myth-of-the-EOF-character"><span class="anchor-number">2.</span> <span class="anchor-text">The myth of the EOF character</span></a></li><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#Some-demo-code"><span class="anchor-number">3.</span> <span class="anchor-text">Some demo code</span></a></li><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#Text-versus-binary-mode"><span class="anchor-number">4.</span> <span class="anchor-text">Text versus binary mode</span></a></li><li class="anchor-item anchor-level-1"><a class="anchor-link" href="#But-what-about-Control-D"><span class="anchor-number">5.</span> <span class="anchor-text">But what about Control-D?</span></a></li></ol>
  </aside>
  <div id="content">
    <div id="postHead">
      <h1>ALL About EOF</h1>
      <div class="postDate">
        <img class="dateIcon" src="/images/clockicon.svg" />
        --2022.4.6
      </div>
        
        <div class="postCategory">
            <a href="/categories/translation/">translation</a>
        </div>
         
    </div>
    <div id="postBody">
      <h1 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h1><p>C&#x2F;C++的初学者在 <code>reddit</code> 和 <code>stack overflow</code> 之类的网站发布的所有问题中,最常见的困惑是当程序中需要读取用户的输入或者读取文件时，对<code>end of file</code>条件的处理.(这篇文章写于 2012 年，10 年后还是这样 🤭)<br>据我估计，超过 95%的问题都表现出对<code>end-of-file</code>这个概念的完全误解.<br>本文试图解释与这个令人困惑的话题的所有相关问题,尤其是对于使用<code>windows</code>和<code>Unix-like</code>(比如我即将用作例子的 Linux)的<code>C C++</code>程序员</p>
<h1 id="The-myth-of-the-EOF-character"><a href="#The-myth-of-the-EOF-character" class="headerlink" title="The myth of the EOF character"></a>The myth of the EOF character</h1><p>许多初学者面对的第一个<code>end-of-file</code>问题是关于<code>EOF</code>字符,尽管实际上并没有这样的一个字符,但是人们认为有(不幸的是，译者初学 C 时也以为有这么个 b 字符 👿).无论 windows 或者 linux 操作系统都没有这种概念:用一个标记字符来表示文件的结束</p>
<p>如果你用<code>Notepad</code>，<code>Vim</code>或者其他文本编辑器创建一个文本文件，文件本身并不会包含一个特殊字符来标志文件结束.Windows 和 Linux 的文件系统都可以知道文件的确切字节长度,因此绝无必要用一个特殊字符标志文件结束.</p>
<p>既然 Windows 和 Linux 都不使用<code>EOF</code>字符，那么<code>EOF</code>这个概念从何而来?</p>
<p>well,在很久很久以前(上世纪 70 年代),有一个叫做<code>CP/M</code>的操作系统(为了丝滑的使用终端)，<code>CP/M</code>可以在<code>Zilog Z80,Intel 8080</code>之类的 8 位处理器上运行.<code>CP/M</code>的文件系统并不知道一个文件的字节长度，它只知道文件占据了多少个<code>block</code>(<code>注: block是文件系统层面上的概念，存储设备本身没有这一概念，因为存储设备的基本读写单位是扇区，但是扇区太小了，所以文件系统将block作为I/O操作的基本单位，通常block的大小4k，对应8个扇区</code>).这意味着如果一个文件的内容为<code>hello world</code>，<code>CP/M</code>不知道这个文件的大小为 11 字节-它只知道该文件占了一个长度至少为 128 字节的<code>block</code>.因为人们通常都想知道文件看起来多大，而不是占据了多少个<code>block</code>，因此需要一个<code>end-of-file</code>字符.<code>CP/M</code>重新使用了<code>ASCII</code>字符集的<code>Control-Z</code>字符(十进制为 26,十六进制为<code>0x1A</code>，最初的用途随着时间流逝已经消失了,<img src="https://gitee.com/salt3dfish/images/raw/master/hexo/22-04-06/7a655058ef48072a96caf0ff5c62377e.png" alt="image-20220406161103269">)用于这个目的-当<code>CP/M</code>系统上的程序读取到<code>Control-Z</code>字符时，通常会认为读取到了文件末尾…</p>
<p>没有任何规定强迫程序去做这件事;处理二进制数据的程序需要其他一些手段来确认是否已经读取到了文件末尾，并且操作系统本身不会特别处理<code>Control-Z</code>字符</p>
<blockquote>
<p>注:很抽象的一句话,让我来粗暴的解释一下</p>
<p>因为<code>CP/M</code>的文件系统只知道文件占据的<code>block</code>数，所以提供的<code>I/O</code>接口也必定是按<code>block</code>读写，但是文件的实际大小并不一定是<code>block</code>的整数倍，最后一块<code>block</code>的内容可能只占了一部分</p>
<p>程序需要知道文件在哪结束，但是系统只支持读取<code>block</code>，那只能人为地在文件末尾加一个文件结束的标志，最后大家决定用<code>Control-Z</code>来标志文件结束，也就是<code>EOF</code>字符，当程序读取到<code>EOF</code>，一般就认为读取完了</p>
<p>不过这只是程序层面的规定，对于操作系统本身，不会读到<code>EOF</code>字符就认为文件结束了,它只会按<code>block</code>读取</p>
</blockquote>
<p>当<code>MS-DOS</code>出现时，兼容<code>CP/M</code>系统非常重要(<code>CP/M</code>一度非常流行)，鉴于许多初版<code>MS-DOS</code>程序仅仅是<code>CP/M</code>上的程序的暴力移植，通过机器码转码器(这 mechanical translators 实在不知道咋翻译，通俗的讲就是将一种机器语言翻译成另一种机器语言)把<code>Z80/8080</code>机器码转码为<code>8086</code>机器码.因为这些程序<strong>没有被重写</strong>，所以仍然把<code>Control-Z</code>字符当作文件的结束标志，直到今天还是这样.事实上，对<code>Control-Z</code>的处理被内置到了<code>Microsoft C Runtime Library</code>(微软为自家操作系统上的 C 语言程序提供的函数库),当以文本模式打开文件时.</p>
<p>有必要再重申一次，<code>windows</code>系统本身不在乎<code>Control-Z</code>字符，这一行为完全取决于 MS 库，并且非常不幸的是几乎所有软件都引用了这个库.此外，这一问题仅会发生在 windows 上，Linux 及其他类 Unix 系统从不以任何形式将<code>Control-Z</code>或其他任何字符作为文件结束的标志.</p>
<blockquote>
<p>注:解释一下，<code>MCR</code>库提供了文件<code>I/O</code>接口，而大部分 win 程序进行<code>I/O</code>操作时都会调用这个接口，读取文件的行为由库中的函数定义，并且程序不需要自行判断文件读取结束(毕竟我微软的操作系统更先进一些)</p>
<p>win 系统本身也不会特殊处理<code>Control-Z</code>，也不需要处理，因为它知道文件的实际长度，唯一有可能处理<code>Control-Z</code>字符的是<code>MCR</code>库，当然它也不一定把它视作<code>EOF</code>，我实在是懒得去看<code>MCR</code>的源码，有兄弟看了记得告诉我一声</p>
</blockquote>
<h1 id="Some-demo-code"><a href="#Some-demo-code" class="headerlink" title="Some demo code"></a>Some demo code</h1><p>用下面的代码可以证明<code>MS</code>库的这个意料之外的特性.首先，写一个程序，在程序中向文本文件写入<code>Control-Z</code>字符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;a.txt&quot;</span>)</span></span>;</span><br><span class="line">    ofs&lt;&lt;<span class="string">&quot;第一行 1\n&quot;</span>;</span><br><span class="line">    ofs&lt;&lt;<span class="built_in">char</span>(<span class="number">26</span>);	<span class="comment">//control-z的ascii码是0x1A,十进制是26</span></span><br><span class="line">    ofs&lt;&lt;<span class="string">&quot;第二行 2\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论在 windows 或 Linux 上运行这个程序，都会创建一个文本文件，在文件的两行之间夹着一个<code>Control-Z</code>字符</p>
<blockquote>
<p>line1</p>
<p>0x1A(实际上是看不到的，因为这不是个可见字符)line2</p>
</blockquote>
<p>在 win 或 Linux 平台上，<code>Control-Z</code>字符作为输出时都没有特殊的含义.可以用命令行工具读取这个文件<code>a.txt</code></p>
<blockquote>
<p>Windows:</p>
<p><code>c:\Users\Me type a.txt</code></p>
<p>输出为:</p>
<blockquote>
<p>第一行 1</p>
</blockquote>
<p>注意只有第一行被打印出来了</p>
<blockquote>
<p>注:在 2022 的 4 月 6 日，译者重现了这段代码，惊喜的发现 windows 平台打印的是两行，可喜可贺，可喜可贺啊！巨硬，你还是有点可取之处的 👍👍</p>
<p><img src="https://gitee.com/salt3dfish/images/raw/master/hexo/22-04-06/ed24629fcb5daa7e658a5e5f5607456b.png" alt="image-20220406221531999"><img src="https://gitee.com/salt3dfish/images/raw/master/hexo/22-04-06/f92d4395cb04c11e4b6f6451df398260.png" alt="image-20220406221552995"><img src="https://gitee.com/salt3dfish/images/raw/master/hexo/22-04-06/9b2adbd4d133b7ddf951922efd96860b.png" alt="image-20220406221606880"></p>
<p>不过让我们先假定没有打印出第二行</p>
</blockquote>
<p>Linux:</p>
<p><code>~&gt; $ cat a.txt</code></p>
<p>输出为:</p>
<blockquote>
<p>第一行 1</p>
<p>?第二行 2</p>
</blockquote>
</blockquote>
<p>两行都能打印出来，但是出现了一个奇怪的字符<code>?</code>,因为<code>cat</code>命令把<code>Control-Z</code>视作普通字符，但是<code>Control-Z</code>不是可打印字符，所以用别的字符替换了它，具体是什么样取决于你的终端，比如译者的就是:</p>
<p><img src="https://gitee.com/salt3dfish/images/raw/master/hexo/22-04-06/4c2e29919d5eb6b2eb369fa0bfaaa523.png" alt="image-20220406221945054"></p>
<p>这好像暗示 windows 知道<code>Control-Z</code>字符，但是那不重要，本质上是某些软件知道这个字符.如果用记事本打开这个文件:<img src="https://latedev.files.wordpress.com/2012/12/screenshot_myfile-txt-notepad_2012-12-04_12-43-56_thumb.gif?w=199&h=90" alt="img1"></p>
<p>两行都被打印出来了，夹着一个<code>Control-Z</code>，显然记事本并未把<code>Control-Z</code>当作<code>end-of-file</code>标志</p>
<h1 id="Text-versus-binary-mode"><a href="#Text-versus-binary-mode" class="headerlink" title="Text versus binary mode"></a>Text versus binary mode</h1><p>那么，上面用的 type 命令和记事本之间到底有什么区别.很难说.可能type命令对输入流中的<code>Control-Z</code>字符有特殊处理.然而，用<code>c++ iostream</code>或<code>C stream</code>库的win程序员可以选择以文本模式或二进制模式打开文件，这会在读取文件时产生一些微小的区别</p>
<p>一个经典的读取文本文件的<code>C++</code>范例:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;a.txt&quot;</span>)</span></span>;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(ifs,line))&#123;</span><br><span class="line">        cout&lt;&lt;line&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在win上运行这个文件，会看到<code>Control-Z</code>被当作<code>end-of-file</code>字符;输出是:</p>
<p><code>第一行 1</code>(经译者测试，确实是这样，看来巨硬这么多年还是没更新<code>MCR</code>)</p>
<p>但是如果以2进制模式打开文件的话:<code>ifstream ifs(&quot;a.txt&quot;,ios::binary)</code></p>
<p>输出就是:</p>
<blockquote>
<p>line 1</p>
<p>?line 2    (经测试，译者的电脑上并没有打印出<code>?</code>)</p>
</blockquote>
<p>所以<code>Control-Z</code>字符只有在默认的以文本模式打开文件时才会被特殊处理，在二进制模式下就是普通字符.注意只有在windows上才会这样</p>
<p>在Linux上两种模式表现基本相同:</p>
<p><img  style="display:inline-block" src="https://gitee.com/salt3dfish/images/raw/master/hexo/22-04-07/2f9f03453642bf5a011d11b8334d1221.png" alt="image-20220407122942033"  /><img style="display:inline-block" src="https://gitee.com/salt3dfish/images/raw/master/hexo/22-04-07/f87fc6f4e4674ea3b402c5a0b1fa4f74.png" alt="image-20220407123119552"  /></p>
<p>那么究竟该怎么做?记住两件事:</p>
<ol>
<li>如果希望文件在文本模式下能被正确读取，不要在文件里插入<code>Control-Z</code>字符</li>
<li>如果文件中必须包含<code>Control-Z</code>，并且希望文件被正确读取，那么就以二进制模式打开文件</li>
</ol>
<p>正确读取表示用任何软件，即使你只在windows上编程(是家人就用linux)</p>
<h1 id="But-what-about-Control-D"><a href="#But-what-about-Control-D" class="headerlink" title="But what about Control-D?"></a>But what about Control-D?</h1><p>一些Linux用户此刻可能回想,”但是我用来结束shell输入的<code>Control-D</code>字符又是怎么回事捏?难道<code>Control-D</code>不是一个<code>end-of-file</code>字符吗?”</p>
    </div>
  </div>
</article> 
  </div>
  
<link rel="stylesheet" href="/css/footer.css">


<div id="footer"></div>
 
</body>